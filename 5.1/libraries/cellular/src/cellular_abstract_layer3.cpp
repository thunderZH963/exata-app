// Copyright (c) 2001-2013, SCALABLE Network Technologies, Inc.  All Rights Reserved.
//                          600 Corporate Pointe
//                          Suite 1200
//                          Culver City, CA 90230
//                          info@scalable-networks.com
//
// This source code is licensed, not sold, and is subject to a written
// license agreement.  Among other things, no portion of this source
// code may be copied, transmitted, disclosed, displayed, distributed,
// translated, used as the basis for a derivative work, or used, in
// whole or in part, for any program or purpose other than its intended
// use in compliance with the license agreement as part of the QualNet
// software.  This source code and certain of the algorithms contained
// within it are confidential trade secrets of Scalable Network
// Technologies, Inc. and may not be used as the basis for any other
// software, hardware, product or service.
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "api.h"
#include "partition.h"
#include "network.h"
#include "network_ip.h"

#include "cellular.h"
#include "cellular_abstract.h"
#include "cellular_layer3.h"
#include "cellular_abstract_layer3.h"
#include "mac_cellular.h"
#include "gui.h"

//#define CHANNEL_ALLOCATION 0 //uncomment it when channel option is used
                               // this option is not fully supported

#define BACKBONE_WIRED_IP 1    // Use Wired IP network as backbone
#define BACKBONE_WIRED_ATM 0   // Use ATM network as backbone
#define BACKBONE_WIRELESS_P2P 0 // Micorwave Link

#define DEBUG_NET2MAC 0 // inter network&mac
#define DEBUG_GENERAL 0 // General
#define DEBUG_NET2APP 0 // inter network&app
#define DEBUG_RR 0 // rr
#define DEBUG_MM 0 // mm
#define DEBUG_CC 0 // cc
#define DEBUG_SM 0 // Session management
#define DEBUG_CAC 0 // Call admission control
#define DEBUG_CONGESTION_CONTROL 0
#define DEBUG_HANDOVER 0 //Handover
#define DEBUG_CELLSELECTION 0 // Cell selection/reselection
#define DEBUG_POWERONOFF 0
#define DEBUG_RESOURCE 0 //Resource Allocation & Deallocation
#define DEBUG_SAMPLE 1 //Resource Usage Sampling
                       //Do not turn it off otherwise
                       //GUI cannot show the dynamic resource usage
                       //it is used for GUI or commandline,
                       //if you do not like the print out,
                       //just comment the printf.
#define SAMPLE_STDOUT    0 // Print bandwidth to std I/O
#define DEBUG_PROGRESS 0 // print out the simualtion progress

/////////////////////////////////////////////////////////////////////////
////BLOCK:UNITLITY FUNCTION
/////////////////////////////////////////////////////////////////////////

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractAddNetworkToMacMsgInfo
// LAYER      :: Layer3
// PURPOSE    :: Add networkToMac info field the message.
// PARAMETERS ::
// + node : Node* : Pointer to node.
// + msg : Message** : Point to message for node to process.
// + infoType : CellularAbstractInterlayerInfoType : Type of information
// + channelindex : int : Channel id used to transmit the msg
// + channelType : CellularAbstractChannelType : The CH type for transmit
// + recvSet : CellularAbstractReceiverSet : The receiver set
// + recvId : NodeAddress : Receiver's address
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractAddNetworkToMacMsgInfo(
        Node *node,
        Message **msg,
        CellularAbstractInterlayerInfoType infoType,
        int channelIndex,
        CellularAbstractChannelType channelType,
        CellularAbstractReceiverSet recvSet,
        NodeAddress recvId)
{
    CellularAbstractNetowrkToMacMsgInfo *msgInfo;

    MESSAGE_InfoAlloc(
        node,
        (*msg),
        sizeof(CellularAbstractNetowrkToMacMsgInfo));
    msgInfo =
        (CellularAbstractNetowrkToMacMsgInfo *) MESSAGE_ReturnInfo((*msg));

    msgInfo->infoType=infoType;
    msgInfo->channelIndex=channelIndex;

    msgInfo->channelType = channelType;
    msgInfo->recvSet = recvSet;
    msgInfo->recvId = recvId;

    if (DEBUG_GENERAL)
    {
        printf("at %015" TYPES_64BITFMT "d node %d:Add info fied to"
               " the msg towards MAC with infoType %d, channelindex %d,"
               " channel type %d\n",
               node->getNodeTime(), node->nodeId,
               msgInfo->infoType,
               msgInfo->channelIndex,
               msgInfo->channelType);
        fflush(stdout);
    }
}//CellularAbstractAddNetworkToMacMsgInfo

///***********************************************************************
// /**
// FUNCTION   :: CellularAbstractRemoveLayer3MsgHeader
// LAYER      :: Layer3
// PURPOSE    :: Remove Message Layer 3 header.
// PARAMETERS ::
// + node : Node* : Pointer to node.
// + msg : Message* : Point to message for node to process.
// + protocolDiscriminator : CellularAbstractInterlayerInfoType : Prot. desc.
// + messageType : CellularAbstractMessageType : Type of message
// RETURN     :: void : NULL
// **/
///************************************************************************
static
void CellularAbstractRemoveLayer3MsgHeader(
        Node *node,
        Message *msg,
        CellularProtocolDiscriminator *protocolDiscriminator,
        CellularAbstractMessageType *messageType)
{
    CellularGenericLayer3MsgHdr *layer3MsgHeader;

    layer3MsgHeader = (CellularGenericLayer3MsgHdr *) msg->packet;
    *protocolDiscriminator = layer3MsgHeader->protocolDiscriminator;
    *messageType = layer3MsgHeader->messageType;

    MESSAGE_RemoveHeader(
        node,
        msg,
        sizeof(CellularGenericLayer3MsgHdr),
        TRACE_CELLULAR);
}//CellularAbstractRemoveLayer3MsgHeader

//************************************************************************
// /**
// FUNCTION   :: CellularAbstractAddLayer3MsgHeader
// LAYER      :: Layer3
// PURPOSE    :: Add Message Layer 3 header.
// PARAMETERS ::
// + node : Node* : Pointer to node.
// + msg : Message** : Point to message for node to process.
// + protocolDiscriminator : CellularAbstractInterlayerInfoType : Prot desc.
// + messageType : CellularAbstractMessageType : Type of message
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractAddLayer3MsgHeader(
        Node *node,
        Message **msg,
        CellularProtocolDiscriminator protocolDiscriminator,
        CellularAbstractMessageType messageType)
{
    int hdrSize;
    CellularGenericLayer3MsgHdr *layer3MsgHeader;

    hdrSize = sizeof(CellularGenericLayer3MsgHdr);
    MESSAGE_AddHeader(node, (*msg), hdrSize, TRACE_CELLULAR);

    layer3MsgHeader =
        (CellularGenericLayer3MsgHdr *) MESSAGE_ReturnPacket((*msg));
    layer3MsgHeader->protocolDiscriminator = protocolDiscriminator;
    layer3MsgHeader->messageType = messageType;

    if (DEBUG_GENERAL)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d:Add layer3 "
            "header to the protocol msg"
            "towards MAC with discriptor %d, msg type %d\n",
            node->getNodeTime(), node->nodeId,
            layer3MsgHeader->protocolDiscriminator,
            layer3MsgHeader->messageType);
        fflush(stdout);
    }
}//CellularAbstractRemoveLayer3MsgHeader

//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3BuildMessage
// LAYER      :: Layer3
// PURPOSE    :: Add Message Layer 3 header.
// PARAMETERS ::
// + node : Node* : Pointer to node.
// + msg : Message** : Point to the meg for node to process.
// + layerType : short : Mesage layer
// + protocolType : short : Message prtocol type
// + eventType : short : Type of event
// + msgPkt : void * : Point to the packet in the message
// + pktSize : int : Size of the packet
// RETURN     :: void : NULL
// **/
//**********************************************************************
static void
CellularAbstractLayer3BuildMessage(Node *node,
                                   Message **msg,
                                   short layerType,
                                   short protocolType,
                                   short eventType,
                                   void *msgPkt,
                                   int pktSize)
{
    void *pktData = NULL;
    *msg = MESSAGE_Alloc(
                        node,
                        layerType,
                        protocolType,
                        eventType);

    if (msgPkt != NULL&&pktSize > 0)
    {
        MESSAGE_PacketAlloc(node, (*msg), pktSize, TRACE_CELLULAR);
        pktData = (unsigned char*) MESSAGE_ReturnPacket((*msg));
        memcpy(pktData, msgPkt, pktSize);
    }
    if (DEBUG_GENERAL)
    {
        printf("at %015" TYPES_64BITFMT "d node %d:build a"
               "layer3 message\n",
                node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}

//********************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3StartTimer
// LAYER      :: Layer3
// PURPOSE    :: Start Layer 3 timer
// PARAMETERS ::
// + node                  : Node*      : Pointer to node.
// + delay                 : clocktype  : Timer duration
// + infoData              : void *     : Point to info data ass/w timer
// + infoDataSize          : int        : Size of the info data
// RETURN     :: Message * : The timer message
// **/
//********************************************************************
static
Message* CellularAbstractLayer3StartTimer(Node        *node,
                                          clocktype   delay,
                                          void        *infoData,
                                          int         infoDataSize)
{
    Message *timerMsg;
    void *timerInfo;

    timerMsg = MESSAGE_Alloc(
                    node,
                    NETWORK_LAYER,
                    NETWORK_PROTOCOL_CELLULAR,
                    MSG_NETWORK_CELLULAR_TimerExpired);

    if (infoData != NULL && infoDataSize > 0)
    {
        MESSAGE_InfoAlloc(node, timerMsg, (unsigned int)infoDataSize);
        timerInfo = (unsigned char*) MESSAGE_ReturnInfo(timerMsg);

        memcpy(timerInfo, infoData, infoDataSize);
    }
    MESSAGE_Send(node, timerMsg, delay);

    if (DEBUG_GENERAL)
    {
        printf("node %d:schedule a timer\n",node->nodeId);
        fflush(stdout);
    }
    return timerMsg;
} // End of CellularAbstractLayer3StartTimer //

//*******************************************************************

// /**
// FUNCTION   :: CellularAbstractSendOutMsgOverIP
// LAYER      :: Layer3
// PURPOSE    :: Send message to next hop.
// PARAMETERS ::
// + node             : Node*        : Pointer to node.
// + msg              : Message*     : Point to msg for node to process
// + nextHopId        : NodeAddress  : Next Hop's node address
// + delay            : clocktype    : Delay for transmission
// RETURN     :: void : NULL
// **/
//********************************************************************
static
void CellularAbstractSendOutMsgOverIP(Node *node,
                                      Message *msg,
                                      NodeAddress nextHopId,
                                      clocktype delay)
{

    NodeAddress destNodeAddress;
    destNodeAddress =
        MAPPING_GetDefaultInterfaceAddressFromNodeId(node, nextHopId);

    msg->layerType = NETWORK_LAYER;
    msg->protocolType = NETWORK_PROTOCOL_IP;
    msg->eventType = MSG_NETWORK_FromTransportOrRoutingProtocol;

    if (delay == 0)
    {
        NetworkIpSendRawMessage(
            node,
            msg,
            ANY_IP,                     //sourceAddr,
            destNodeAddress,            //destinationAddress,
            ANY_INTERFACE,              //outgoingInterface,
            IPTOS_PREC_INTERNETCONTROL, // priority
            IPPROTO_CELLULAR,           // protocol
            0);                          // ttl, default is used
    }
    else
    {
        NetworkIpSendRawMessageWithDelay(
            node,
            msg,
            ANY_IP,                     //sourceAddr,
            destNodeAddress,            //destinationAddress,
            ANY_INTERFACE,              //outgoingInterface,
            IPTOS_PREC_INTERNETCONTROL, // priority
            IPPROTO_CELLULAR,           // protocol
            0,                          // ttl, default is used
            delay);                     // delay
    }
}

//*************************************************************************
// /**
// FUNCTION   :: CCellularAbstractLayer3SendProtocolMsgToMac
// LAYER      :: Layer3
// PURPOSE    :: Semd message to radio interface.
// PARAMETERS ::
// + node : Node* : Pointer to node.
// + msg  : Message* : Point to message for node to process.
// + protocolDiscriminato: CellularProtocolDiscriminator : protocol desc.
// + messageType : CellularAbstractMessageType : Msg type of the layer3 msg
// + infoType : CellularAbstractInterlayerInfoType : Type of information
// + channelIndex : int : Channel id used to transmit the msg
// + channelType : CellularAbstractChannelType : The type of the ch used
// + recvSet : CellularAbstractReceiverSet              : The receiver set
// + recvId : NodeAddress                              : Receiver's address
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractLayer3SendProtocolMsgToMac(
        Node *node,
        Message *msg,
        CellularProtocolDiscriminator protocolDiscriminator,
        CellularAbstractMessageType messageType,
        CellularAbstractInterlayerInfoType infoType,
        int channelIndex,
        CellularAbstractChannelType channelType,
        CellularAbstractReceiverSet recvSet,
        NodeAddress recvId)
{

    CellularLayer3Data *nwCellularData;
    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //add hearder,add info
    CellularAbstractAddNetworkToMacMsgInfo(
                                            node,
                                            &msg,
                                            infoType,
                                            channelIndex,
                                            channelType,
                                            recvSet,
                                            recvId);
    CellularAbstractAddLayer3MsgHeader(
                                        node,
                                        &msg,
                                        protocolDiscriminator,
                                        messageType);

    MESSAGE_SetInstanceId(msg, (short)nwCellularData->interfaceIndex);

    // send to MAC
    MESSAGE_Send(node, msg, 0);

    if (DEBUG_NET2MAC)
    {
        printf(
            "node %d NW-MAC: send msg with Fromnetwork"
            "to mac on channel %d to node %d\n",
            node->nodeId,
            channelIndex,
            recvId);
        fflush(stdout);
    }
}//CellularAbstractLayer3SendProtocolMsgToMac
//*************************************************************************
// /**
// FUNCTION   :: CCellularAbstractLayer3SendProtocolMsgToMac
// LAYER      :: Layer3
// PURPOSE    :: Semd message to radio interface. (reloaded)
// PARAMETERS ::
// + node             : Node*    : Pointer to node.
// + msg              : Message* : Point to message for node to process.
// + protocolDiscriminato: CellularProtocolDiscriminator  : protocol desc.
// + messageType      : CellularAbstractMessageType  : Msg type
// + infoType         : CellularAbstractInterlayerInfoType : Type of info.
// + channelindex     : int                                : Channel id
// + channelType      : CellularAbstractChannelType        : CH type
// + recvSet          : CellularAbstractReceiverSet        : The receiver set
// + recvId           : NodeAddress                        : Receiver's addr
// + delay            : clocktype                          : Dealy
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractLayer3SendProtocolMsgToMac(
        Node *node,
        Message *msg,
        CellularProtocolDiscriminator protocolDiscriminator,
        CellularAbstractMessageType messageType,
        CellularAbstractInterlayerInfoType infoType,
        int channelIndex,
        CellularAbstractChannelType channelType,
        CellularAbstractReceiverSet recvSet,
        NodeAddress recvId,
        clocktype delay)
{

    CellularLayer3Data *nwCellularData;
    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //add hearder,add info
    CellularAbstractAddNetworkToMacMsgInfo(
                                            node,
                                            &msg,
                                            infoType,
                                            channelIndex,
                                            channelType,
                                            recvSet,
                                            recvId);
    CellularAbstractAddLayer3MsgHeader(
                                        node,
                                        &msg,
                                        protocolDiscriminator,
                                        messageType);

    MESSAGE_SetInstanceId(msg, (short) nwCellularData->interfaceIndex);

    // send to MAC
    MESSAGE_Send(node, msg, delay);

    if (DEBUG_NET2MAC)
    {
        printf(
            "node %d NW-MAC: send msg with Fromnetwork"
            "to mac on channel %d to node %d\n",
            node->nodeId,
            channelIndex,
            recvId);
    }
}//CellularAbstractLayer3SendProtocolMsgToMac

//**********************************************************************
// FUNCTION   :: CellularAbstractSendMsgOverNonCellularLink
// LAYER      :: Layer3
// PURPOSE    :: Send message over non Cellular link.
//               This fuction is used to send msg over the links
//               connecting BS-SC,SC-gateway,and others....
//               it should be further developed to support
// PARAMETERS ::
// + node             : Node*      : Pointer to node.
// + msg              : Message*   : Point to message for node to process.
// + protocolDiscriminato: CellularProtocolDiscriminator  : protocol desc.
// + messageType      : CellularAbstractMessageType  : Message type
// RETURN     :: void : NULL
//************************************************************************
static
void CellularAbstractSendMsgOverNonCellularLink(
        Node *node,
        Message *msg,
        CellularProtocolDiscriminator protocolDiscriminator,
        CellularAbstractMessageType messageType)
{
    CellularAbstractNetowrkToMacMsgInfo *msgInfo;
    NodeAddress nextHopId;

    CellularAbstractAddLayer3MsgHeader( node,
                                        &msg,
                                        protocolDiscriminator,
                                        messageType);
    msgInfo =
        (CellularAbstractNetowrkToMacMsgInfo *)MESSAGE_ReturnInfo(msg);


    nextHopId = msgInfo->recvId;

    // send
    if (BACKBONE_WIRED_IP)
    {
        CellularAbstractSendOutMsgOverIP(node, msg, nextHopId, 0);
    }
    else if (BACKBONE_WIRED_ATM)
    {
        //TODO: support ATM/MICROWAVE/.......
        //CellularAbstractSendOutMsgOverATM(node, msg, nextHopId, 0);
    }
    else if (BACKBONE_WIRELESS_P2P)
    {
        //TODO: support ATM/MICROWAVE/.......
        //CellularAbstractSendOutMsgOverWirelessP2P(node, msg, nextHopId,0);
    }
    if (DEBUG_NET2MAC )
    {
        printf(
            "node %d NW-MAC: send msg with From network"
            "over non cellular links to node %d \n",
            node->nodeId,
            nextHopId);
        fflush(stdout);
    }
}
//*******************************************************************
// FUNCTION   :: CellularAbstractSendCallIndication
// LAYER      :: Layer3
// PURPOSE    :: Send indication to remote SC.
// PARAMETERS ::
// + node             : Node*  : Pointer to node.
// + callIndicationPkt: void*  : Point to indicaion.
// + pktSize          : int    : size of the message
// + callIndicationType: CellularAbstractCallIndicationType:Type of call ind.
// + nextHopId        : NodeAddress : next hop the indi. should be sent to
// RETURN     :: void : NULL
//********************************************************************
static
void CellularAbstractSendCallIndication(
        Node *node,
        void *callIndicationPkt,
        int pktSize,
        CellularAbstractCallIndicationType callIndicationType,
        NodeAddress nextHopId)
{
    Message *msg;
    CellularAbstractMessageType messageType =
        CELLULAR_ABSTRACT_MESSAGE_TYPE_INVALID;
    CellularProtocolDiscriminator protocolDiscriminator;

    msg = MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        msg,
                        pktSize,
                        TRACE_CELLULAR);

    memcpy(MESSAGE_ReturnPacket(msg), callIndicationPkt, pktSize);

    if (callIndicationType == CELLULAR_ABSTRACT_CALL_SETUP_INDICATION)
    {
        messageType = CELLULAR_ABSTRACT_CC_CALL_SETUP_INDICATION;
    }
    else if (callIndicationType ==
        CELLULAR_ABSTRACT_CALL_CONNECT_INDICATION)
    {
        messageType = CELLULAR_ABSTRACT_CC_CALL_CONNECT_INDICATION;
    }
    else if (callIndicationType ==
        CELLULAR_ABSTRACT_CALL_ALERTING_INDICATION)
    {
        messageType = CELLULAR_ABSTRACT_CC_CALL_ALERTING_INDICATION;
    }
    else if (callIndicationType ==
        CELLULAR_ABSTRACT_CALL_DISCONNECT_INDICATION)
    {
        messageType = CELLULAR_ABSTRACT_CC_CALL_DISCONNECT_INDICATION;
    }
    else if (callIndicationType ==
        CELLULAR_ABSTRACT_PDP_CONTEXT_INDICATION)
    {
        messageType=CELLULAR_ABSTRACT_SM_PDP_CONTEXT_INDICATION;
    }

    ERROR_Assert(messageType != CELLULAR_ABSTRACT_MESSAGE_TYPE_INVALID,
                 "Unsupported Call Indication");

    //add info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &msg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //add IP header
    if (callIndicationType == CELLULAR_ABSTRACT_PDP_CONTEXT_INDICATION)
    {
        protocolDiscriminator = CELLULAR_PD_SM;

    }
    else
    {
        protocolDiscriminator = CELLULAR_PD_CC;
    }

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        msg,
        protocolDiscriminator,
        messageType);
}

///////////////////////////////////////////////////////////////////////
///BLOCK:BUILD PROTOCOL PAKCET
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
//BLOCK MS FUNCITON
////////////////////////////////////////////////////////////////////////
//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsStopCallControlTimer
// LAYER      :: Layer3
// PURPOSE    :: Stop the application's call control timer
// PARAMETERS ::
// + node             : Node*    : Pointer to node.
// + itemIndex        : int*     : Point to the index of the application
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractMsStopCallControlTimer(Node *node, int itemIndex)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;
    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303);

        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303 = NULL;
    }

    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT305 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT305);

        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT305 = NULL;
    }

    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT308 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT308);
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT308 = NULL;
    }

    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT310 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT310);
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT310 = NULL;
    }

    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT313 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT313);
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT313 = NULL;
    }

    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT323 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT323);
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT323 = NULL;
    }

    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT332 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT332);
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT332 = NULL;
    }

    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT335 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT335);
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT335 = NULL;
    }
}

//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsCreateAppInfoItem
// LAYER      :: Layer3
// PURPOSE    :: Create a application information record
// PARAMETERS ::
// + node             : Node*     : Pointer to node.
// + transactionId    : int       : Thansaction Id of this applicaiton.
// + appId            : int       : Application Id
// + applicationType  : CellularAbstractApplicationType : application type
// + srcNodeId     : NodeAddress  : Application's src address
// + destNodeId    : NodeAddress  : Application's dest address
// + numChannelRequire: int       : Number of the channel required
// + bandwidthRequired: double    : Resource requirement for the application
// + callSrcDestType  : CellularAbstractCallSrcDestType : call src&dest type
// + itemIndex        : int*      : Point to the index of the application
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractMsCreateAppInfoItem(
         Node *node,
         int transactionId,
         int appId,
         CellularAbstractApplicationType applicationType,
         NodeAddress srcNodeId,
         NodeAddress destNodeId,
         int numChannelRequired,
         double bandwidthRequired,
         CellularAbstractCallSrcDestType callSrcDestType,
         int *itemIndex)
{
    int i;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;
    BOOL found = FALSE;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    //look for the first un used item
    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS; i ++)
    {
        if (nwCellularAbstractMsInfo->msAppInfo[i].inUse == FALSE)
        {
            found=TRUE;
            break;
        }
    }

    //make sure there is enough room to keep these information
    ERROR_Assert(
        found==TRUE,
        "TOO MANY CONCURRENT TRANSACIONS!INCREASE THE value of"
        "CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS!");

    //update the item
    nwCellularAbstractMsInfo->msAppInfo[i].inUse = TRUE;
    nwCellularAbstractMsInfo->msAppInfo[i].appId = appId;
    nwCellularAbstractMsInfo->msAppInfo[i].transactionId = transactionId;

    nwCellularAbstractMsInfo->msAppInfo[i].applicationType =
                                                    applicationType;

    nwCellularAbstractMsInfo->msAppInfo[i].srcMsNodeId = srcNodeId;
    nwCellularAbstractMsInfo->msAppInfo[i].destMsNodeId = destNodeId;

    nwCellularAbstractMsInfo->msAppInfo[i].numChannelRequired =
                                                    numChannelRequired;

    nwCellularAbstractMsInfo->msAppInfo[i].bandwidthRequired =
                                                    bandwidthRequired;

    nwCellularAbstractMsInfo->msAppInfo[i].callSrcDestType =
                                                    callSrcDestType;

    nwCellularAbstractMsInfo->msAppInfo[i].isDedicatedChannelAssigned =
                                                                    FALSE;

    nwCellularAbstractMsInfo->msAppInfo[i].timerT303 = NULL;
    nwCellularAbstractMsInfo->msAppInfo[i].timerT305 = NULL;
    nwCellularAbstractMsInfo->msAppInfo[i].timerT308 = NULL;
    nwCellularAbstractMsInfo->msAppInfo[i].timerT310 = NULL;
    nwCellularAbstractMsInfo->msAppInfo[i].timerT313 = NULL;
    nwCellularAbstractMsInfo->msAppInfo[i].timerT323 = NULL;
    nwCellularAbstractMsInfo->msAppInfo[i].timerT335 = NULL;

    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        nwCellularAbstractMsInfo->msAppInfo[i].msNodeId = destNodeId;
    }
    else if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        nwCellularAbstractMsInfo->msAppInfo[i].msNodeId = srcNodeId;
    }

    nwCellularAbstractMsInfo->msAppInfo[i].channelRequestForApplication =
        (CellularAbstractChannelRequestInfo *)
            MEM_malloc(sizeof(CellularAbstractChannelRequestInfo));

    memset(
        nwCellularAbstractMsInfo->msAppInfo[i].channelRequestForApplication,
        0,
        sizeof(CellularAbstractChannelRequestInfo));

    if (DEBUG_GENERAL)
    {
        printf(
            "node %d: add one appinfo with tranId %d for"
            "src %d dest %d msnode %d for appId %d\n",
            node->nodeId,
            nwCellularAbstractMsInfo->msAppInfo[i].transactionId,
            nwCellularAbstractMsInfo->msAppInfo[i].srcMsNodeId,
            nwCellularAbstractMsInfo->msAppInfo[i].destMsNodeId,
            nwCellularAbstractMsInfo->msAppInfo[i].msNodeId,
            nwCellularAbstractMsInfo->msAppInfo[i].appId);
        fflush(stdout);
    }
    *itemIndex = i; //return the index
}

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsLookForAppInfoItem
// LAYER      :: Layer3
// PURPOSE    :: Look for a application information record by the nodeId
//               and transaction Id
// PARAMETERS ::
// + node             : Node*    : Pointer to node.
// + transactionId    : int      : Thansaction Id of this applicaiton.
// + srcNodeId     : NodeAddress : The node address associate w/ this record
// + itemIndex        : int*     : Point to the index of the application
// RETURN     ::  BOOL : find or not
// **/
//***************************************************************************
static
BOOL CellularAbstractMsLookForAppInfoItem(Node *node,
                                          int transactionId,
                                          NodeAddress srcNodeId,
                                          int *itemIndex)
{
    int i;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;
    BOOL found = FALSE;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    //look for the first un used item
    if (DEBUG_GENERAL)
    {
        for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS; i ++)
        {
            if (nwCellularAbstractMsInfo->msAppInfo[i].inUse == TRUE)
            {
                printf(
                    "item %d appID %d src %d, dest %d,trans %d,msnode Id%d\n",
                    i,
                    nwCellularAbstractMsInfo->msAppInfo[i].appId,
                    nwCellularAbstractMsInfo->msAppInfo[i].srcMsNodeId,
                    nwCellularAbstractMsInfo->msAppInfo[i].destMsNodeId,
                    nwCellularAbstractMsInfo->msAppInfo[i].transactionId,
                    nwCellularAbstractMsInfo->msAppInfo[i].msNodeId);
                fflush(stdout);
            }
        }
        printf("input is ms %d tran %d\n", srcNodeId, transactionId);
        fflush(stdout);
    }

    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS; i ++)
    {
        if (nwCellularAbstractMsInfo->msAppInfo[i].inUse == TRUE &&
            nwCellularAbstractMsInfo->msAppInfo[i].msNodeId == srcNodeId &&
            nwCellularAbstractMsInfo->msAppInfo[i].transactionId ==
                                                            transactionId)
        {
            found = TRUE;
            if (DEBUG_RR)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d: RR found"
                    "msNode %d transactionid %d"
                    "type %d with bandwdith %f\n",
                    node->getNodeTime(),
                    node->nodeId,
                    nwCellularAbstractMsInfo->msAppInfo[i].msNodeId,
                    transactionId,
                    nwCellularAbstractMsInfo->msAppInfo[i].applicationType,
                    nwCellularAbstractMsInfo->
                                            msAppInfo[i].bandwidthRequired);
                fflush(stdout);
            }
            break;
        }
    }

    *itemIndex = i; //return index
    return found;
}

//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsLookForAppItemByAppId
// LAYER      :: Layer3
// PURPOSE    :: Look for a application information record by
//               the appId and src and dest's address
// PARAMETERS ::
// + node             : Node*        : Pointer to node.
// + appId            : int          : Application Id
// + srcNodeId        : NodeAddress  : Application's src address
// + destNodeId       : NodeAddress  : Application's dest address
// + itemIndex        : int*         : Point to the index of the application
// + transactionId    : int*         : Point to the teansactionId
// RETURN     :: BOOL : found or not
// **/
//**********************************************************************
static
BOOL CellularAbstractMsLookForAppItemByAppId(
         Node *node,
         int appId,
         NodeAddress srcNodeId,
         NodeAddress destNodeId,
         int *itemIndex,
         int *transactionId)
{
    int i;
    BOOL found;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *) node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    //look for the  item
    found = FALSE;
    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS; i ++)
    {
            if (nwCellularAbstractMsInfo->msAppInfo[i].inUse == TRUE &&
                nwCellularAbstractMsInfo->msAppInfo[i].appId == appId &&
                nwCellularAbstractMsInfo->msAppInfo[i].srcMsNodeId ==
                                                            srcNodeId &&
                nwCellularAbstractMsInfo->msAppInfo[i].destMsNodeId ==
                                                            destNodeId)
            {

                found=TRUE;
                if (DEBUG_RR)
                {
                    printf(
                        "at %015" TYPES_64BITFMT "d Node %d MT:"
                        "RR found msnode %d type %d with bandwdith %f\n",
                         node->getNodeTime(),
                        node->nodeId,
                        nwCellularAbstractMsInfo->msAppInfo[i].msNodeId,
                        nwCellularAbstractMsInfo->
                                            msAppInfo[i].applicationType,
                        nwCellularAbstractMsInfo->
                                            msAppInfo[i].bandwidthRequired);
                    fflush(stdout);
                }
                break;
            }
    }

    *itemIndex = i;
    *transactionId = nwCellularAbstractMsInfo->msAppInfo[i].transactionId;
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d Node %d: RR found msnode %d"
            "transactionId %d for AppID %d\n",
            node->getNodeTime(),
            node->nodeId,
            nwCellularAbstractMsInfo->msAppInfo[i].msNodeId,
            nwCellularAbstractMsInfo->msAppInfo[i].transactionId,
            nwCellularAbstractMsInfo->msAppInfo[i].appId);
        fflush(stdout);
    }
    return found;
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsResetAppItem
// LAYER      :: Layer3
// PURPOSE    :: Reset the application information record by the record index
// PARAMETERS ::
// + node             : Node*     : Pointer to node.
// + itemIndex        : int*      : Point to the index of the application
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractMsResetAppItem(Node *node, int itemIndex)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    nwCellularAbstractMsInfo->msAppInfo[itemIndex].inUse = FALSE;
    nwCellularAbstractMsInfo->
        msAppInfo[itemIndex].isDedicatedChannelAssigned = FALSE;
    if (nwCellularAbstractMsInfo->
        msAppInfo[itemIndex].channelRequestForApplication != NULL)
    {
        if (nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication->
                channelRequestMsg != NULL)
        {
            MESSAGE_CancelSelfMsg(node, nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication->
                channelRequestMsg);
            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication->
                channelRequestMsg = NULL;
        }

        if (nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication->
                channelRequestTimer != NULL)
        {
            MESSAGE_CancelSelfMsg(node, nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication->
                channelRequestTimer);
            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication->
                channelRequestTimer = NULL;
        }

        if (nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication->
                timerT3126Msg != NULL)
        {
            MESSAGE_CancelSelfMsg(node, nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication->
                timerT3126Msg);
            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication->
                timerT3126Msg = NULL;
        }
        if (nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication->
                timerT3240Msg != NULL)
        {
            MESSAGE_CancelSelfMsg(node, nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication->
                timerT3240Msg);
            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication->
                timerT3240Msg = NULL;
        }

        MEM_free(
            nwCellularAbstractMsInfo->
                        msAppInfo[itemIndex].channelRequestForApplication);

        nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].channelRequestForApplication = NULL;
    }
    CellularAbstractMsStopCallControlTimer(node, itemIndex);

    if (DEBUG_GENERAL)
    {
        printf("node %d reset appInfo\n", node->nodeId);
        fflush(stdout);
    }
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsBuildChannelRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Build the channel request msg
// PARAMETERS ::
// + node                : Node *     : Pointer to node.
// + msg                 : Message ** : Point to the channel request msg
// + estCause            : CellularEstCause : Eastablish cause for the chReq
// + numChannelRequired  : int        : Number of channel required
// + bandwidthRequired   : double     : Bandwidth requirement
// + channelRequestType  : CellularAbstractChannelRequestType :Types of chReq
// + transactionId       : int        : Transaction id of the application
// + pageId              : int        : Page id for this channel request
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractMsBuildChannelRequestMsg(
        Node            *node,
        Message         **msg,
        CellularEstCause   estCause,
        int numChannelRequired,
        double bandwidthRequired,
        CellularAbstractChannelRequestType channelRequestType,
        int transactionId,
        int pageReqId)
{
    CellularAbstractChannelRequestPkt *channelReqPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    *msg = MESSAGE_Alloc(
              node,
              MAC_LAYER,
              MAC_PROTOCOL_CELLULAR,
              MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
            node,
            *msg,
            sizeof(CellularAbstractChannelRequestPkt),
            TRACE_CELLULAR);

    channelReqPkt =
        (CellularAbstractChannelRequestPkt *) MESSAGE_ReturnPacket((*msg));

    channelReqPkt->msNodeId = node->nodeId;

    channelReqPkt->msNodeAddr =
        MAPPING_GetDefaultInterfaceAddressFromNodeId(node, node->nodeId);

    channelReqPkt->bsNodeId =
        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId;

    channelReqPkt->bsNodeAddr =
        nwCellularAbstractMsInfo->
        associatedBsSectorInfo->associatedBSNodeAddress;

    channelReqPkt->sectorId =
        nwCellularAbstractMsInfo->
        associatedBsSectorInfo->associatedSectorId;

    channelReqPkt->estCause = estCause;
    channelReqPkt->numChannelRequired = numChannelRequired;
    channelReqPkt->bandwidthRequired = bandwidthRequired;

    channelReqPkt->channelRequestType = channelRequestType;
    channelReqPkt->transactionId = transactionId; //0 for not a applicaton
    channelReqPkt->pageReqId = pageReqId;// 0 for not a page response

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW-RR: finish building"
            "the channel req msg with pageId %d"
            "tranId %d cause %d and #channel%d bandwidth %f\n",
            node->getNodeTime(),
            node->nodeId,
            channelReqPkt->pageReqId,
            channelReqPkt->transactionId,
            channelReqPkt->estCause,
            channelReqPkt->numChannelRequired,
            channelReqPkt->bandwidthRequired);
        fflush(stdout);
    }
}//CellularAbstractMsBuildChannelRequestMsg

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsPrepareChannelRequest
// LAYER      :: Layer3
// PURPOSE    :: Prepare the channel request msg
//               the function is used to build the channel request msg,
//               and schedule a timer to send the first req
// PARAMETERS ::
// + node                : Node *   : Pointer to node.
// + msChannelReqInfo    : CellularAbstractChannelRequestInfo * :
//                         Point to the channel request Info strcture
// + estCause            : CellularEstCause  : Eastablish cause
// + numChannelRequired  : int               : Number of channel required
// + bandwidthRequired   : double            : Bandwidth requirement
// + channelRequestType  : CellularAbstractChannelRequestType :Type of chReq
// + transactionId       : int               : Trans id of the application
// + pageId              : int               : Page id for this chReq
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractMsPrepareChannelRequest(
         Node *node,
         CellularAbstractChannelRequestInfo *msChannelReqInfo,
         CellularEstCause estCause,
         int numChannelReq,
         double bandwidthRequired,
         CellularAbstractChannelRequestType channelRequestType,
         int transactionId,
         int pageReqId)
{
    int slotsToWait;
    CellularAbstractMsChannelRequestTimerInfo timerInfo;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW-RR: in prepare"
            "CH REQ and schedule the channel request timer\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo= nwCellularAbstractData->msLayer3Info;

    msChannelReqInfo->isRequestingChannel = TRUE;
    msChannelReqInfo->numChannelRequestAttempts = 0;

    msChannelReqInfo->channelRequestMsg = NULL;
    msChannelReqInfo->channelRequestTimer = NULL;
    msChannelReqInfo->timerT3126Msg = NULL;
    msChannelReqInfo->timerT3240Msg = NULL;
    msChannelReqInfo->reqInitTime = node->getNodeTime();

    slotsToWait =
        (int)(RANDOM_erand(nwCellularData->randSeed) *
        CELLULAR_RANDACCESS_S *
        DefaultCellularAbstractSlotNumberPerFrame);

    //build the channel req
    //the numChannelReq is 1 when bandwidth option is used.
    //when numchannel is used bandwdith is 0;
    //but be consistece with application setting
    CellularAbstractMsBuildChannelRequestMsg(
        node,
        &msChannelReqInfo->channelRequestMsg,
        estCause,numChannelReq,
        bandwidthRequired,
        channelRequestType, // CELLULAR_ABSTRACT_CHANNEL_REQUEST_GENERAL
        transactionId,
        pageReqId);

    //update the stats
    nwCellularAbstractMsInfo->stats.numChannelRequestAttempt ++;

    //schedule a channel request timer to send the first CH REQ
    timerInfo.timerType =
        MSG_NETWORK_CELLULAR_WaitForChannelRequestResponseTimer;

    timerInfo.transactionId = transactionId;
    timerInfo.srcNodeId = node->nodeId;

    msChannelReqInfo->channelRequestTimer =
        CellularAbstractLayer3StartTimer(
            node,
            slotsToWait * DefaultCellularSlotDuration,
            &timerInfo,
            sizeof(CellularAbstractMsChannelRequestTimerInfo));

    if (DEBUG_PROGRESS)
    {
        char clockStr1[MAX_STRING_LENGTH];
        char clockStr2[MAX_STRING_LENGTH];
        char clockStr3[MAX_STRING_LENGTH];
        ctoa(slotsToWait * DefaultCellularSlotDuration, clockStr1);
        ctoa(node->getNodeTime(), clockStr2);
        ctoa(slotsToWait * DefaultCellularSlotDuration
             + node->getNodeTime(),
             clockStr3);
        printf("at %015" TYPES_64BITFMT "d node %d wait for slot %d %s "
               "the first CHREQ attemp future %s\n",
               node->getNodeTime(),
               node->nodeId,
               slotsToWait,
               clockStr1,
               clockStr3);
        fflush(stdout);
    }
}
///*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsPrepareLocationUpdate
// LAYER      :: Layer3
// PURPOSE    :: Prepare the location update
//               the function is used to build the channel request msg,
//               and schedule a timer to send the first req
// PARAMETERS ::
// + node                : Node *   : Pointer to node.
// + estCause            : CellularEstCause : The cause to build RR conn.
// + locUpdateType  : CellularAbstractLocationUpdatingType:Type of locUpdate
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractMsPrepareLocationUpdate(
         Node *node,
         CellularEstCause estCause,
         CellularAbstractLocationUpdatingType locUpdateType)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    CellularAbstractChannelRequestInfo *msChannelReqInfo;

    if (DEBUG_MM || DEBUG_PROGRESS)
    {
        char clockStr[MAX_STRING_LENGTH];
        ctoa(node->getNodeTime(), clockStr);
        printf("at %015" TYPES_64BITFMT "d node %d NW-MM:"
               "in prepare the location update"
               "by building the channel request\n",
                node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    //intiate the request
    nwCellularAbstractMsInfo->isLocationUpdateInProgress = TRUE;
    nwCellularAbstractMsInfo->locationUpdatingType = locUpdateType;
    msChannelReqInfo =
        nwCellularAbstractMsInfo->channelReqForLocationUpdate;

    //PREPARE THE CHANNEL REQUEST MSG
    CellularAbstractMsPrepareChannelRequest(
        node,
        msChannelReqInfo,
        estCause,
        1,
        CELLULAR_ABSTRACT_BANDWIDTH_FOR_LOCATION_UPDATE,
        CELLULAR_ABSTRACT_CHANNEL_REQUEST_GENERAL,
        0,
        0);//transactioId 0 page Id 0
}//prepare location update

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleSystemInformation
// LAYER      :: Layer3
// PURPOSE    :: Handle BS system broadcast inoformation
// PARAMETERS ::
// + node                : Node *   : Pointer to node.
// + msg                 : Messae * : Message to be handled
// RETURN     :: void : NULL
// **/
///*************************************************************************
static
void CellularAbstractMsHandleSystemInformation(Node *node, Message *msg)
{
    CellularAbstractBsSystemInfo *sysInfo;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    CellularAbstractBsSectorCandidate *newCandidate;
    CellularAbstractBsSectorCandidate *currrentCandidate;
    BOOL found=FALSE;

    if (DEBUG_GENERAL)
    {
        printf("node %d NW: in handle system infomation packet\n",
            node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    //update stats
    nwCellularAbstractMsInfo->stats.numSystemInfoRecvd ++;

    sysInfo = (CellularAbstractBsSystemInfo *)(MESSAGE_ReturnPacket(msg));

    if (nwCellularAbstractMsInfo->bsSectorCandidate == NULL)
    {
        newCandidate =
            (CellularAbstractBsSectorCandidate *)
                MEM_malloc(sizeof(CellularAbstractBsSectorCandidate));

        newCandidate->lastReceived = node->getNodeTime();

        memcpy(&(newCandidate->sysInfo),
                sysInfo,
                sizeof(CellularAbstractBsSystemInfo));

        newCandidate->nextCandidate = NULL;
        nwCellularAbstractMsInfo->bsSectorCandidate = newCandidate;

        if (DEBUG_GENERAL)
        {
            printf(
                "node %d NW: create the list and the firs record\n",
                node->nodeId);
            fflush(stdout);
        }
    }
    else
    {
        //look for this bs and id to see if we do have recorder
        currrentCandidate = nwCellularAbstractMsInfo->bsSectorCandidate;

        while (currrentCandidate != NULL)
        {
            if (currrentCandidate->sysInfo.bsNodeId == sysInfo->bsNodeId)
            {
                found = TRUE;
                if (DEBUG_GENERAL)
                {
                    printf("node %d NW: find an existing record"
                        "for the BS control info %d\n",
                        node->nodeId,
                        sysInfo->bsNodeId);
                    fflush(stdout);
                }
                break;
            }
            currrentCandidate = currrentCandidate->nextCandidate;
        }
        if (found == TRUE)
        {
            //update the current record
            currrentCandidate->lastReceived = node->getNodeTime();

            memcpy(
                &(currrentCandidate->sysInfo),
                sysInfo,
                sizeof(CellularAbstractBsSystemInfo));

            if (DEBUG_GENERAL)
            {
                printf("node %d NW: update the BS control info %d\n",
                    node->nodeId, sysInfo->bsNodeId);
                fflush(stdout);
            }
        }
        else
        {
            newCandidate =
                (CellularAbstractBsSectorCandidate *)
                    MEM_malloc(sizeof(CellularAbstractBsSectorCandidate));

            newCandidate->lastReceived = node->getNodeTime();

            memcpy(
                &(newCandidate->sysInfo),
                sysInfo,
                sizeof(CellularAbstractBsSystemInfo));

            newCandidate->nextCandidate = NULL;
            currrentCandidate = nwCellularAbstractMsInfo->bsSectorCandidate;

            while (currrentCandidate->nextCandidate != NULL)
            {
                currrentCandidate = currrentCandidate->nextCandidate;
            }
            currrentCandidate->nextCandidate = newCandidate;
            if (DEBUG_GENERAL)
            {
                printf("node %d NW: add a new BS control info %d\n",
                    node->nodeId,
                    sysInfo->bsNodeId);
                fflush(stdout);
            }
        }
    }
}

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsStartHandover
// LAYER      :: Layer3
// PURPOSE    :: MS start handover
// PARAMETERS ::
// + node                : Node *                  : Pointer to node.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractMsStartHandover(Node *node)
{
    int i;
    int index;
    CellularAbstractHandoverRequiredPkt *handoverRequiredPkt;
    Message *handoverRequiredMsg;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    //build the handover required msg--- ms initiate
    handoverRequiredPkt =
        (CellularAbstractHandoverRequiredPkt *)
            MEM_malloc(sizeof(CellularAbstractHandoverRequiredPkt));

    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS; i ++)
    {
        handoverRequiredPkt->handoverAppInfo[i].appId =
                                    CELLULAR_ABSTRACT_INVALID_APP_ID;
    }

    index = 0;

    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS; i ++)
    {
        if (nwCellularAbstractMsInfo->msAppInfo[i].inUse == TRUE)
        {
            handoverRequiredPkt->handoverAppInfo[index].transactionId =
                nwCellularAbstractMsInfo->msAppInfo[i].transactionId;

            handoverRequiredPkt->handoverAppInfo[index].appId =
                nwCellularAbstractMsInfo->msAppInfo[i].appId;

            handoverRequiredPkt->handoverAppInfo[index].appType =
                nwCellularAbstractMsInfo->msAppInfo[i].applicationType;

            handoverRequiredPkt->handoverAppInfo[index].appSrcNodeId =
                nwCellularAbstractMsInfo->msAppInfo[i].srcMsNodeId;

            handoverRequiredPkt->handoverAppInfo[index].callSrcDestType =
                nwCellularAbstractMsInfo->msAppInfo[i].callSrcDestType;

            handoverRequiredPkt->handoverAppInfo[index].appDestNodeId =
                nwCellularAbstractMsInfo->msAppInfo[i].destMsNodeId;

            handoverRequiredPkt->
                handoverAppInfo[index].numChannelRequired =
                    nwCellularAbstractMsInfo->
                                        msAppInfo[i].numChannelRequired;

            handoverRequiredPkt->
                handoverAppInfo[index].bandwidthRequired =
                    nwCellularAbstractMsInfo->
                                        msAppInfo[i].bandwidthRequired;
            index ++;
        }

    }

    handoverRequiredPkt->numApplication = index;
    handoverRequiredPkt->msNodeId = node->nodeId;

    handoverRequiredPkt->currentBsNodeId =
        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId;

    handoverRequiredPkt->currentSectorId =
        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedSectorId;

    handoverRequiredPkt->targetBsNodeId =
        nwCellularAbstractMsInfo->handoverInfo->targetBSNodeId;

    handoverRequiredPkt->targetSectorId =
        nwCellularAbstractMsInfo->handoverInfo->targetSectorId;

    CellularAbstractLayer3BuildMessage(
        node,
        &handoverRequiredMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        handoverRequiredPkt,
        sizeof(CellularAbstractHandoverRequiredPkt));

    //send the msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        handoverRequiredMsg,
        CELLULAR_PD_RR,//protocl discritptor
        CELLULAR_ABSTRACT_HANDOVER_REQUIRED,//layer 3 message type
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,//interlayer info type

        nwCellularAbstractMsInfo->
            msAppInfo[index-1].assignedULChannelIndex[0],//temporary use

        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only assocatiated BS
        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId);

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d --handover: build and send "
            "HANDOVER REQUIRED MSG TO current BS %d"
            "sector %d, target Bs %d sector %d\n",
            node->getNodeTime(),
            node->nodeId,
            handoverRequiredPkt->currentBsNodeId,
            handoverRequiredPkt->currentSectorId,
            handoverRequiredPkt->targetBsNodeId,
            handoverRequiredPkt->targetSectorId);
        fflush(stdout);
    }

    MEM_free(handoverRequiredPkt);

    //update stats
    nwCellularAbstractMsInfo->stats.numHandoverRequiredSent ++;
}

//********************************************************************
// /**
/// FUNCTION   :: CellularAbstractMsIsHandoverReady
// LAYER      :: Layer3
// PURPOSE    :: Check handover is ready to start
// PARAMETERS ::
// + node             : Node *            : Pointer to node.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractMsIsHandoverReady(Node *node)
{
    BOOL isHandoverReady;
    int i;
    BOOL isAllApplicationActive;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    isHandoverReady=FALSE;
    isAllApplicationActive=TRUE;

    //look for the first used item
    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS &&
                    isAllApplicationActive == TRUE; i ++)
    {
        if (nwCellularAbstractMsInfo->msAppInfo[i].inUse == TRUE)
        {
            if (nwCellularAbstractMsInfo->msAppInfo[i].msCcState !=
                CELLULAR_ABSTRACT_MS_CC_STATE_ACTIVE)
            {
                isAllApplicationActive = FALSE;
            }
        }
    }

    if (isAllApplicationActive == TRUE &&
        nwCellularAbstractMsInfo->isLocationUpdateInProgress == FALSE)
    {
        nwCellularAbstractMsInfo->handoverState =
            CELLULAR_ABSTRACT_HANDOVER_STATE_PROCEEDING;

        if (DEBUG_HANDOVER)
        {
            printf("at %015" TYPES_64BITFMT "d node %d start handover\n",
                    node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }

        CellularAbstractMsStartHandover(node);
    }
}

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsSelectCellSector
// LAYER      :: Layer3
// PURPOSE    :: Perform Cell select or cell reselect
// PARAMETERS ::
// + node             : Node *                  : Pointer to node.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractMsSelectCellSector(Node *node)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    CellularAbstractAssociatedBsSectorInfo *bsSectorInfo;
    double maxStrength;
    int maxIndex;
    int i;
    BOOL cellReselectionNeeded;
    BOOL normalLocationUpdateNeeded;
    BOOL firstTimeCellSelection;
    Message *cellSelectMsg;
    CellularAbstractSelectCellInfo *cellSelectMsgInfo;
    CellularAbstractLocationUpdatingType locUpdateType =
                    CELLULAR_ABSTRACT_LOCATION_UPTATE_TYPE_INVALID;

    if (DEBUG_GENERAL)
    {
        printf("node %d NW: in cell sector selection\n",node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    if (DEBUG_GENERAL )
    {
        printf(
            "node %d NW:  %d %d %d %d %d %d "
            "measure report detail\n",node->nodeId,
            nwCellularAbstractMsInfo->reportInfo[0].monitoredBsId,
            nwCellularAbstractMsInfo->reportInfo[1].monitoredBsId,
            nwCellularAbstractMsInfo->reportInfo[2].monitoredBsId,
            nwCellularAbstractMsInfo->reportInfo[3].monitoredBsId,
            nwCellularAbstractMsInfo->reportInfo[4].monitoredBsId,
            nwCellularAbstractMsInfo->reportInfo[5].monitoredBsId);
        fflush(stdout);
        printf(
            "node %d NW:  %d %d %d %d %d %d "
            "measure report detail\n",node->nodeId,
            nwCellularAbstractMsInfo->reportInfo[0].monitoredSectorId,
            nwCellularAbstractMsInfo->reportInfo[1].monitoredSectorId,
            nwCellularAbstractMsInfo->reportInfo[2].monitoredSectorId,
            nwCellularAbstractMsInfo->reportInfo[3].monitoredSectorId,
            nwCellularAbstractMsInfo->reportInfo[4].monitoredSectorId,
            nwCellularAbstractMsInfo->reportInfo[5].monitoredSectorId);
        fflush(stdout);
        printf(
            "node %d NW:  %f %f %f %f %f %f "
            "measure report detail\n",node->nodeId,
            nwCellularAbstractMsInfo->reportInfo[0].receivedSignalStrength,
            nwCellularAbstractMsInfo->reportInfo[1].receivedSignalStrength,
            nwCellularAbstractMsInfo->reportInfo[2].receivedSignalStrength,
            nwCellularAbstractMsInfo->reportInfo[3].receivedSignalStrength,
            nwCellularAbstractMsInfo->reportInfo[4].receivedSignalStrength,
            nwCellularAbstractMsInfo->reportInfo[5].receivedSignalStrength);
        fflush(stdout);

    }

    maxStrength =
        nwCellularAbstractMsInfo->reportInfo[0].receivedSignalStrength;
    maxIndex = 0;

    //find the max strength,here is the minmum distance
    for (i = 1; i < CELLULAR_ABSTRACT_MAX_BS_SECTOR_CANDIDATE; i ++)
    {
        if ((nwCellularAbstractMsInfo->
            reportInfo[i].receivedSignalStrength < maxStrength) &&
            (nwCellularAbstractMsInfo->reportInfo[i].monitoredBsId !=
            CELLULAR_ABSTRACT_INVALID_BS_ID))
        {
            maxIndex = i;
            maxStrength = nwCellularAbstractMsInfo->
                                reportInfo[i].receivedSignalStrength;
        }
    }

    normalLocationUpdateNeeded = FALSE;
    cellReselectionNeeded = FALSE;
    firstTimeCellSelection = FALSE;
    bsSectorInfo = nwCellularAbstractMsInfo->associatedBsSectorInfo;

    //the first time: power on or return to service area
    if (nwCellularAbstractMsInfo->isBsSelected == FALSE)
    {
        normalLocationUpdateNeeded = TRUE;
        nwCellularAbstractMsInfo->isBsSelected = TRUE;
        firstTimeCellSelection = TRUE;
        locUpdateType = CELLULAR_ABSTRACT_IMSI_ATTACH;
        nwCellularAbstractMsInfo->stats.numCellSelectionPerformed ++;
    }
    else //not the first time
    {
        //when cell or BS changed, to reduce the location update,
        //it could be only BS change count as location update needed
        if ((bsSectorInfo->associatedBSNodeId !=
            nwCellularAbstractMsInfo->reportInfo[maxIndex].monitoredBsId)
            || (bsSectorInfo->associatedSectorId !=
            nwCellularAbstractMsInfo->
                                    reportInfo[maxIndex].monitoredSectorId))

        {
            //if any application is on going app or loc updating
            if (nwCellularAbstractMsInfo->numActiveApplicaions > 0 ||
                nwCellularAbstractMsInfo->isLocationUpdateInProgress ==
                TRUE)
            {
                //handlover needed
                if (DEBUG_HANDOVER)
                {
                    printf("at %015" TYPES_64BITFMT "d node %d :"
                           "handover needed \n",
                            node->getNodeTime(), node->nodeId);
                    fflush(stdout);
                }
                if (nwCellularAbstractMsInfo->handoverState !=
                    CELLULAR_ABSTRACT_HANDOVER_STATE_PROCEEDING)
                {
                    nwCellularAbstractMsInfo->handoverState =
                        CELLULAR_ABSTRACT_HANDOVER_STATE_PENDING;

                    //prepare handover
                    nwCellularAbstractMsInfo->handoverInfo->targetBSNodeId =
                        nwCellularAbstractMsInfo->
                        reportInfo[maxIndex].monitoredBsId;

                    nwCellularAbstractMsInfo->handoverInfo->targetSectorId =
                        nwCellularAbstractMsInfo->
                        reportInfo[maxIndex].monitoredSectorId;

                    nwCellularAbstractMsInfo->
                        handoverInfo->handoverReference =
                            node->getNodeTime();

                    CellularAbstractMsIsHandoverReady(node);
                }

                return;
            }
            else
            //cell reselecton needed if no active application no loc updting
            {
                BOOL cellReselectAllowed = TRUE;

                // the  following code is to implement reselection only when no
                // active transactions including channel request
                // currently it is disbaled, so reslection an be made even with
                // ongoign channel request
                /*for (i = 0; i <CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS; i++)
                {
                    if (nwCellularAbstractMsInfo->msAppInfo[i].inUse == TRUE)
                    {

                        CellularAbstractChannelRequestInfo *msChannelReqInfo;

                        msChannelReqInfo =
                            nwCellularAbstractMsInfo->
                            msAppInfo[i].channelRequestForApplication;
                        //for those are requesting channels, abort
                        if (msChannelReqInfo->isRequestingChannel == TRUE)
                        {
                            cellReselectAllowed = FALSE;
                            break;
                        }
                    }
                }*/
                if (cellReselectAllowed == TRUE)
                {
                    cellReselectionNeeded = TRUE;
                    locUpdateType=CELLULAR_ABSTRACT_NORMAL_LOCATION_UPDATING;
                    nwCellularAbstractMsInfo->
                        stats.numCellReSelectionPerformed ++;

                    if (DEBUG_CELLSELECTION)
                    {
                        printf(
                            "node %d :cell reselction needed  old"
                            "BS %d sector %d,new bs %d, sector %d\n",
                            node->nodeId,
                            bsSectorInfo->associatedBSNodeId,
                            bsSectorInfo->associatedSectorId,
                            nwCellularAbstractMsInfo->
                                reportInfo[maxIndex].monitoredBsId,
                            nwCellularAbstractMsInfo->
                                reportInfo[maxIndex].monitoredSectorId);
                        fflush(stdout);
                    }
                }
            }

        }
        else if ((bsSectorInfo->associatedBSNodeId ==
            nwCellularAbstractMsInfo->reportInfo[maxIndex].monitoredBsId)
            && (bsSectorInfo->associatedSectorId ==
                    nwCellularAbstractMsInfo->
                    reportInfo[maxIndex].monitoredSectorId)
            && nwCellularAbstractMsInfo->handoverState ==
                CELLULAR_ABSTRACT_HANDOVER_STATE_PENDING)

        //before the handover happen,the MS move back to currentBS
        {
            nwCellularAbstractMsInfo->handoverState =
                CELLULAR_ABSTRACT_HANDOVER_STATE_IDLE;

            //handlover on pending is canceled
            if (DEBUG_HANDOVER)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d :handover"
                    "on pending is canceled"
                    "---MS move back to original sector\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }
    }

    if (firstTimeCellSelection == TRUE || cellReselectionNeeded == TRUE)
    {

        bsSectorInfo->associatedBSNodeId =
            nwCellularAbstractMsInfo->reportInfo[maxIndex].monitoredBsId;

        bsSectorInfo->associatedSectorId =
            nwCellularAbstractMsInfo->reportInfo[maxIndex].monitoredSectorId;

        // update the other information,such as TXinterger,
        //which is available in BsSectorCandidate list
        CellularAbstractBsSectorCandidate *currentCandidate;
        currentCandidate = nwCellularAbstractMsInfo->bsSectorCandidate;
        while (currentCandidate != NULL)
        {
            if (DEBUG_GENERAL)
            {
                printf(
                    "Node%d associatedBSNodeId = %d, "
                    "sysinfo bsNodeId = %d\n",
                    node->nodeId, bsSectorInfo->associatedBSNodeId,
                    currentCandidate->sysInfo.bsNodeId);
                fflush(stdout);
            }
            if (currentCandidate->sysInfo.bsNodeId ==
                bsSectorInfo->associatedBSNodeId)
            {
                break;
            }
            else
            {
                currentCandidate=currentCandidate->nextCandidate;
            }
        }

        if (cellReselectionNeeded == TRUE
            && bsSectorInfo->lac != currentCandidate->sysInfo.lac)
        {
            normalLocationUpdateNeeded=TRUE;
        }

        bsSectorInfo->lac = currentCandidate->sysInfo.lac;

        bsSectorInfo->associatedBSNodeAddress =
            currentCandidate->sysInfo.bsNodeAddress;

        bsSectorInfo->cellIdentity =
            currentCandidate->sysInfo.cellId;

        bsSectorInfo->controlDLChannelIndex =
            currentCandidate->sysInfo.controlDLChannelIndex;

        bsSectorInfo->controlULChannelIndex =
            currentCandidate->sysInfo.controlULChannelIndex;

        if (currentCandidate->sysInfo.congestionControlPolicy ==
            CELLULAR_ABSTRACT_CONGESTION_CONTROL_ROUND_ROBIN)
        {
            // param  init goes to here
            // not implemented yet
            bsSectorInfo->congestionControlPolicy =
                CELLULAR_ABSTRACT_CONGESTION_CONTROL_ROUND_ROBIN;

            bsSectorInfo->oneControlDuration =
                currentCandidate->sysInfo.oneControlDuration;

            bsSectorInfo->numAccessClass =
                (short)currentCandidate->sysInfo.numAccessClass;

            nwCellularAbstractMsInfo->msAccessClass =
            (int)(RANDOM_erand(nwCellularData->randSeed) *
            currentCandidate->sysInfo.numAccessClass);

            bsSectorInfo->refrainProb =
                currentCandidate->sysInfo.refrainProb;
        }

        nwCellularAbstractMsInfo->txInteger =
            (short)currentCandidate->sysInfo.txInteger;
        nwCellularAbstractMsInfo->maxReTrans =
            (short)currentCandidate->sysInfo.maxReTrans;

        //reset the location update attempt number
        nwCellularAbstractMsInfo->numLocationUpdateAttempt = 0;

        //if there is no ogoing location update and no ongoing application
        if (nwCellularAbstractMsInfo->isLocationUpdateInProgress == FALSE
            && nwCellularAbstractMsInfo->numActiveApplicaions== 0
            && normalLocationUpdateNeeded == TRUE)
        {
            if (DEBUG_MM)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d NW-MM:"
                    "updae location after cell selection \n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }

            CellularAbstractMsPrepareLocationUpdate(
                node,
                CELLULAR_EST_CAUSE_LOCATION_UPDATING,
                locUpdateType);

            //update stats
            nwCellularAbstractMsInfo->stats.numLocationUpdateAttempt ++;
        }

        //inform MAC the selction so they can monitoring
        //the PAGCH besides the BCCH
        cellSelectMsg =
            MESSAGE_Alloc(
                node,
                MAC_LAYER,
                MAC_PROTOCOL_CELLULAR,
                MSG_MAC_CELLULAR_FromNetworkCellSelected);

        MESSAGE_InfoAlloc (
            node,
            cellSelectMsg,
            sizeof(CellularAbstractSelectCellInfo));

        cellSelectMsgInfo =
            (CellularAbstractSelectCellInfo *)
            MESSAGE_ReturnInfo(cellSelectMsg);

        cellSelectMsgInfo->bsNodeId = bsSectorInfo->associatedBSNodeId;
        cellSelectMsgInfo->sectorId = bsSectorInfo->associatedSectorId;

        cellSelectMsgInfo->controlDLChannelIndex =
            bsSectorInfo->controlDLChannelIndex;

        cellSelectMsgInfo->controlULChannelIndex =
            bsSectorInfo->controlULChannelIndex;

        MESSAGE_SetInstanceId(cellSelectMsg,
                             (short) nwCellularData->interfaceIndex);

        MESSAGE_Send(node, cellSelectMsg, 0);

        if (DEBUG_NET2MAC)
        {
            printf(
                "node %d send mac a cell select msg"
                "to notify the DL UL info\n",
                node->nodeId);
            fflush(stdout);
        }
    }

    if (DEBUG_GENERAL)
    {
        printf(
            "node %d NW: cell sector selection is BS %d and sector %d\n",
            node->nodeId,
            bsSectorInfo->associatedBSNodeId,
            bsSectorInfo->associatedSectorId);
        fflush(stdout);
    }

}//CellularAbstractMsSelectCellSector

///*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleMeasurementReportFromMac
// LAYER      :: Layer3
// PURPOSE    :: Handle measuremnt report from MAC
// PARAMETERS ::
// + node                : Node *                   : Pointer to node.
// + msg                 : Messae *                 : Message to be handled
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractMsHandleMeasurementReportFromMac(Node *node,
                                                      Message *msg)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    CellularAbstractMeasurementReportMsgInfo *info;

    if (DEBUG_GENERAL)
    {
        printf("node %d NW: Handle MeasurementReportFromMac msg\n",
            node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    //update stats
    nwCellularAbstractMsInfo->stats.numMeasurementReportRecvdFromMac ++;

    info = (CellularAbstractMeasurementReportMsgInfo *)
                                            (MESSAGE_ReturnInfo(msg));

    memcpy(
        nwCellularAbstractMsInfo->reportInfo,
        info,
        CELLULAR_ABSTRACT_MAX_BS_SECTOR_CANDIDATE
        * sizeof(CellularAbstractMeasurementReportMsgInfo));

    if (DEBUG_GENERAL)
    {
        printf(
            "node %d NW: get %d %d %d %d %d %d "
            "measure report from Mac\n",node->nodeId,
            nwCellularAbstractMsInfo->reportInfo[0].monitoredBsId,
            nwCellularAbstractMsInfo->reportInfo[1].monitoredBsId,
            nwCellularAbstractMsInfo->reportInfo[2].monitoredBsId,
            nwCellularAbstractMsInfo->reportInfo[3].monitoredBsId,
            nwCellularAbstractMsInfo->reportInfo[4].monitoredBsId,
            nwCellularAbstractMsInfo->reportInfo[5].monitoredBsId);
        fflush(stdout);
    }

    //process the measurement report and see if cell select or reselct needed
    CellularAbstractMsSelectCellSector(node);
}//CellularAbstractMsHandleMeasurementReportFromMac

//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsBuildLocationUpdateRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: BUild location update msg
// PARAMETERS ::
// + node                           : Node *    : Pointer to node.
// + msg                            : Message **: Point to the loUpdate Msg
// + locationUpdateType:CellularAbstractLocationUpdatingType:Type of loUpdate
// + lac                            : int       : location area code
// + assignmentId                   : int       : resource assignment id
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractMsBuildLocationUpdateRequestMsg(
        Node *node,
        Message **msg,
        CellularAbstractLocationUpdatingType   locationUpdatingType,
        int   lac,
        int assignmentId)
{
    CellularAbstractLocationUpdateRequestPkt *locUpdateReqPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;
    if (DEBUG_RR)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW RR:"
               "build a loc update msg\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    *msg = MESSAGE_Alloc( node,
                          MAC_LAYER,
                          MAC_PROTOCOL_CELLULAR,
                          MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        *msg,
        sizeof(CellularAbstractLocationUpdateRequestPkt),
        TRACE_CELLULAR);

    locUpdateReqPkt =
        (CellularAbstractLocationUpdateRequestPkt *)
        MESSAGE_ReturnPacket ((*msg));

    locUpdateReqPkt->locationUpdatingType = locationUpdatingType;
    locUpdateReqPkt->lac = lac;
    locUpdateReqPkt->msNodeId = nwCellularAbstractMsInfo->msNodeId;
    locUpdateReqPkt->msNodeAddr = nwCellularAbstractMsInfo->msNodeAddress;

    locUpdateReqPkt->bsNodeId =
       nwCellularAbstractMsInfo->associatedBsSectorInfo->associatedBSNodeId;

    locUpdateReqPkt->bsNodeAddr =
        nwCellularAbstractMsInfo->
        associatedBsSectorInfo->associatedBSNodeAddress;

    locUpdateReqPkt->assignmentId = assignmentId;

    if (DEBUG_RR)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW-RR:"
               "finish building the location update msg with"
               "update type %d with assignId %d\n",
               node->getNodeTime(),
               node->nodeId,
               locUpdateReqPkt->locationUpdatingType,
               locUpdateReqPkt->assignmentId);
        fflush(stdout);
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsSendCMServiceRequest
// LAYER      :: Layer3
// PURPOSE    :: Send CM service request msg
// PARAMETERS ::
// + node                : Node * : Pointer to node.
// + transactionId       : int    : transaction id
// + srcNodeId           : NodeAddress : source node address
// + cmServiceType       : CellularAbstractCMServiceType : Type of CM service
// + channelIndex        : int    : Channel index
// + assignmentId        : int    : assignment Id associate w/ the CM service
// RETURN     :: void : NULL
// **/
//***************************************************************************
static
void CellularAbstractMsSendCMServiceRequest(
         Node *node,
         int transactionId,
         NodeAddress srcNodeId,
         CellularAbstractCMServiceType cmServiceType,
         int channelIndex,
         int assignmentId)
{
    CellularAbstractCMServiceRequestPkt *cmServiceReqPkt;
    int itemIndex;
    Message *cmServiceReqMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo= nwCellularAbstractData->msLayer3Info;

    if (DEBUG_MM || DEBUG_PROGRESS)
    {
        char clockStr[MAX_STRING_LENGTH];
        ctoa(node->getNodeTime(), clockStr);
        printf("at %015" TYPES_64BITFMT "d node %d NW MM: build a "
               "Cm service request message\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    cmServiceReqMsg = MESSAGE_Alloc(
                          node,
                          MAC_LAYER,
                          MAC_PROTOCOL_CELLULAR,
                          MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc (
        node,
        cmServiceReqMsg,
        sizeof(CellularAbstractCMServiceRequestPkt),
        TRACE_CELLULAR);

    cmServiceReqPkt =
        (CellularAbstractCMServiceRequestPkt *)
        MESSAGE_ReturnPacket(cmServiceReqMsg);

    cmServiceReqPkt->msNodeId = srcNodeId;

    cmServiceReqPkt->transactionId = transactionId;
    cmServiceReqPkt->cmServiceType = cmServiceType;

    cmServiceReqPkt->bsNodeId =
        nwCellularAbstractMsInfo->
        associatedBsSectorInfo->associatedBSNodeId;

    cmServiceReqPkt->assignmentId = assignmentId;

    //update stats
    nwCellularAbstractMsInfo->stats.numCmServiceRequestSent++;

    //send the cm service req to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        cmServiceReqMsg,
        CELLULAR_PD_MM, //protocl discritptor
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_CM_SERVICE_REQUEST,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        channelIndex,
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,

        nwCellularAbstractMsInfo->
        associatedBsSectorInfo->associatedBSNodeId);

    //Timer 3230
    CellularAbstractGenericTimerInfo timerInfo;
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T3230Timer;
    timerInfo.transactionId = transactionId;
    timerInfo.srcNodeId = srcNodeId;

    //find the itemindex in appifo

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            srcNodeId,
            &itemIndex) == TRUE,
        "cannot found the appInfo need to send CM requuest");


    nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT3230 =
        CellularAbstractLayer3StartTimer(
            node,
            DefaultCellularAbstractCMServiceRequestTimer_T3230Time,
            &timerInfo,
            sizeof(CellularAbstractGenericTimerInfo));

    //timer 303
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T303Timer;
    timerInfo.transactionId = transactionId;
    timerInfo.srcNodeId = srcNodeId;
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303 =
        CellularAbstractLayer3StartTimer(
        node,
        DefaultCellularAbstractCallControl_T303Time,
        &timerInfo,
        sizeof(CellularAbstractGenericTimerInfo));

    //update the CC state
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_MM_CONNECTION_PENDING;
}

//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsSendCallSetupMsg
// LAYER      :: Layer3
// PURPOSE    :: Send Call setup msg
// PARAMETERS ::
// + node                : Node * : Pointer to node.
// + transactionId       : int    : Transaction id
// + appId               : int    : Application id
// + appType             : CellularAbstractApplicationType : App Type
// + appSrcNodeId        : NodeAddress  : Source node address
// + appDestNodeId       : NodeAddress  : Dest node address
// + callSrcDestType     : CellularAbstractCallSrcDestTyp : Src&dest Type
// + numChannelRequired  : int    : Number of channel required
// + bandwidthRequired   : double : bandwdith requirement
// + channelIndex        : int    : Channel index
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractMsSendCallSetupMsg(
        Node *node,
        int transactionId,
        int appId,
        CellularAbstractApplicationType appType,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        int numChannelRequired,
        double bandwidthRequired,
        int channelIndex)
{
    int itemIndex;
    CellularAbstractCallSetupPkt *callSetupPkt;
    Message *callSetupMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            appSrcNodeId,
            &itemIndex) == TRUE,
        "cannot found the appInfo need to send call setup msg");

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW CC: build a"
               "CAll SETUP message\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    callSetupMsg = MESSAGE_Alloc(
                        node,
                        MAC_LAYER,
                        MAC_PROTOCOL_CELLULAR,
                        MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        callSetupMsg,
                        sizeof(CellularAbstractCallSetupPkt),
                        TRACE_CELLULAR);

    callSetupPkt =
        (CellularAbstractCallSetupPkt *)
        MESSAGE_ReturnPacket(callSetupMsg);

    callSetupPkt->appId = appId;
    callSetupPkt->transactionId = transactionId;
    callSetupPkt->appType = appType;
    callSetupPkt->appSrcNodeId = appSrcNodeId;

    callSetupPkt->srcBsNodeId =
       nwCellularAbstractMsInfo->associatedBsSectorInfo->associatedBSNodeId;

    callSetupPkt->appDestNodeId = appDestNodeId;
    callSetupPkt->callSrcDestType = callSrcDestType;
    callSetupPkt->numChannelRequired = numChannelRequired;
    callSetupPkt->bandwidthRequired = bandwidthRequired;

    //update stats
    nwCellularAbstractMsInfo->stats.numMOCallSetupSent ++;

    //send the setup msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        callSetupMsg,
        CELLULAR_PD_CC,//protocl discritptor
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_SETUP,//layer 3 message type
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,//interlayer info type
        channelIndex,
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only assocatiated BS

        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId);

    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_CALL_INITIATED;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW CC: sending"
               "a CAll SETUP message\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

}

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsSendActivatePDPContextRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Send activate PDP contect request msg
//               the function is used to build the channel request msg,
//               and schedule a timer to send the first req
// PARAMETERS ::
// + node                : Node *  : Pointer to node.
// + transactionId       : int     : Transaction id
// + appId               : int     : Application id
// + appType             : CellularAbstractApplicationType : App Type
// + appSrcNodeId        : NodeAddress : Source node address
// + appDestNodeId       : NodeAddress : Dest node address
// + callSrcDestType     : CellularAbstractCallSrcDestTyp : call Src and dest
// + numChannelRequired  : int     : Number of channel required
// + bandwidthRequired   : double  : bandwdith requirement
// + appDuration         : clocktype : application's duration
// + channelIndex        : int     : Channel index
// RETURN     :: void : NULL
// **/
//***************************************************************************
static
void CellularAbstractMsSendActivatePDPContextRequestMsg(
        Node *node,
        int transactionId,
        int appId,
        CellularAbstractApplicationType appType,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        int numChannelRequired,
        double bandwidthRequired,
        clocktype appDuration,
        int channelIndex)
{
    int itemIndex = 0;
    CellularAbstractActivatePDPContextRequestPkt *activatePDPContextReqPkt;
    Message *activatePDPContextReqMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        ERROR_Assert(
            CellularAbstractMsLookForAppInfoItem(
                node,
                transactionId,
                appSrcNodeId,
                &itemIndex) == TRUE,
            "cannot found the appInfo need to send activate PDP request");
    }
    else if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        ERROR_Assert(
            CellularAbstractMsLookForAppInfoItem(
                node,
                transactionId,
                appDestNodeId,
                &itemIndex) == TRUE,
            "cannot found the appInfo need to send activate PDP request");
    }
    if (DEBUG_SM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW SM: build"
               "a activate PDP context request message\n",
               node->getNodeTime(),
               node->nodeId);
        fflush(stdout);
    }

    activatePDPContextReqMsg = MESSAGE_Alloc(
                                    node,
                                    MAC_LAYER,
                                    MAC_PROTOCOL_CELLULAR,
                                    MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        activatePDPContextReqMsg,
        sizeof(CellularAbstractActivatePDPContextRequestPkt),
        TRACE_CELLULAR);

    activatePDPContextReqPkt =
        (CellularAbstractActivatePDPContextRequestPkt *)
        MESSAGE_ReturnPacket(activatePDPContextReqMsg);

    activatePDPContextReqPkt->appId = appId;
    activatePDPContextReqPkt->transactionId = transactionId;
    activatePDPContextReqPkt->appType = appType;
    activatePDPContextReqPkt->appSrcNodeId = appSrcNodeId;

    if (callSrcDestType==CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        activatePDPContextReqPkt->srcBsNodeId =
            nwCellularAbstractMsInfo->
                associatedBsSectorInfo->associatedBSNodeId;
    }
    else if (callSrcDestType==CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        activatePDPContextReqPkt->destBsNodeId =
            nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId;
    }

    activatePDPContextReqPkt->appDestNodeId = appDestNodeId;
    activatePDPContextReqPkt->callSrcDestType = callSrcDestType;
    activatePDPContextReqPkt->numChannelRequired = numChannelRequired;
    activatePDPContextReqPkt->bandwidthRequired = bandwidthRequired;
    activatePDPContextReqPkt->appDuration = appDuration;

    //TODO update stats

    //send the setup msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        activatePDPContextReqMsg,
        CELLULAR_PD_SM,//protocl discritptor
        CELLULAR_ABSTRACT_SM_ACTIVATE_PDP_CONTEXT_REQUEST,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,//interlayer info type
        channelIndex,
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only assocatiated BS

        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId);

    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_CALL_INITIATED;

    if (DEBUG_SM || DEBUG_PROGRESS)
    {
        char clockStr[MAX_STRING_LENGTH];
        ctoa(node->getNodeTime(), clockStr);
        printf("at %015" TYPES_64BITFMT "d node %d NW SM: sending"
               "a activate pdp contect request message\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsSendDeactivatePDPContextRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Send deactivate PDP contect request msg
//               the function is used to build the channel request msg,
//               and schedule a timer to send the first req
// PARAMETERS ::
// + node                : Node * : Pointer to node.
// + appId               : int  : Application id
// + appType             : CellularAbstractApplicationType: Application Type
// + appSrcNodeId        : NodeAddress : Source node address
// + appDestNodeId       : NodeAddress : Dest node address
// + callSrcDestType : CellularAbstractCallSrcDestTyp : Type of Src&dest
// + callDiscCause :CellularAbstractCallDisconectCauseType : deca. cause
// + dealy               : clocktype : delay
// RETURN     :: void : NULL
// **/
//***************************************************************************
static
void CellularAbstractMsSendDeactivatePDPContextRequestMsg(
          Node *node,
          int appId,
          CellularAbstractApplicationType appType,
          NodeAddress appSrcNodeId,
          NodeAddress appDestNodeId,
          CellularAbstractCallSrcDestType callSrcDestType,
          CellularAbstractCallDisconectCauseType callDiscCause,
          clocktype delay = 0)
{
    int itemIndex;
    int transactionId;
    CellularAbstractDeactivatePDPContextRequestPkt
        *deactivatePDPContextReqPkt;

    Message *deactivatePDPContextReqMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    ERROR_Assert(
        CellularAbstractMsLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            &itemIndex,
            &transactionId) == TRUE,
        "cannot find the appInfo needs to send deactivate PDP req msg");

    if (DEBUG_SM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW SM: build a"
               "deactivate PDP context request message\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    deactivatePDPContextReqMsg = MESSAGE_Alloc(
                                        node,
                                        MAC_LAYER,
                                        MAC_PROTOCOL_CELLULAR,
                                        MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        deactivatePDPContextReqMsg,
        sizeof(CellularAbstractDeactivatePDPContextRequestPkt),
        TRACE_CELLULAR);

    deactivatePDPContextReqPkt =
        (CellularAbstractDeactivatePDPContextRequestPkt *)
            MESSAGE_ReturnPacket(deactivatePDPContextReqMsg);

    deactivatePDPContextReqPkt->appId = appId;
    deactivatePDPContextReqPkt->transactionId = transactionId;
    deactivatePDPContextReqPkt->appType = appType;
    deactivatePDPContextReqPkt->appSrcNodeId = appSrcNodeId;

    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        deactivatePDPContextReqPkt->srcBsNodeId =
            nwCellularAbstractMsInfo->
                associatedBsSectorInfo->associatedBSNodeId;
    }
    else if (callSrcDestType==CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        deactivatePDPContextReqPkt->destBsNodeId =
            nwCellularAbstractMsInfo->
                associatedBsSectorInfo->associatedBSNodeId;
    }

    deactivatePDPContextReqPkt->appDestNodeId = appDestNodeId;
    deactivatePDPContextReqPkt->callSrcDestType = callSrcDestType;
    deactivatePDPContextReqPkt->callDiscCause = callDiscCause;
    //update stats

    //send the  msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        deactivatePDPContextReqMsg,
        CELLULAR_PD_SM,//protocl discritptor
        CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_REQUEST,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,//interlayer info type

        nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].assignedULChannelIndex[0],

        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only assocatiated BS

        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId,
        delay);

    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_RELEASE_REQUEST;

    if (DEBUG_SM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW CC: sending a"
               "deactivate pdp context request message\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}

//*************************************************************************
// FUNCTION   :: CellularAbstractMsSendPageResponseMsg
// LAYER      :: Layer3
// PURPOSE    :: Send page response msg
// PARAMETERS ::
// + node                : Node * : Pointer to node.
// + transactionId       : int    : Transaction id
// + appId               : int    : Application id
// + appType             : CellularAbstractApplicationType : App Type
// + srcMsNodeId         : NodeAddress : Source node address
// + destMsNodeId        : NodeAddress : Dest node address
// + callSrcDestType     : CellularAbstractCallSrcDestTyp: src&dest Type
// + numChannelRequired  : int    : Number of channel required
// + bandwidthRequired   : double : bandwdith requirement
// + appDuration         : clocktype : application's duration
// + pageRequestId       : int    : Page Request id
// + channelIndex        : int    : Channel index
// + assignmentId        : int    : assignment Id
// RETURN     :: void : NULL
//**************************************************************************
static
void CellularAbstractMsSendPageResponseMsg(
        Node *node,
        int transactionId,
        int appId,
        CellularAbstractApplicationType appType,
        NodeAddress srcMsNodeId,
        NodeAddress destMsNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        double bandwidthRequired,
        int numChannelRequired,
        clocktype appDuration,
        int pageRequestId,
        int channelIndex,
        int assignmentId)
{
    CellularAbstractPageResponsePkt *pageResponsePkt;
    Message *pageResponseMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    pageResponseMsg = MESSAGE_Alloc(node,
                                    MAC_LAYER,
                                    MAC_PROTOCOL_CELLULAR,
                                    MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        pageResponseMsg,
                        sizeof(CellularAbstractPageResponsePkt),
                        TRACE_CELLULAR);

    pageResponsePkt =
        (CellularAbstractPageResponsePkt *)
            MESSAGE_ReturnPacket(pageResponseMsg);

    pageResponsePkt->appId = appId;
    pageResponsePkt->appType = appType;
    pageResponsePkt->appSrcNodeId = srcMsNodeId;
    pageResponsePkt->appDestNodeId = destMsNodeId;

    //only destination ms shoule be here
    pageResponsePkt->destBsNodeId =
        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId;

    pageResponsePkt->bandwidthRequired = bandwidthRequired;
    pageResponsePkt->numChannelRequired = numChannelRequired;
    pageResponsePkt->appDuration = appDuration;
    pageResponsePkt->callSrcDestType = callSrcDestType;
    pageResponsePkt->transactionId = transactionId;
    pageResponsePkt->pageRequestId = pageRequestId;
    pageResponsePkt->assignmentId = assignmentId;

    //send the setup msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        pageResponseMsg,
        CELLULAR_PD_RR,//protocl discritptor
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_PAGING_RESPONSE,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,//interlayer info type
        channelIndex,
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only assocatiated BS

        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId);

    if (DEBUG_RR)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW RR: sending"
               "a Page Response message for pageId %d with assignId %d\n",
               node->getNodeTime(),
               node->nodeId,
               pageResponsePkt->pageRequestId,
               pageResponsePkt->assignmentId);
        fflush(stdout);
    }
}

//**************************************************************************
// FUNCTION   :: CellularAbstractMsSendCallConfirmMsg
// LAYER      :: Layer3
// PURPOSE    :: Send call confirm msg
// PARAMETERS ::
// + node                : Node * : Pointer to node.
// + transactionId       : int    : Transaction Id of the application
// + appId               : int    : Application id
// + callSrcDestType     : CellularAbstractCallSrcDestTyp : src&dest Type
// + appSrcNodeId        : NodeAddress : Source node address
// + srcBsNodeId         : NodeAddress : Source node's BS address
// + appDestNodeId       : NodeAddress : Dest node address
// + destBsNodeId        : NodeAddress : Source node's BS address
// RETURN     :: void : NULL
//**************************************************************************
static
void CellularAbstractMsSendCallConfirmMsg(
          Node *node,
          int transactionId,
          int appId,
          CellularAbstractCallSrcDestType callSrcDestType,
          NodeAddress appSrcNodeId,
          NodeAddress srcBsNodeId,
          NodeAddress appDestNodeId,
          NodeAddress destBsNodeId)
{
    CellularAbstractCallConfirmPkt *callConfirmPkt;
    Message *callConfirmMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;
    int itemIndex;
    int channelIndex;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    callConfirmMsg = MESSAGE_Alloc( node,
                                    MAC_LAYER,
                                    MAC_PROTOCOL_CELLULAR,
                                    MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        callConfirmMsg,
                        sizeof(CellularAbstractCallConfirmPkt),
                        TRACE_CELLULAR);

    callConfirmPkt =
        (CellularAbstractCallConfirmPkt *)
        MESSAGE_ReturnPacket(callConfirmMsg);

    callConfirmPkt->transactionId = transactionId;
    callConfirmPkt->appId = appId;
    callConfirmPkt->appSrcNodeId = appSrcNodeId;
    callConfirmPkt->appDestNodeId = appDestNodeId;
    callConfirmPkt->callSrcDestType = callSrcDestType;
    callConfirmPkt->srcBsNodeId = srcBsNodeId;
    callConfirmPkt->destBsNodeId = destBsNodeId;

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == TRUE,
        "cannot found the appInfo need to send call confirm msg");

    channelIndex =
        nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].assignedULChannelIndex[0];

    //send the setup msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        callConfirmMsg,
        CELLULAR_PD_CC,//protocl discritptor
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CALL_CONFIRMED,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,//interlayer info type
        channelIndex,
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only assocatiated BS

        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId,
    CELLULAR_ABSTRACT_CALL_CONFIRM_WAITING_TIME);

    //update stats
    nwCellularAbstractMsInfo->stats.numMTCallCallConfirmSent ++;
    //change the cc state
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_MOBILE_TERM_CALL_CONFIRMED;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW RR: sending a "
               "call confirm msg to bs %d for appId %d\n",
               node->getNodeTime() + CELLULAR_ABSTRACT_CALL_CONFIRM_WAITING_TIME,
                node->nodeId,
                nwCellularAbstractMsInfo->
                associatedBsSectorInfo->associatedBSNodeId,
                appId);
        fflush(stdout);
    }
}
//*************************************************************************
// FUNCTION   :: CellularAbstractMsSendCallAlertingMsg
// LAYER      :: Layer3
// PURPOSE    :: Send Call alerting msg
// PARAMETERS ::
// + node                : Node * : Pointer to node.
// + transactionId       : int    : Transaction Id of the application
// + appId               : int    : Application id
// + callSrcDestType     : CellularAbstractCallSrcDestTyp : Type of Src&dest
// + appSrcNodeId        : NodeAddress : Source node address
// + srcBsNodeId         : NodeAddress : Source node's BS address
// + appDestNodeId       : NodeAddress : Dest node address
// + destBsNodeId        : NodeAddress : Source node's BS address
// RETURN     :: void : NULL
//**************************************************************************
static
void CellularAbstractMsSendCallAlertingMsg(
        Node *node,
        int transactionId,
        int appId,
        CellularAbstractCallSrcDestType callSrcDestType,
        NodeAddress appSrcNodeId,
        NodeAddress srcBsNodeId,
        NodeAddress appDestNodeId,
        NodeAddress destBsNodeId)
{
    CellularAbstractCallAlertingPkt *callAlertingPkt;
    Message *callAlertingMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;
    int itemIndex;
    int channelIndex;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;
    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;
    //thrid hierarchy
    nwCellularAbstractMsInfo= nwCellularAbstractData->msLayer3Info;

    callAlertingMsg = MESSAGE_Alloc(node,
                                    MAC_LAYER,
                                    MAC_PROTOCOL_CELLULAR,
                                    MSG_MAC_CELLULAR_FromNetwork);
    MESSAGE_PacketAlloc(node,
                        callAlertingMsg,
                        sizeof(CellularAbstractCallAlertingPkt),
                        TRACE_CELLULAR);

    callAlertingPkt =
        (CellularAbstractCallAlertingPkt *)
            MESSAGE_ReturnPacket(callAlertingMsg);

    callAlertingPkt->transactionId = transactionId;
    callAlertingPkt->appId = appId;
    callAlertingPkt->appSrcNodeId = appSrcNodeId;
    callAlertingPkt->appDestNodeId = appDestNodeId;
    callAlertingPkt->callSrcDestType = callSrcDestType;
    callAlertingPkt->srcBsNodeId = srcBsNodeId;
    callAlertingPkt->destBsNodeId = destBsNodeId;

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == TRUE,
        "cannot found the appInfo need to send call AlertingPkt");

    channelIndex =
        nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].assignedULChannelIndex[0];

    //send the setup msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        callAlertingMsg,
        CELLULAR_PD_CC,//protocl discritptor
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_ALERTING,//layer 3 message type
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,//interlayer info type
        channelIndex,
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only assocatiated BS

        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId,
    CELLULAR_ABSTRACT_CALL_ALERTING_WAITING_TIME);

    //update stats
    nwCellularAbstractMsInfo->stats.numMTCallCallAlertingSent ++;

    //change the cc state
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_CALL_RECEIVED;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW RR: sending a call"
               "alerting msg to bs %d for appId %d src %d dest %d\n",
               node->getNodeTime() + CELLULAR_ABSTRACT_CALL_ALERTING_WAITING_TIME,
               node->nodeId,
               nwCellularAbstractMsInfo->
                 associatedBsSectorInfo->associatedBSNodeId,
               appId,
               callAlertingPkt->appSrcNodeId,
               callAlertingPkt->appDestNodeId);
        fflush(stdout);
    }
}

//************************************************************************
// FUNCTION   :: CellularAbstractMsSendAppCallArriveMsg
// LAYER      :: Layer3
// PURPOSE    :: Send App a call srrivae msg
// PARAMETERS ::
// + node                : Node *     : Pointer to node.
// + appId               : int        : Application id
// + transactionId       : int        : Transaction Id of the application
// RETURN     :: void : NULL
//*************************************************************************
static
void CellularAbstractMsSendAppCallArriveMsg(Node *node,
                                            int appId,
                                            int transactionId)
{

    CellularAbstractCallArriveMessageInfo *callArriveInfo;
    Message *callArriveMsgToApp;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;
    int itemIndex;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    callArriveMsgToApp = MESSAGE_Alloc(
                                node,
                                APP_LAYER,
                                APP_CELLULAR_ABSTRACT,
                                MSG_APP_CELLULAR_FromNetworkCallArrive);

    MESSAGE_InfoAlloc(
        node,
        callArriveMsgToApp,
        sizeof(CellularAbstractCallArriveMessageInfo));

    callArriveInfo =
        (CellularAbstractCallArriveMessageInfo *)
            MESSAGE_ReturnInfo(callArriveMsgToApp);

    callArriveInfo->appId = appId;
    callArriveInfo->transactionId = transactionId;

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == TRUE,
        "cannot found the appInfo need to send call arrive msg");

    callArriveInfo->appSrcNodeId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].srcMsNodeId;

    callArriveInfo->appDestNodeId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].destMsNodeId;

    callArriveInfo->appType =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].applicationType;

    //TODO:instance other aribales
    MESSAGE_Send(node, callArriveMsgToApp,
        CELLULAR_ABSTRACT_CALL_CONNECT_WAITING_TIME);

    if (DEBUG_NET2APP)
    {
        printf("at %015" TYPES_64BITFMT "d node %d:notify application"
               "layer a call is arrived\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//**************************************************************************
// FUNCTION   :: CellularAbstractMsSendAppCallArriveMsg
// LAYER      :: Layer3
// PURPOSE    :: Send App a call arrivae msg
// PARAMETERS ::
// + node                : Node *       : Pointer to node.
// + appId               : int          : Application id
// + transactionId       : int          : Transaction Id of the application
// RETURN     :: void : NULL
//**************************************************************************
static
void CellularAbstractMsSendAppCallAcceptMsg(Node *node,
                                            int appId,
                                            int transactionId)
{

    CellularAbstractCallAcceptMessageInfo *callAcceptInfo;
    Message *callAcceptMsgToApp;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;
    int itemIndex;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    callAcceptMsgToApp = MESSAGE_Alloc(
                            node,
                            APP_LAYER,
                            APP_CELLULAR_ABSTRACT,
                            MSG_APP_CELLULAR_FromNetworkCallAccepted);

    MESSAGE_InfoAlloc(
        node,
        callAcceptMsgToApp,
        sizeof(CellularAbstractCallAcceptMessageInfo));

    callAcceptInfo =
        (CellularAbstractCallAcceptMessageInfo *)
            MESSAGE_ReturnInfo(callAcceptMsgToApp);

    callAcceptInfo->appId = appId;
    callAcceptInfo->transactionId = transactionId;

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == TRUE,
        "cannot found the appInfo need to send the call accept msg");

    callAcceptInfo->appSrcNodeId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].srcMsNodeId;

    callAcceptInfo->appDestNodeId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].destMsNodeId;

    callAcceptInfo->appType =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].applicationType;

    //TODO:instance other aribales

    MESSAGE_Send(node, callAcceptMsgToApp, 0);

    if (DEBUG_NET2APP)
    {
        printf("at %015" TYPES_64BITFMT "d node %d:notify application"
               " layer a call is accept\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}

//*************************************************************************
// FUNCTION   :: CellularAbstractMsSendAppCallEndByRemote
// LAYER      :: Layer3
// PURPOSE    :: Send App a call end msg
// PARAMETERS ::
// + node                : Node *        : Pointer to node.
// + appId               : int           : Application id
// + appSrcNodeId        : NodeAddress   : Application's src address
// + appDestNodeId       : NodeAddress   : Application's dest address
// RETURN     :: void : NULL
//**************************************************************************
static
void CellularAbstractMsSendAppCallEndByRemote(Node *node,
                                              int appId,
                                              NodeAddress appSrcNodeId,
                                              NodeAddress appDestNodeId)
{
    CellularAbstractCallEndByRemoteMessageInfo *callEndByRemoteInfo;
    Message *callEndByRemoteMsgToApp;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo= nwCellularAbstractData->msLayer3Info;

    callEndByRemoteMsgToApp= MESSAGE_Alloc(
        node,
        APP_LAYER,
        APP_CELLULAR_ABSTRACT,
        MSG_APP_CELLULAR_FromNetworkCallEndByRemote);

    MESSAGE_InfoAlloc(
        node,
        callEndByRemoteMsgToApp,
        sizeof(CellularAbstractCallEndByRemoteMessageInfo));

    callEndByRemoteInfo =
        (CellularAbstractCallEndByRemoteMessageInfo *)
            MESSAGE_ReturnInfo(callEndByRemoteMsgToApp);

    callEndByRemoteInfo->appId = appId;
    callEndByRemoteInfo->appSrcNodeId= appSrcNodeId;
    callEndByRemoteInfo->appDestNodeId = appDestNodeId;

    //TODO:instance other aribales
    MESSAGE_Send(node, callEndByRemoteMsgToApp, 0);

    if (DEBUG_NET2APP)
    {
        printf("at %015" TYPES_64BITFMT "d node %d:notify application"
               "layer a call is ended by remote\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//*************************************************************************
// FUNCTION   :: CellularAbstractMsSendAppCallRejectedMsg
// LAYER      :: Layer3
// PURPOSE    :: Send App a call reject msg
// PARAMETERS ::
// + node                : Node *      : Pointer to node.
// + appId               : int         : Application id
// + appSrcNodeId        : NodeAddress : Application's src address
// + appDestNodeId       : NodeAddress : Application's dest address
// + rejectCause         : CellularAbstractCallRejectCauseType: reject Cause
// RETURN     :: void : NULL
//**************************************************************************
#if 0
static
void CellularAbstractMsSendAppCallRejectedMsg(
        Node *node,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallRejectCauseType rejectCause)
{
    Message *callRejectToAppMsg;
    CellularAbstractCallRejectMessageInfo *callRejectToAppMsgInfo;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;


    callRejectToAppMsg =
            MESSAGE_Alloc(
                node,
                APP_LAYER,
                APP_CELLULAR_ABSTRACT,
                MSG_APP_CELLULAR_FromNetworkCallRejected);

    MESSAGE_InfoAlloc(
        node,
        callRejectToAppMsg,
        sizeof(CellularAbstractCallRejectMessageInfo));

    callRejectToAppMsgInfo =
        (CellularAbstractCallRejectMessageInfo *)
            MESSAGE_ReturnInfo(callRejectToAppMsg);

    callRejectToAppMsgInfo->appId = appId;
    callRejectToAppMsgInfo->appSrcNodeId = appSrcNodeId;
    callRejectToAppMsgInfo->appDestNodeId = appDestNodeId;

    callRejectToAppMsgInfo->rejectCause = rejectCause;

    //TODO:instance other aribales

    MESSAGE_Send(node, callRejectToAppMsg, 0);
}
#endif
//*************************************************************************
// FUNCTION   :: CellularAbstractMsSendAppCallDroppedMsg
// LAYER      :: Layer3
// PURPOSE    :: Send App a call drop msg
// PARAMETERS ::
// + node                : Node *      : Pointer to node.
// + appId               : int         : Application id
// + appSrcNodeId        : NodeAddress : Application's src address
// + appDestNodeId       : NodeAddress : Application's dest address
// + dropCause           : CellularAbstractCallDropCauseType : drop Cause
// + delay               : clocktype        : delay
// RETURN     :: void : NULL
//**************************************************************************
static
void CellularAbstractMsSendAppCallDroppedMsg(
        Node *node,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallDropCauseType dropCause,
        clocktype delay = 0)
{
    Message *callDropToAppMsg;
    CellularAbstractCallDropMessageInfo *callDropToAppMsgInfo;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;


    callDropToAppMsg =
            MESSAGE_Alloc(
                node,
                APP_LAYER,
                APP_CELLULAR_ABSTRACT,
                MSG_APP_CELLULAR_FromNetworkCallDropped);

    MESSAGE_InfoAlloc(
        node,
        callDropToAppMsg,
        sizeof(CellularAbstractCallDropMessageInfo));

    callDropToAppMsgInfo =
        (CellularAbstractCallDropMessageInfo *)
            MESSAGE_ReturnInfo(callDropToAppMsg);

    callDropToAppMsgInfo->appId = appId;
    callDropToAppMsgInfo->appSrcNodeId = appSrcNodeId;
    callDropToAppMsgInfo->appDestNodeId = appDestNodeId;

    callDropToAppMsgInfo->dropCause = dropCause;

    //TODO:instance other aribales

    MESSAGE_Send(node, callDropToAppMsg, delay);

    //update stats
    nwCellularAbstractMsInfo->stats.numCallDroppedSent ++;
}
//**************************************************************************
// FUNCTION   :: CellularAbstractMsSendConnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Send Call connect msg
// PARAMETERS ::
// + node                : Node * : Pointer to node.
// + transactionId       : int    : Transaction Id of the application
// + appId               : int    : Application id
// + callSrcDestType : CellularAbstractCallSrcDestTyp : Type of Src and dest
// + appSrcNodeId        : NodeAddress : Source node address
// + srcBsNodeId         : NodeAddress : Source node's BS address
// + appDestNodeId       : NodeAddress : Dest node address
// + destBsNodeId        : NodeAddress : Source node's BS address
// RETURN     :: void : NULL
//**************************************************************************
static
void CellularAbstractMsSendConnectMsg(
          Node *node,
          int transactionId,
          int appId,
          CellularAbstractCallSrcDestType callSrcDestType,
          NodeAddress appSrcNodeId,
          NodeAddress srcBsNodeId,
          NodeAddress appDestNodeId,
          NodeAddress destBsNodeId)
{
    CellularAbstractCallConnectPkt *callConnectPkt;
    Message *callConnectMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;
    int itemIndex;
    int channelIndex;
    CellularAbstractGenericTimerInfo timerInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    callConnectMsg = MESSAGE_Alloc(node,
                                   MAC_LAYER,
                                   MAC_PROTOCOL_CELLULAR,
                                   MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        callConnectMsg,
                        sizeof(CellularAbstractCallConnectPkt),
                        TRACE_CELLULAR);

    callConnectPkt =
        (CellularAbstractCallConnectPkt *)
            MESSAGE_ReturnPacket(callConnectMsg);

    callConnectPkt->transactionId = transactionId;
    callConnectPkt->appId = appId;
    callConnectPkt->appSrcNodeId = appSrcNodeId;
    callConnectPkt->appDestNodeId = appDestNodeId;
    callConnectPkt->callSrcDestType = callSrcDestType;
    callConnectPkt->srcBsNodeId = srcBsNodeId;
    callConnectPkt->destBsNodeId = destBsNodeId;

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == TRUE,
        "cannot found the appInfo need to send out call connect msg");

    channelIndex =
        nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].assignedULChannelIndex[0];

    //send the setup msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        callConnectMsg,
        CELLULAR_PD_CC,//protocl discritptor
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        channelIndex,
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId);

    //update stats
    nwCellularAbstractMsInfo->stats.numMTCallConnectSent ++;

    //start T313
    timerInfo.srcNodeId = node->nodeId;
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T313Timer;
    timerInfo.transactionId = transactionId;
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT313=
        CellularAbstractLayer3StartTimer(
            node,
            DefaultCellularAbstractCallControl_T313Time,
            &timerInfo,
            sizeof(CellularAbstractGenericTimerInfo));

    //change the cc state
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_CONNECT_REQUEST;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW CC: sending"
               "a call coonect msg to bs %d for appId %d and start T313\n",
               node->getNodeTime(),
               node->nodeId,
               nwCellularAbstractMsInfo->
                associatedBsSectorInfo->associatedBSNodeId,
               appId);
        fflush(stdout);
    }
}

//***************************************************************************
// FUNCTION   :: CellularAbstractMsSendConnectAckMsg
// LAYER      :: Layer3
// PURPOSE    :: Send Call connect ack msg
// PARAMETERS ::
// + node                : Node *      : Pointer to node.
// + transactionId       : int         : Transaction Id of the application
// + appId               : int         : Application id
// + callSrcDestType     : CellularAbstractCallSrcDestTyp : Type Src & dest
// + appSrcNodeId        : NodeAddress : Source node address
// + srcBsNodeId         : NodeAddress : Source node's BS address
// + appDestNodeId       : NodeAddress : Dest node address
// + destBsNodeId        : NodeAddress : Source node's BS address
// RETURN     :: void : NULL
//****************************************************************************
static
void CellularAbstractMsSendConnectAckMsg(
        Node *node,
        int transactionId,
        int appId,
        CellularAbstractCallSrcDestType callSrcDestType,
        NodeAddress appSrcNodeId,
        NodeAddress srcBsNodeId,
        NodeAddress appDestNodeId,
        NodeAddress destBsNodeId)
{
    CellularAbstractCallConnectAckPkt *callConnectAckPkt;
    Message *callConnectAckMsg;
    int itemIndex;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    ERROR_Assert(
        callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
        "MS only can send CONNCET ACK for MO call");

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW CC: build a CAll"
               "Connect Ack message for MO call\n",
               node->getNodeTime(),
               node->nodeId);
        fflush(stdout);
    }

    callConnectAckMsg = MESSAGE_Alloc(node,
                                      MAC_LAYER,
                                      MAC_PROTOCOL_CELLULAR,
                                      MSG_MAC_CELLULAR_FromNetwork);
    MESSAGE_PacketAlloc(node,
                        callConnectAckMsg,
                        sizeof(CellularAbstractCallConnectAckPkt),
                        TRACE_CELLULAR);

    callConnectAckPkt =
        (CellularAbstractCallConnectAckPkt *)
            MESSAGE_ReturnPacket(callConnectAckMsg);

    callConnectAckPkt->appId = appId;
    callConnectAckPkt->transactionId = transactionId;
    callConnectAckPkt->appSrcNodeId = appSrcNodeId;
    callConnectAckPkt->srcBsNodeId = srcBsNodeId;
    callConnectAckPkt->appDestNodeId = appDestNodeId;
    callConnectAckPkt->destBsNodeId = destBsNodeId;
    callConnectAckPkt->callSrcDestType = callSrcDestType;

    //send to mac
    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            appSrcNodeId,
            &itemIndex) == TRUE,
        "cannot found the appInfo need to send call connect ack msg");

    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        callConnectAckMsg,
        CELLULAR_PD_CC,//protocl discritptor
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT_ACKNOWLEDGE,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,

        nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].assignedULChannelIndex[0],
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,

        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId);

    //update stats
    nwCellularAbstractMsInfo->stats.numMOCallConnectAckSent ++;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW CC:sending"
               "a MO CallConnectAck msg\n",
               node->getNodeTime(),
               node->nodeId);
        fflush(stdout);
    }
}
//**********************************************************************
// FUNCTION   :: CellularAbstractMsSendCallDisconnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Send Call disconnect  msg
// PARAMETERS ::
// + node                : Node *      : Pointer to node.
// + appId               : int         : Application id
// + appSrcNodeId        : NodeAddress : Source node address
// + appDestNodeId       : NodeAddress : Dest node address
// + callDiscCause      : CellularAbstractCallDisconectCauseType : dis cause
// + delay               : clocktype   : delay
// RETURN     :: void : NULL
//***********************************************************************
static
void CellularAbstractMsSendCallDisconnectMsg(
        Node *node,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallDisconectCauseType callDiscCause,
        clocktype delay = 0)
{
    int itemIndex;
    int transactionId;
    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractCallDisconnectPkt *callDisconnectPkt;
    Message *callDisconnectMsg;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    ERROR_Assert(
        CellularAbstractMsLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            &itemIndex,
            &transactionId) == TRUE,
        "cannot find the appInfo need to send call disconnect msg");

    callSrcDestType =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].callSrcDestType;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW CC: build a "
               "CAll DisConnect message for appId %d"
               "transactionId %d between src %d and %d call type %d\n",
               node->getNodeTime(),
               node->nodeId,
               appId,
               transactionId,
               appSrcNodeId,
               appDestNodeId,
               callSrcDestType);
        fflush(stdout);
    }

    callDisconnectMsg = MESSAGE_Alloc(node,
                                      MAC_LAYER,
                                      MAC_PROTOCOL_CELLULAR,
                                      MSG_MAC_CELLULAR_FromNetwork);
    MESSAGE_PacketAlloc(node,
                        callDisconnectMsg,
                        sizeof(CellularAbstractCallDisconnectPkt),
                        TRACE_CELLULAR);

    callDisconnectPkt =
        (CellularAbstractCallDisconnectPkt *)
            MESSAGE_ReturnPacket(callDisconnectMsg);

    callDisconnectPkt->appId = appId;
    callDisconnectPkt->transactionId = transactionId;
    callDisconnectPkt->appSrcNodeId = appSrcNodeId;
    callDisconnectPkt->appDestNodeId = appDestNodeId;
    callDisconnectPkt->callDiscCause = callDiscCause;

    callDisconnectPkt->callDisconnectType =
        CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_MS;

    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        callDisconnectPkt->srcBsNodeId =
            nwCellularAbstractMsInfo->
                associatedBsSectorInfo->associatedBSNodeId;

        //update stats
        nwCellularAbstractMsInfo->stats.numMOCallDisconnectByMsSent ++;

        if (DEBUG_CC)
        {
            printf("at %015" TYPES_64BITFMT "d node %d NW CC: "
                   "sending a MO CALL DISCOONET message\n",
                   node->getNodeTime(),
                   node->nodeId);
            fflush(stdout);
        }
    }

    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        callDisconnectPkt->destBsNodeId =
            nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId;
        //update stats
        nwCellularAbstractMsInfo->stats.numMTCallDisconnectByMsSent ++;
        if (DEBUG_CC)
        {
            printf("at %015" TYPES_64BITFMT "d node %d NW CC: sending a"
                   "MT CALL DISCOONET by ms message\n",
                   node->getNodeTime(),
                   node->nodeId);
            fflush(stdout);
        }
    }

    callDisconnectPkt->callSrcDestType = callSrcDestType;

    //send to mac
    //send the setup msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        callDisconnectMsg,
        CELLULAR_PD_CC,//protocl discritptor
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_DISCONNECT,//layer 3 message type
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,//interlayer info type

        nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].assignedULChannelIndex[0],

        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,//
        CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only assocatiated BS

        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId,
        delay);

    //STOP all running call control timer
    CellularAbstractMsStopCallControlTimer(node, itemIndex);

    // start timer 305
    CellularAbstractGenericTimerInfo timerInfo;

    timerInfo.timerType = MSG_NETWORK_CELLULAR_T305Timer;

    timerInfo.transactionId=transactionId;
    timerInfo.srcNodeId=node->nodeId;
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT305=
        CellularAbstractLayer3StartTimer(
            node,
            DefaultCellularAbstractCallControl_T305Time,
            &timerInfo,
            sizeof(CellularAbstractGenericTimerInfo));

    //change the cc state
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_DISCONNECT_REQUEST;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW CC: sending a"
               "CALL DISCOONET message\n",
               node->getNodeTime(),
               node->nodeId);
        fflush(stdout);
    }
}

//**************************************************************************
// FUNCTION   :: CellularAbstractMsSendCallReleaseCompleteMs
// LAYER      :: Layer3
// PURPOSE    :: Send Call release ack msg
// PARAMETERS ::
// + node                : Node * : Pointer to node.
// + appId               : int    : Application id
// + transactionId       : int    : Transaction Id of the application
// + appSrcNodeId        : NodeAddress  : Source node address
// + appDestNodeId       : NodeAddress  : Dest node address
// + callSrcDestType : CellularAbstractCallSrcDestTyp : Type of  Src and dest
// + callReleaseCompleteType:CellularAbstractCallReleaseCompleteType:
//                                       Type of call release
// RETURN     :: void : NULL
//**************************************************************************
static
void CellularAbstractMsSendCallReleaseCompleteMsg(
        Node *node,
        int appId,
        int transactionId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        CellularAbstractCallReleaseCompleteType callReleaseCompleteType)

{
    CellularAbstractCallReleaseCompletePkt *callRelCompPkt;
    Message *callRelCompMsg;
    int itemIndex;
    NodeAddress msNodeId = CELLULAR_ABSTRACT_INVALID_MS_ID;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    callRelCompMsg = MESSAGE_Alloc( node,
                                    MAC_LAYER,
                                    MAC_PROTOCOL_CELLULAR,
                                    MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        callRelCompMsg,
                        sizeof(CellularAbstractCallReleaseCompletePkt),
                        TRACE_CELLULAR);

    callRelCompPkt =
        (CellularAbstractCallReleaseCompletePkt *)
            MESSAGE_ReturnPacket(callRelCompMsg);

    callRelCompPkt->appId = appId;
    callRelCompPkt->transactionId = transactionId;
    callRelCompPkt->appSrcNodeId = appSrcNodeId;
    callRelCompPkt->appDestNodeId = appDestNodeId;
    callRelCompPkt->callSrcDestType = callSrcDestType;
    callRelCompPkt->callReleaseCompleteType = callReleaseCompleteType;

    //get the channel
     if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        msNodeId = appSrcNodeId;
    }
    else if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        msNodeId = appDestNodeId;
    }

    ERROR_Assert(msNodeId != CELLULAR_ABSTRACT_INVALID_MS_ID,
                 " Unknown MS Node Id");
    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            msNodeId,
            &itemIndex) == TRUE,
        "cannot found the appInfo need to send call release complete msg");

    //send the setup msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        callRelCompMsg,
        CELLULAR_PD_CC,//protocl discritptor
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_RELEASE_COMPLETE,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,

        nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].assignedULChannelIndex[0],

        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,

        nwCellularAbstractMsInfo->
        associatedBsSectorInfo->associatedBSNodeId);

    //update stat
    nwCellularAbstractMsInfo->stats.numCallReleaseCompleteSent ++;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d CC:send call"
               "release complete to network\n",
                node->getNodeTime(),
                node->nodeId);
        fflush(stdout);
    }
}
//********************************************************************
// FUNCTION   :: CellularAbstractMsSendCallReleaseMsg
// LAYER      :: Layer3
// PURPOSE    :: Send Call release msg
// PARAMETERS ::
// + node                : Node *      : Pointer to node.
// + appId               : int         : Application id
// + appSrcNodeId        : NodeAddress : Source node address
// + appDestNodeId       : NodeAddress : Dest node address
// + callSrcDestType : CellularAbstractCallSrcDestTyp : Type of Src & dest
// + callReleaseCompleteType:CellularAbstractCallReleaseCompleteType: 
//                                       Type of call release
// RETURN     :: void : NULL
//**********************************************************************
static
void CellularAbstractMsSendCallReleaseMsg(
        Node *node,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        CellularAbstractCallReleaseType callReleaseType)
{
    int itemIndex;
    int transactionId;
    CellularAbstractCallReleasePkt *callReleasePkt;
    Message *callReleaseMsg;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    callReleaseMsg = MESSAGE_Alloc(node,
                                  MAC_LAYER,
                                  MAC_PROTOCOL_CELLULAR,
                                  MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        callReleaseMsg,
                        sizeof(CellularAbstractCallReleaseCompletePkt),
                        TRACE_CELLULAR);

    callReleasePkt =
        (CellularAbstractCallReleasePkt *)
            MESSAGE_ReturnPacket(callReleaseMsg);

    callReleasePkt->appId = appId;
    callReleasePkt->appSrcNodeId = appSrcNodeId;
    callReleasePkt->appDestNodeId = appDestNodeId;
    callReleasePkt->callSrcDestType = callSrcDestType;
    callReleasePkt->callReleaseType = callReleaseType;

    ERROR_Assert(
        CellularAbstractMsLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            &itemIndex,
            &transactionId) == TRUE,
        "cannot find the appInof need to send call release msg");

    callReleasePkt->transactionId = transactionId;

    //send the setup msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        callReleaseMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_RELEASE,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,

        nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].assignedULChannelIndex[0],

        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,//
        CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only assocatiated BS

        nwCellularAbstractMsInfo->
        associatedBsSectorInfo->associatedBSNodeId);

    //update stat
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        nwCellularAbstractMsInfo->stats.numMOCallReleaseByMsSent ++;
        if (DEBUG_CC)
        {
            printf("at %015" TYPES_64BITFMT "d node %d CC: send MO call "
                   "release by ms to network\n",
                   node->getNodeTime(),
                   node->nodeId);
            fflush(stdout);
        }
    }
    else if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        nwCellularAbstractMsInfo->stats.numMTCallReleaseByMsSent ++;
        if (DEBUG_CC)
        {
            printf("at %015" TYPES_64BITFMT "d node %d CC: send MT call "
                   "release by ms to network\n",
                   node->getNodeTime(),
                   node->nodeId);
            fflush(stdout);
        }
    }
}

//************************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3CalculateSignalStrength
// LAYER      :: Layer3
// PURPOSE    :: Calculate the signal strength. In theory, the strength
//               should be reported by the PHY model. Here, we simply
//               estimate signal strength by calculating the distance to BS
//               Added for optimization
// PARAMETERS ::
// + node       : Node*       : Pointer to the Node
// + bsLocation : Coordinates : location of the BS
// + msLocation : Coordinates : location of myself (MS)
// + signalStrength : double* : for return the signal strength calculated
// + numSector : short : number of sectors of this BS
// + sectorId : int* : for return sector id of this measurement
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractLayer3CalculateSignalStrength(Node *node,
                                                   Coordinates *bsLocation,
                                                   Coordinates *msLocation,
                                                   double *signalStrength,
                                                   short numSector,
                                                   int  *sectorId)
{
    Orientation DOA1;
    Orientation DOA2;
    *sectorId = CELLULAR_ABSTRACT_INVALID_SECTOR_ID;

    COORD_CalcDistanceAndAngle(
        NODE_GetTerrainPtr(node)->getCoordinateSystem(),
        bsLocation,
        msLocation,
        signalStrength,
        &DOA1,
        &DOA2);

    if (DEBUG_CELLSELECTION)
    {
        printf("The BS to MS angle is %f numSector is %d so the "
               "sectorId is %d\n",
               DOA1.azimuth,numSector, *sectorId);
        fflush(stdout);
    }

    //determine the sector id that closest to the ms
    *sectorId = (short)(DOA1.azimuth /
                (double)(ANGLE_RESOLUTION / numSector)) + 1;

    if (DEBUG_CELLSELECTION)
    {
        printf("The BS to MS angle is %f numSector is %d so the "
               "sectorId is %d\n",
               DOA1.azimuth,numSector,*sectorId);
        fflush(stdout);
    }

}

//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3Callback
// LAYER      :: Layer3
// PURPOSE    :: Callback function for mobility layer to notify of movement
//               Added for optimization
// PARAMETERS ::
// + node             : Node*                       : Pointer to node.
// RETURN     :: void : NULL
// **/
//*************************************************************************
void CellularAbstractLayer3Callback(
         Node* node)
{


    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;
    double distance;

    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    COORD_CalcDistance(
        NODE_GetTerrainPtr(node)->getCoordinateSystem(),
        &(node->mobilityData->current->position),
        &(nwCellularAbstractMsInfo->lastUpdatePosition),
        &distance
    );

    if (distance >= nwCellularAbstractData->movThreshold)
    {
        //generate signal strength report here.
        int i;
        int sectorId;
        double signalStrength;
        double minStrength;
        int minIndex;
        CellularAbstractLayer3BsMinInfo* bsMinInfo;
        CellularAbstractMeasurementReportMsgInfo
            reportInfo[CELLULAR_ABSTRACT_MAX_BS_SECTOR_CANDIDATE];

        for (i = 0; i < CELLULAR_ABSTRACT_MAX_BS_SECTOR_CANDIDATE; i++)
        {
            reportInfo[i].monitoredBsId =
                (NodeAddress) CELLULAR_ABSTRACT_INVALID_BS_ID;
            reportInfo[i].monitoredSectorId =
                CELLULAR_ABSTRACT_INVALID_SECTOR_ID;
            reportInfo[i].receivedSignalStrength = -1;
        }
        minIndex = 0;
        minStrength = 0;
        for (i = 0, bsMinInfo = nwCellularAbstractMsInfo->bsMinInfo;
                i < CELLULAR_ABSTRACT_MAX_BS_SECTOR_CANDIDATE &&
                bsMinInfo != NULL; bsMinInfo = bsMinInfo->next, i++)
        {
            CellularAbstractMsHandleSystemInformation(node,
                bsMinInfo->systemInfoType2);

            CellularAbstractLayer3CalculateSignalStrength(node,
                &(bsMinInfo->bsPosition),
                &(node->mobilityData->current->position),
                &signalStrength,
                bsMinInfo->numSectors,
                &sectorId);

            reportInfo[i].monitoredBsId =
                bsMinInfo->bsNodeId;
            reportInfo[i].monitoredSectorId =  sectorId;
            reportInfo[i].receivedSignalStrength = signalStrength;
        }

        for (; bsMinInfo != NULL; bsMinInfo = bsMinInfo->next)
        {
            CellularAbstractMsHandleSystemInformation(node,
                bsMinInfo->systemInfoType2);

            CellularAbstractLayer3CalculateSignalStrength(node,
                &(bsMinInfo->bsPosition),
                &(node->mobilityData->current->position),
                &signalStrength,
                bsMinInfo->numSectors,
                &sectorId);

            for (i = 0, minStrength = 0.0, minIndex = 0;
                    i < CELLULAR_ABSTRACT_MAX_BS_SECTOR_CANDIDATE; i++)
            {
                if (reportInfo[i].receivedSignalStrength > minStrength)
                {
                    minIndex = i;
                    minStrength = reportInfo[i].receivedSignalStrength;
                }
            }

            reportInfo[minIndex].monitoredBsId =
                bsMinInfo->bsNodeId;
            reportInfo[minIndex].monitoredSectorId =  sectorId;
            reportInfo[minIndex].receivedSignalStrength = signalStrength;
        }

        memcpy(nwCellularAbstractMsInfo->reportInfo,
            reportInfo,
            CELLULAR_ABSTRACT_MAX_BS_SECTOR_CANDIDATE
            * sizeof(CellularAbstractMeasurementReportMsgInfo));

        CellularAbstractMsSelectCellSector(node);

        nwCellularAbstractMsInfo->lastUpdatePosition
            = node->mobilityData->current->position;
    }
}
////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////HANDLE MESSAGE////////////////////
////////////////////////////////////////////////////////////////////////////
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsProcessT3230Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T3230.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractMsProcessT3230Timer(Node *node, Message *msg)
{
    if (DEBUG_MM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d MM: handle Cm service "
               "request timer T3230 msg\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}

///***************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsProcessT3126Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers 3126.
//               after M+1 retry,notify the one cause this channel request,
//               either MM layer loction update or RR call
//               conncetion or pageing response
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//****************************************************************************
static
void CellularAbstractMsProcessT3126Timer(Node *node, Message *msg)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;
    CellularAbstractChannelRequestInfo *msChannelReqInfo;
    CellularAbstractGenericTimerInfo *msgInfo;

    if (DEBUG_RR)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW-MM: process the"
               " channel request timer T3126\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    //update  stats
    nwCellularAbstractMsInfo->stats.numChannelRequestFailure ++;

    //look for the transaction associate with this timer
    msgInfo = (CellularAbstractGenericTimerInfo *)(MESSAGE_ReturnInfo(msg));

    if (msgInfo->transactionId == 0)
    {
        //location update failuare
        msChannelReqInfo =
            (CellularAbstractChannelRequestInfo *)
                nwCellularAbstractMsInfo->channelReqForLocationUpdate;

        msChannelReqInfo->isRequestingChannel = FALSE;

        if (msChannelReqInfo->channelRequestMsg != NULL)
        {
            MESSAGE_Free(node, msChannelReqInfo->channelRequestMsg);
            msChannelReqInfo->channelRequestMsg = NULL;
        }

        if (msChannelReqInfo->channelRequestTimer != NULL)
        {
            MESSAGE_CancelSelfMsg(
                node,
                msChannelReqInfo->channelRequestTimer);
            msChannelReqInfo->channelRequestTimer = NULL;
        }

        // set the time 3126 pointer to NULL
        msChannelReqInfo->timerT3126Msg = NULL;

        //update stats
        nwCellularAbstractMsInfo->stats.numLocationUpdateFailaure ++;
        nwCellularAbstractMsInfo->isLocationUpdateInProgress = FALSE;

        //if poweroff is  in process and MS cannot get resource to detach
        //then directly turn off
        if (nwCellularAbstractMsInfo->powerOffInProgress == TRUE
             && nwCellularAbstractMsInfo->locationUpdatingType ==
                    CELLULAR_ABSTRACT_IMSI_DETACH)
        {

            if (nwCellularAbstractMsInfo->handoverState ==
                CELLULAR_ABSTRACT_HANDOVER_STATE_PENDING)
            {
                nwCellularAbstractMsInfo->handoverState =
                    CELLULAR_ABSTRACT_HANDOVER_STATE_IDLE;
            }
            nwCellularAbstractMsInfo->isBsSelected = FALSE;
            nwCellularAbstractMsInfo->isPowerOn = FALSE;
            nwCellularAbstractMsInfo->powerOffInProgress = FALSE;

            //TODO: give mac a notification of poweroff
            /*powerOffMsg =
                MESSAGE_Alloc(
                    node,
                    MAC_LAYER,
                    MAC_PROTOCOL_CELLULAR,
                    MSG_CELLULAR_PowerOff);

            MESSAGE_Send(
                node,
                powerOffMsg,
                0);*/
            return;
        }

        //check handover is needed
        if (nwCellularAbstractMsInfo->handoverState ==
            CELLULAR_ABSTRACT_HANDOVER_STATE_PENDING)
        {
            if (nwCellularAbstractMsInfo->numActiveApplicaions > 0)
            {
                CellularAbstractMsIsHandoverReady(node);
            }
            else
            {
                nwCellularAbstractMsInfo->handoverState =
                    CELLULAR_ABSTRACT_HANDOVER_STATE_IDLE;
            }
        }
    }
    else
    {
        //get channelreqInfo by transaction id;
        int itemIndex;
        Message *callRejectToAppMsg;
        CellularAbstractCallRejectMessageInfo *callRejectToAppMsgInfo;

        ERROR_Assert(
            CellularAbstractMsLookForAppInfoItem(
                node,
                msgInfo->transactionId,
                msgInfo->srcNodeId,
                &itemIndex) == TRUE,
            "cannot find the appInfo associated with this T3126");

        msChannelReqInfo =
            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication;

        msChannelReqInfo->isRequestingChannel = FALSE;

        if (msChannelReqInfo->channelRequestMsg != NULL)
        {
            MESSAGE_Free(node, msChannelReqInfo->channelRequestMsg);
            msChannelReqInfo->channelRequestMsg = NULL;
        }

        if (msChannelReqInfo->channelRequestTimer !=NULL)
        {
            MESSAGE_CancelSelfMsg(
                node,
                msChannelReqInfo->channelRequestTimer);
            msChannelReqInfo->channelRequestTimer = NULL;
        }
        // set the time 3126 pointer to NULL
        msChannelReqInfo->timerT3126Msg = NULL;

        if (node->nodeId ==
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].srcMsNodeId)
            //only src node need to tell the app layer reject msg,
            //which means block channel req
            //for answer paging will not incur any reject msg
        {
            //send the APP a msg about the failaure
            //notify the application layer, call failuare
            callRejectToAppMsg =
                MESSAGE_Alloc(
                    node,
                    APP_LAYER,
                    APP_CELLULAR_ABSTRACT,
                    MSG_APP_CELLULAR_FromNetworkCallRejected);

            MESSAGE_InfoAlloc(
                node,
                callRejectToAppMsg,
                sizeof(CellularAbstractCallRejectMessageInfo));

            callRejectToAppMsgInfo =
                (CellularAbstractCallRejectMessageInfo *)
                    MESSAGE_ReturnInfo(callRejectToAppMsg);

            callRejectToAppMsgInfo->appId =
                nwCellularAbstractMsInfo->msAppInfo[itemIndex].appId;

            callRejectToAppMsgInfo->appSrcNodeId =
                nwCellularAbstractMsInfo->msAppInfo[itemIndex].srcMsNodeId;

            callRejectToAppMsgInfo->appDestNodeId =
                nwCellularAbstractMsInfo->msAppInfo[itemIndex].destMsNodeId;

            callRejectToAppMsgInfo->rejectCause =
                CELLULAR_ABSTRACT_CALL_REJECT_CAUSE_SYSTEM_BUSY;

            //TODO:instance other aribales

            MESSAGE_Send(node, callRejectToAppMsg, 0);

            //update stats
            nwCellularAbstractMsInfo->stats.numCallRejectSent ++;

            if (DEBUG_RR)
            {
                printf("at %015" TYPES_64BITFMT "d node %d: could not"
                       "get CH after max retry send an APP reject with"
                       "system busy cause\n",
                       node->getNodeTime(),
                       node->nodeId);
                fflush(stdout);
            }
            if (DEBUG_CAC)
            {
                printf("at %015" TYPES_64BITFMT "d node %d CC: SRC node"
                       "send a call reject msg to app, itemIndex is %d\n",
                       node->getNodeTime(),
                       node->nodeId,
                       itemIndex);
                fflush(stdout);
            }
        }
        CellularAbstractMsResetAppItem(node, itemIndex);
    }
}

///*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsProcessT3210Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T3210.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
/////***********************************************************************
static
void CellularAbstractMsProcessT3210Timer(Node *node,Message *msg)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;
    CellularAbstractGenericTimerInfo *msgInfo;

    if (DEBUG_RR)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW-MM: process the"
               "location update timer\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;
    msgInfo = (CellularAbstractGenericTimerInfo *)MESSAGE_ReturnInfo(msg);

    // reset the 3210 timer pointer to NULL
    nwCellularAbstractMsInfo->timerT3210Msg = NULL;

    if (nwCellularAbstractMsInfo->numLocationUpdateAttempt <
        CELLULAR_ABSTRACT_MAX_LOCATION_UPDATE_ATTEMPT)
    {
        //update the statis ans sttus
        nwCellularAbstractMsInfo->stats.numLocationUpdateFailaure ++;
        //start 3211
        //schedule a channel request timer to initiate a new location update
        //at this time, the previous allocated resource must have been
        //release by netowrk either by timer T3101
        //(MSG_NETWORK_CELLULAR_ImmediateAssignmentTimer_T3101)
        //or by channel release timer
        CellularAbstractGenericTimerInfo timerInfo;
        timerInfo.timerType=MSG_NETWORK_CELLULAR_T3211Timer;
        timerInfo.transactionId=msgInfo->transactionId;

        nwCellularAbstractMsInfo->timerT3211Msg=
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractLocationUpdateRequestTimer_T3211Time,
                &timerInfo,
                sizeof(CellularAbstractGenericTimerInfo));
    }
    else
    {
        nwCellularAbstractMsInfo->isLocationUpdateInProgress = FALSE;
        nwCellularAbstractMsInfo->numLocationUpdateAttempt = 0;

        //check handover is needed
        if (nwCellularAbstractMsInfo->handoverState ==
            CELLULAR_ABSTRACT_HANDOVER_STATE_PENDING)
        {
            if (nwCellularAbstractMsInfo->numActiveApplicaions > 0)
            {
                CellularAbstractMsIsHandoverReady(node);
            }
            else
            {
                nwCellularAbstractMsInfo->handoverState =
                    CELLULAR_ABSTRACT_HANDOVER_STATE_IDLE;
            }
        }

        //schedule the periodic location
        if (nwCellularAbstractMsInfo->isLocationUpdateInProgress == FALSE
            && nwCellularAbstractMsInfo->timerT3212Msg == NULL)
        {
            //start T3212 to schedule location update
            CellularAbstractGenericTimerInfo timerInfo;
            timerInfo.timerType=MSG_NETWORK_CELLULAR_T3212Timer;
            timerInfo.transactionId=msgInfo->transactionId;

            nwCellularAbstractMsInfo->timerT3212Msg =
                CellularAbstractLayer3StartTimer(
                    node,
                    nwCellularAbstractMsInfo->t3212TimeoutValue,
                    &timerInfo,
                    sizeof(CellularAbstractGenericTimerInfo));
        }
    }
}
///********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsProcessT3211Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T3211.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractMsProcessT3211Timer(Node *node, Message *msg)
{

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    // reset the tiemr pointer
    nwCellularAbstractMsInfo->timerT3211Msg = NULL;

    //start a new location update attempt
    CellularAbstractMsPrepareLocationUpdate(
        node,
        CELLULAR_EST_CAUSE_LOCATION_UPDATING,
        CELLULAR_ABSTRACT_NORMAL_LOCATION_UPDATING);

    if (DEBUG_MM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d MS node MM: begin a "
               "T3211 for a new location update\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}

//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsProcessT3212Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T3212.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractMsProcessT3212Timer(Node *node,Message *msg)
{
    CellularAbstractGenericTimerInfo *msgInfo;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    // reset the timer pointer
    nwCellularAbstractMsInfo->timerT3211Msg = NULL;

    if (nwCellularAbstractMsInfo->isLocationUpdateInProgress == FALSE
        && nwCellularAbstractMsInfo->numActiveApplicaions == 0
        && nwCellularAbstractMsInfo->isBsSelected == TRUE)
    {
        CellularAbstractMsPrepareLocationUpdate(
            node,
            CELLULAR_EST_CAUSE_LOCATION_UPDATING,
            CELLULAR_ABSTRACT_PERIODIC_LOCATION_UPDATING);

        //update stats
        nwCellularAbstractMsInfo->stats.numLocationUpdateAttempt ++;

        msgInfo =
            (CellularAbstractGenericTimerInfo *)MESSAGE_ReturnInfo(msg);

        //reset the attempt number
        nwCellularAbstractMsInfo->numLocationUpdateAttempt = 0;

        //schedule the next location update
        CellularAbstractGenericTimerInfo timerInfo;
        timerInfo.timerType = MSG_NETWORK_CELLULAR_T3212Timer;
        timerInfo.transactionId = msgInfo->transactionId;
        nwCellularAbstractMsInfo->timerT3212Msg =
            CellularAbstractLayer3StartTimer(
                node,
                nwCellularAbstractMsInfo->t3212TimeoutValue,
                &timerInfo,
                sizeof(CellularAbstractGenericTimerInfo));
    }
    else
    {
        nwCellularAbstractMsInfo->timerT3212Msg = NULL;
    }
}
///**********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsProcessT3110Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T3110.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
///***********************************************************************
static
void CellularAbstractMsProcessT3110Timer(Node *node, Message *msg)
{
    CellularAbstractGenericTimerInfo *msgInfo;
    int itemIndex;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    if (DEBUG_RR)
    {
        printf("at %015" TYPES_64BITFMT "d node %d: RR: process T3110, "
               "and deativate the assigned resource\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    msgInfo =
        (CellularAbstractGenericTimerInfo *)MESSAGE_ReturnInfo(msg);

    if (msgInfo->transactionId == 0)
    {
        nwCellularAbstractMsInfo->isLocationUpdateInProgress = FALSE;

        if (nwCellularAbstractMsInfo->powerOffInProgress == TRUE
             && nwCellularAbstractMsInfo->locationUpdatingType ==
                    CELLULAR_ABSTRACT_IMSI_DETACH )
        {

            nwCellularAbstractMsInfo->isBsSelected = FALSE;
            nwCellularAbstractMsInfo->isPowerOn = FALSE;
            nwCellularAbstractMsInfo->powerOffInProgress = FALSE;

            if (nwCellularAbstractMsInfo->handoverState ==
                CELLULAR_ABSTRACT_HANDOVER_STATE_PENDING)
            {
                nwCellularAbstractMsInfo->handoverState =
                    CELLULAR_ABSTRACT_HANDOVER_STATE_IDLE;
            }

            if (DEBUG_RR || DEBUG_POWERONOFF)
            {
                printf("at %015" TYPES_64BITFMT "d node %d: RR: powered"
                       "off from  now on\n",
                       node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }

            //TODO:POWEROFF give mac a notification of poweroff
            /*powerOffMsg =
                MESSAGE_Alloc(
                    node,
                    MAC_LAYER,
                    MAC_PROTOCOL_CELLULAR,
                    MSG_CELLULAR_PowerOff);

            MESSAGE_Send(
                node,
                powerOffMsg,
                0);*/

            return;
        }

        //check handover is needed
        if (nwCellularAbstractMsInfo->handoverState ==
            CELLULAR_ABSTRACT_HANDOVER_STATE_PENDING)
        {
            if (nwCellularAbstractMsInfo->numActiveApplicaions > 0)
            {
                CellularAbstractMsIsHandoverReady(node);
            }
            else
            {
                nwCellularAbstractMsInfo->handoverState =
                    CELLULAR_ABSTRACT_HANDOVER_STATE_IDLE;
            }

            if (DEBUG_HANDOVER)
            {
                printf("at %015" TYPES_64BITFMT "d node %d finish loc update, "
                       "need to check handover is pending "
                       "and ready to handover\n",
                       node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }


    }
    else
    {
        if (
            CellularAbstractMsLookForAppInfoItem(
                node,
                msgInfo->transactionId,
                msgInfo->srcNodeId,
                &itemIndex) == TRUE)
        {

            nwCellularAbstractMsInfo->numActiveApplicaions --;

            CellularAbstractMsResetAppItem(node, itemIndex);
        }

        //check see if any handover is needed
        if (nwCellularAbstractMsInfo->handoverState ==
            CELLULAR_ABSTRACT_HANDOVER_STATE_PENDING)
        {
            if (nwCellularAbstractMsInfo->numActiveApplicaions > 0)
            {
                CellularAbstractMsIsHandoverReady(node);
            }
            else
            {
                nwCellularAbstractMsInfo->handoverState =
                    CELLULAR_ABSTRACT_HANDOVER_STATE_IDLE;
            }
            if (DEBUG_HANDOVER)
            {
                printf("at %015" TYPES_64BITFMT "d node %d finishone call's"
                       "resource resource,need to check handover is pending"
                       "and ready to handover\n",
                       node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }

        //give MAC a inidcation of no application
        if (nwCellularAbstractMsInfo->numActiveApplicaions == 0)
        {
            Message *noAppMsg;
            noAppMsg = MESSAGE_Alloc(
                            node,
                            MAC_LAYER,
                            MAC_PROTOCOL_CELLULAR,
                            MSG_MAC_CELLULAR_FromNetworkNoTransaction);

            MESSAGE_SetInstanceId(noAppMsg,
                                  (short)nwCellularData->interfaceIndex);

            MESSAGE_Send(node, noAppMsg, 0);

            if (DEBUG_NET2MAC)
            {
                printf(
                    "node %d: notify MAC, network state"
                    "from active application"
                    " to idle with no appplication\n",
                    node->nodeId);
                fflush(stdout);
            }
            //GUI_CELLULAR
            if (node->guiOption == TRUE)
            {
                GUI_SetNodeIcon(
                    node->nodeId,
                    "icons/MS-idle.png",
                    node->getNodeTime());
            }
            //GUI_CELLULAR
        }
    }

    if (nwCellularAbstractMsInfo->numActiveApplicaions == 0
        && nwCellularAbstractMsInfo->isLocationUpdateInProgress == FALSE
        && nwCellularAbstractMsInfo->timerT3212Msg == NULL)
    {
        //start T3112 to schedule location update
        CellularAbstractGenericTimerInfo timerInfo;
        timerInfo.timerType = MSG_NETWORK_CELLULAR_T3212Timer;
        timerInfo.transactionId = msgInfo->transactionId;
        nwCellularAbstractMsInfo->timerT3212Msg =
            CellularAbstractLayer3StartTimer(
                node,
                nwCellularAbstractMsInfo->t3212TimeoutValue,
                &timerInfo,
                sizeof(CellularAbstractGenericTimerInfo));
    }
}

//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsProcessT3240Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T3240.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractMsProcessT3240Timer(Node *node, Message *msg)
{
    CellularAbstractGenericTimerInfo *msgInfo;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_RR)
    {
        printf("at %015" TYPES_64BITFMT "d node %d RR: process T3240"
               "timer waitng for channel release from nw \n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    msgInfo = (CellularAbstractGenericTimerInfo *)MESSAGE_ReturnInfo(msg);

    //start tiemr 3110 to reset resource
    CellularAbstractGenericTimerInfo timerInfo;
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T3110Timer;
    timerInfo.transactionId = msgInfo->transactionId;
    timerInfo.srcNodeId = node->nodeId;
    CellularAbstractLayer3StartTimer(
        node,
        DefaultCellularAbstractMsChannelReleaseTimer_T3110Time,
        &timerInfo,
        sizeof(CellularAbstractGenericTimerInfo));

    // reset the pointer to NULL
    if (msgInfo->transactionId == 0)
    {
        nwCellularAbstractMsInfo->
            channelReqForLocationUpdate->timerT3240Msg = NULL;
    }
    else
    {
        int itemIndex;

        ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            msgInfo->transactionId,
            node->nodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for the T3240");
        nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].channelRequestForApplication->
                timerT3240Msg = NULL;
    }
}

//********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsProcessT303Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T303.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractMsProcessT303Timer(Node *node, Message *msg)
{
    int itemIndex;
    CellularAbstractGenericTimerInfo *msgInfo;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d MS process T303 timer\n",
               node->getNodeTime(),
               node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    msgInfo = (CellularAbstractGenericTimerInfo *)MESSAGE_ReturnInfo(msg);

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            msgInfo->transactionId,
            msgInfo->srcNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo associated with the T303");

    // reset the pointer
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303 = NULL;

    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
        CELLULAR_ABSTRACT_MS_CC_STATE_MM_CONNECTION_PENDING)
    {
        //TODO:
        //notify applicaiton the call is rejected;
    }
    else if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
        CELLULAR_ABSTRACT_MS_CC_STATE_CALL_INITIATED)
    {
        //TODO
    }
}

//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsProcessT305Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T305.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractMsProcessT305Timer(Node *node, Message *msg)
{
    CellularAbstractTimer308Info timerInfo;
    CellularAbstractGenericTimerInfo *msgInfo;
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d MS process T305 timer\n",
               node->getNodeTime(),
               node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    msgInfo =
        (CellularAbstractGenericTimerInfo *)MESSAGE_ReturnInfo(msg);

    transactionId = msgInfo->transactionId;

     //msg->srcNodeId should equal to nodeId
    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            msgInfo->srcNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this T305");

    // reset the pointer
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT305 = NULL;

    appId = nwCellularAbstractMsInfo->msAppInfo[itemIndex].appId;
    appSrcNodeId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].srcMsNodeId;

    appDestNodeId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].destMsNodeId;

    callSrcDestType =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].callSrcDestType;

    //send release msg to network side
    CellularAbstractMsSendCallReleaseMsg(
        node,
        appId,
        appSrcNodeId,
        appDestNodeId,
        callSrcDestType,
        CELLULAR_ABSTRACT_CALL_RELEASE_BY_MS);

    //start timer T308
    timerInfo.srcNodeId = node->nodeId;
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T308Timer;
    timerInfo.transactionId = transactionId;
    timerInfo.numExpiration = 0;
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT308 =
        CellularAbstractLayer3StartTimer(
            node,
            DefaultCellularAbstractCallControl_T308Time,
            &timerInfo,
            sizeof(CellularAbstractTimer308Info));

    //change state to release request
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_RELEASE_REQUEST;
}

//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsProcessT308Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T308.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractMsProcessT308Timer(Node *node,Message *msg)
{
    CellularAbstractTimer308Info *msgInfo;
    int                             numExpiration;
    int                             itemIndex;
    int                             transactionId;
    int                             appId;
    NodeAddress                     appSrcNodeId;
    NodeAddress                     appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d MS node %d process T308 timer\n",
                node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    msgInfo = (CellularAbstractTimer308Info *)MESSAGE_ReturnInfo(msg);

    transactionId = msgInfo->transactionId;
    numExpiration = msgInfo->numExpiration;
    numExpiration ++;

    //msg->srcNodeId should equal to nodeId
    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            msgInfo->srcNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for the T308");

    appId = nwCellularAbstractMsInfo->msAppInfo[itemIndex].appId;

    appSrcNodeId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].srcMsNodeId;

    appDestNodeId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].destMsNodeId;

    callSrcDestType =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].callSrcDestType;

    // reset the timer pointer
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT308 = NULL;

    if (numExpiration < DefaultCellularAbstractCallControl_T308MaxRetry)
    {
        //send release msg to network side again
        CellularAbstractTimer308Info timerInfo;
        CellularAbstractMsSendCallReleaseMsg(
            node, appId, appSrcNodeId, appDestNodeId,
            callSrcDestType, CELLULAR_ABSTRACT_CALL_RELEASE_BY_MS);

        //restart timer T308
        timerInfo.srcNodeId = node->nodeId;
        timerInfo.timerType = MSG_NETWORK_CELLULAR_T308Timer;
        timerInfo.transactionId = transactionId;
        timerInfo.numExpiration = numExpiration;
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT308 =
            CellularAbstractLayer3StartTimer(
                node, DefaultCellularAbstractCallControl_T308Time,
                &timerInfo, sizeof(CellularAbstractTimer308Info));

        //change state to release request
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
            CELLULAR_ABSTRACT_MS_CC_STATE_RELEASE_REQUEST;
    }
    else
    {
        //TODO release MM  connection
        //start T3240 for release
        //cc state to null
        CellularAbstractGenericTimerInfo timerInfo;
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
            CELLULAR_ABSTRACT_MS_CC_STATE_NULL;
        timerInfo.timerType = MSG_NETWORK_CELLULAR_T3240Timer;
        timerInfo.transactionId = transactionId;
        timerInfo.srcNodeId = node->nodeId;

        nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].channelRequestForApplication->
                timerT3240Msg =
                CellularAbstractLayer3StartTimer(
                    node,
                    DefaultCellularAbstractMsChannelReleaseTimer_T3240Time,
                    &timerInfo,
                    sizeof(CellularAbstractGenericTimerInfo));
    }
}

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsProcessT310Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T310.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractMsProcessT310Timer(Node *node, Message *msg)
{
    CellularAbstractGenericTimerInfo *msgInfo;
    int itemIndex;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d MS node %d process T310 timer\n",
                node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;
    msgInfo = (CellularAbstractGenericTimerInfo *)MESSAGE_ReturnInfo(msg);

    //msg->srcNodeId should equal to nodeId
    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            msgInfo->transactionId,
            msgInfo->srcNodeId,
            &itemIndex) == TRUE,
        "cannot fins the appInfo for this T310");


    // reset the timer pointer
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT310 = NULL;

    appId = nwCellularAbstractMsInfo->msAppInfo[itemIndex].appId;

    appSrcNodeId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].srcMsNodeId;

    appDestNodeId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].destMsNodeId;

    CellularAbstractMsSendCallDisconnectMsg(
        node,
        appId,
        appSrcNodeId,
        appDestNodeId,
        CELLULAR_ABSTRACT_CALL_DISCONNECT_TIMEOUT);
}

//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsProcessT313Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T313.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractMsProcessT313Timer(Node *node, Message *msg)
{
    CellularAbstractGenericTimerInfo *msgInfo;
    int itemIndex;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d MS node %d: process T313 timer\n",
                node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    msgInfo = (CellularAbstractGenericTimerInfo *)MESSAGE_ReturnInfo(msg);

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            msgInfo->transactionId,
            msgInfo->srcNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this T313");
        //msg->srcNodeId should equal to nodeId

    // reset the timer pointer
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT313 = NULL;

    appId = nwCellularAbstractMsInfo->msAppInfo[itemIndex].appId;

    appSrcNodeId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].srcMsNodeId;

    appDestNodeId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].destMsNodeId;

    CellularAbstractMsSendCallDisconnectMsg(
        node,
        appId,
        appSrcNodeId,
        appDestNodeId,
        CELLULAR_ABSTRACT_CALL_DISCONNECT_TIMEOUT);
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsCongestionControl
// LAYER      :: Layer3
// PURPOSE    :: MS side congestion control.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// RETURN     :: BOOL :
// **/
///*************************************************************************
static
BOOL CellularAbstractMsCongestionControl(Node *node)
{
    BOOL refrainTransmission = FALSE;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_CONGESTION_CONTROL)
    {
        printf("MS node %d: congestion control\n",node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    if (nwCellularAbstractMsInfo->
        associatedBsSectorInfo->congestionControlPolicy ==
        CELLULAR_ABSTRACT_CONGESTION_CONTROL_ROUND_ROBIN)
    {
        // customized code is needed here
        refrainTransmission = FALSE;
    }
    else
    {
        refrainTransmission = FALSE;
    }
    if (DEBUG_CONGESTION_CONTROL)
    {
        printf(
            "MS node %d: congestion control decision is %d\n",
            node->nodeId,
            refrainTransmission);
        fflush(stdout);
    }
    return refrainTransmission;
}

//************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsProcessChannelRequestTimer
// LAYER      :: Layer3
// PURPOSE    :: Handle Channel request timer.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
///*************************************************************************
static
void CellularAbstractMsProcessChannelRequestTimer(Node *node, Message *msg)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;
    CellularAbstractChannelRequestInfo *msChannelReqInfo;
    int slotsToWait;
    Message *chReqMsg;
    CellularAbstractMsChannelRequestTimerInfo *msgInfo;
    BOOL channelRequestGiveUp;

    if (DEBUG_RR)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW-MM: process the"
               "channel request timer\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    //look for the transaction associate with this timer
    msgInfo =
        (CellularAbstractMsChannelRequestTimerInfo *)
        (MESSAGE_ReturnInfo(msg));


    if (msgInfo->transactionId == 0)
    {
        msChannelReqInfo =
            nwCellularAbstractMsInfo->channelReqForLocationUpdate;
    }
    else
    {
        //get channelreqInfo by transaction id and srcNode addr;
        int itemIndex;
        ERROR_Assert(
            CellularAbstractMsLookForAppInfoItem(
                node,
                msgInfo->transactionId,
                msgInfo->srcNodeId,
                &itemIndex) == TRUE,
            "cannot find the appInfo for this channel request timer");

        msChannelReqInfo =
            nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].channelRequestForApplication;
        if (DEBUG_RR)
        {
            printf("at %015" TYPES_64BITFMT "d node %d: Look for appitem,"
                   "itemIndex is %d\n",
                    node->getNodeTime(), node->nodeId, itemIndex);
            fflush(stdout);
        }
    }


    if (msChannelReqInfo->isRequestingChannel == TRUE &&
                    msChannelReqInfo->channelRequestMsg != NULL)
    {
        //if congestio control is employed at BS
        if ((nwCellularAbstractMsInfo->
            associatedBsSectorInfo->congestionControlPolicy ==
            CELLULAR_ABSTRACT_CONGESTION_CONTROL_ROUND_ROBIN) &&
            (CellularAbstractMsCongestionControl(node) == TRUE))
        {
            //schedule next timer
            //schedule a channel request timer to send the next CH REQ
            CellularAbstractMsChannelRequestTimerInfo nextTimerInfo;

            nextTimerInfo.timerType =
                MSG_NETWORK_CELLULAR_WaitForChannelRequestResponseTimer;

            nextTimerInfo.transactionId = msgInfo->transactionId;
            nextTimerInfo.srcNodeId = msgInfo->srcNodeId;

            slotsToWait = (int)(RANDOM_erand(nwCellularData->randSeed)
                            * CELLULAR_RANDACCESS_S *
                            DefaultCellularAbstractSlotNumberPerFrame);

            msChannelReqInfo->channelRequestTimer =
                CellularAbstractLayer3StartTimer(
                    node,
                    slotsToWait*DefaultCellularSlotDuration,
                    &nextTimerInfo,
                    sizeof(CellularAbstractMsChannelRequestTimerInfo));
            return;
        }

        if (msChannelReqInfo->numChannelRequestAttempts
            > (nwCellularAbstractMsInfo->maxReTrans + 1))
        {
            if (DEBUG_RR)
            {
                printf("at %015" TYPES_64BITFMT "d Node %d RR: Max CH-REQ %d+1"
                       "attempts\n",
                       node->getNodeTime(), node->nodeId,
                       nwCellularAbstractMsInfo->maxReTrans + 1 );
                fflush(stdout);
                printf("at %015" TYPES_64BITFMT "d node %d RR: Start T3126\n",
                       node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }

            if (msChannelReqInfo->channelRequestMsg != NULL)
            {
                MESSAGE_Free(node, msChannelReqInfo->channelRequestMsg);
                msChannelReqInfo->channelRequestMsg = NULL;
            }

            // reset the channel request timer pointer
            msChannelReqInfo->channelRequestTimer = NULL;

            // Random Access Failure: start T3126 TODO:
            CellularAbstractGenericTimerInfo timerInfo;
            timerInfo.timerType = MSG_NETWORK_CELLULAR_T3126Timer;
            timerInfo.transactionId = msgInfo->transactionId;
            timerInfo.srcNodeId = msgInfo->srcNodeId;
            msChannelReqInfo->timerT3126Msg =
                CellularAbstractLayer3StartTimer(
                    node,
                    DefaultCellularAbstractMaxRetryTimer_T3126Time,
                    &timerInfo,
                    sizeof(CellularAbstractGenericTimerInfo));
            return;
        }

        slotsToWait =  (int)(RANDOM_erand(nwCellularData->randSeed)
                        * CELLULAR_RANDACCESS_S *
                        DefaultCellularAbstractSlotNumberPerFrame);
        if (DEBUG_RR ||DEBUG_PROGRESS)
        {
            char clockStr[MAX_STRING_LENGTH];
            ctoa(node->getNodeTime(), clockStr);
            printf("at %015" TYPES_64BITFMT "d node %d RR: Sending CH-REQ"
                   "next %d TS at %d attempts to BS%d\n",
                   node->getNodeTime(),
                   node->nodeId,
                   slotsToWait,
                   msChannelReqInfo->numChannelRequestAttempts,

                nwCellularAbstractMsInfo->
                    associatedBsSectorInfo->associatedBSNodeId);
            fflush(stdout);
        }

        //make a copy, for retransmission
        chReqMsg =
            MESSAGE_Duplicate(node, msChannelReqInfo->channelRequestMsg);

        CellularAbstractChannelRequestPkt *outPkt;

        //to make sure the BS sector ID id is
        //the current one after handover or cellselction
        outPkt = (CellularAbstractChannelRequestPkt *)
                            MESSAGE_ReturnPacket(chReqMsg);

        //if it is for page response, make sure it is
        //in the same BS as it rcvd the page request
        channelRequestGiveUp = FALSE;
        if (outPkt->pageReqId != 0)
        {
            if (outPkt->bsNodeId !=
                nwCellularAbstractMsInfo->
                    associatedBsSectorInfo->associatedBSNodeId)
            {
                channelRequestGiveUp = TRUE;
                //cancel the current channel request sicne MS moves
                if (msChannelReqInfo->channelRequestMsg != NULL)
                {
                    MESSAGE_Free(node, msChannelReqInfo->channelRequestMsg);
                    msChannelReqInfo->channelRequestMsg = NULL;
                }

                //reset the request timer pointer
                msChannelReqInfo->channelRequestTimer = NULL;

                // Random Access Failure: start T3126 TODO:
                CellularAbstractGenericTimerInfo timerInfo;
                timerInfo.timerType = MSG_NETWORK_CELLULAR_T3126Timer;
                timerInfo.transactionId = msgInfo->transactionId;
                timerInfo.srcNodeId = msgInfo->srcNodeId;
                msChannelReqInfo->timerT3126Msg =
                    CellularAbstractLayer3StartTimer(
                        node,
                        DefaultCellularAbstractMaxRetryTimer_T3126Time,
                        &timerInfo,
                        sizeof(CellularAbstractGenericTimerInfo));

                //out the paging BS's range
                if (DEBUG_RR )
                {
                    printf("at %015" TYPES_64BITFMT "d node %d: ch req for "
                           "page res pageReqId %d, to bs %d "
                           "is canceled since cur BS is %d\n",
                           node->getNodeTime(), node->nodeId,
                           outPkt->pageReqId, outPkt->bsNodeId,
                           nwCellularAbstractMsInfo->
                           associatedBsSectorInfo->associatedBSNodeId);
                    fflush(stdout);
                }
                return;
            }
        }

        if (channelRequestGiveUp == FALSE)
        {
            //if it can continue, then send to the current BS
            outPkt->bsNodeId =
                nwCellularAbstractMsInfo->
                    associatedBsSectorInfo->associatedBSNodeId;

            outPkt->bsNodeAddr =
                nwCellularAbstractMsInfo->
                    associatedBsSectorInfo->associatedBSNodeAddress;

            outPkt->sectorId =
                nwCellularAbstractMsInfo->
                    associatedBsSectorInfo->associatedSectorId;


            //send the req to mac
            CellularAbstractLayer3SendProtocolMsgToMac(
                node,
                chReqMsg,
                CELLULAR_PD_RR,
                CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_CHANNEL_REQUEST,
                CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,

                nwCellularAbstractMsInfo->
                    associatedBsSectorInfo->controlULChannelIndex,

                CELLULAR_ABSTRACT_CONTROL_CHANNEL_RACCH,

                CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only assocatiated BS

                nwCellularAbstractMsInfo->
                    associatedBsSectorInfo->associatedBSNodeId);

            //update stats
            nwCellularAbstractMsInfo->stats.numChannelRequestSent ++;
            if (DEBUG_RR )
            {
                printf("at %015" TYPES_64BITFMT "d node %d: ch req"
                       " for page res page pageReqId %d,"
                       "to bs %d my cur BS %d\n",
                       node->getNodeTime(), node->nodeId,
                       outPkt->pageReqId, outPkt->bsNodeId,
                       nwCellularAbstractMsInfo->
                         associatedBsSectorInfo->associatedBSNodeId);
                fflush(stdout);
            }
        }

        msChannelReqInfo->numChannelRequestAttempts ++;

        //schedule a channel request timer to send the next CH REQ
        CellularAbstractMsChannelRequestTimerInfo timerInfo;

        timerInfo.timerType =
            MSG_NETWORK_CELLULAR_WaitForChannelRequestResponseTimer;

        timerInfo.transactionId = msgInfo->transactionId;
        timerInfo.srcNodeId = msgInfo->srcNodeId;

        msChannelReqInfo->channelRequestTimer =
            CellularAbstractLayer3StartTimer(
                node,
                slotsToWait * DefaultCellularSlotDuration +
                DefaultCellularAbstractImmediateAssignmentTimer_T3101Time,
                &timerInfo,
                sizeof(CellularAbstractMsChannelRequestTimerInfo));
    }
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandlePowerOnMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle power on msg from APP.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractMsHandlePowerOnMsg(Node *node, Message *msg)
{
    Message *scanSignalMsg = NULL;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_NET2APP)
    {
        char clockStr[MAX_STRING_LENGTH];
        ctoa(node->getNodeTime(), clockStr);
        printf("at %015" TYPES_64BITFMT "d node %d NW-APP: "
            "process the power on msg at cur time %s\n",
            node->getNodeTime(), node->nodeId, clockStr);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    if (nwCellularAbstractMsInfo->isPowerOn == TRUE)
    {
        return;
    }

    nwCellularAbstractMsInfo->isPowerOn = TRUE;
    //notify MAClayer of power on

    //TODO: give mac a notification of poweroff
    /*powerOnMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_CELLULAR_PowerOn);

    MESSAGE_Send(
        node,
        powerOnMsg,
        0);*/
    //search for networks when startup

    if (nwCellularAbstractData->optLevel ==
            CELLULAR_ABSTRACT_OPTIMIZATION_LOW)
    {
        scanSignalMsg =
            MESSAGE_Alloc(
                node,
                MAC_LAYER,
                MAC_PROTOCOL_CELLULAR,
                MSG_MAC_CELLULAR_FromNetworkScanSignalPerformMeasurement);

        MESSAGE_SetInstanceId(scanSignalMsg,
                              (short)nwCellularData->interfaceIndex);

        MESSAGE_Send(
            node,
            scanSignalMsg,
            0);
    }
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandlePowerOffMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle power on msg from APP.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractMsHandlePowerOffMsg(Node *node, Message *msg)
{

    int i;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_NET2APP)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW-APP: process the"
               "power off msg\n",
                node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    if (nwCellularAbstractMsInfo->isPowerOn == FALSE)
    {
        return;
    }

    //to prevent new incoming/outgoing applications
    nwCellularAbstractMsInfo->powerOffInProgress = TRUE;

    //cancel pending handover
    if (nwCellularAbstractMsInfo->handoverState ==
                CELLULAR_ABSTRACT_HANDOVER_STATE_PENDING)
    {
        nwCellularAbstractMsInfo->handoverState =
            CELLULAR_ABSTRACT_HANDOVER_STATE_IDLE;
    }

    // abort ongoing calnnel request for location update

    //abort ongoing channel request for calls
    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS; i ++)
    {

        if (nwCellularAbstractMsInfo->msAppInfo[i].inUse == TRUE)
        {

            CellularAbstractChannelRequestInfo *msChannelReqInfo;

            msChannelReqInfo =
                nwCellularAbstractMsInfo->
                msAppInfo[i].channelRequestForApplication;

            //for those are requesting channels, abort
            if (msChannelReqInfo->isRequestingChannel == TRUE)
            {
                if (msChannelReqInfo->channelRequestMsg != NULL)
                {
                    MESSAGE_Free(node, msChannelReqInfo->channelRequestMsg);
                    msChannelReqInfo->channelRequestMsg = NULL;
                    msChannelReqInfo->isRequestingChannel = FALSE;
                }
                if (msChannelReqInfo->channelRequestTimer != NULL)
                {
                    MESSAGE_CancelSelfMsg(
                        node, msChannelReqInfo->channelRequestTimer);

                    msChannelReqInfo->channelRequestTimer = NULL;
                }
                //stop the T3126 if running
                if (msChannelReqInfo->timerT3126Msg != NULL)
                {
                    MESSAGE_CancelSelfMsg(
                        node, msChannelReqInfo->timerT3126Msg);
                    msChannelReqInfo->timerT3126Msg = NULL;
                }
                if (msChannelReqInfo->timerT3240Msg != NULL)
                {
                    MESSAGE_CancelSelfMsg(
                        node, msChannelReqInfo->timerT3240Msg);
                    msChannelReqInfo->timerT3240Msg = NULL;
                }
                //in case immediate asisgnment for prevoius sent ch req
                //the immediate will be discarded because
                //it is in power off process
                msChannelReqInfo->isRequestingChannel = FALSE;

                //reset the app info item
                CellularAbstractMsResetAppItem(node, i);

                if (DEBUG_POWERONOFF)
                {
                    printf("at %015" TYPES_64BITFMT "d node %d: cancel"
                           "ongoing challel request due to power off\n",
                           node->getNodeTime(), node->nodeId);
                    fflush(stdout);
                }
            }
        }
    }
    if (nwCellularAbstractMsInfo->handoverState ==
                CELLULAR_ABSTRACT_HANDOVER_STATE_IDLE)
    {
        //cancel the ongoing calls
        for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS; i ++)
        {

            if (nwCellularAbstractMsInfo->msAppInfo[i].inUse == TRUE &&
                nwCellularAbstractMsInfo->msAppInfo[i].msCcState ==
                    CELLULAR_ABSTRACT_MS_CC_STATE_ACTIVE)
            {
                if (nwCellularAbstractMsInfo->msAppInfo[i].applicationType ==
                    CELLULAR_ABSTRACT_VOICE_PHONE)
                {
                    //send disconnect msg out
                    CellularAbstractMsSendCallDisconnectMsg(
                        node,
                        nwCellularAbstractMsInfo->msAppInfo[i].appId,
                        nwCellularAbstractMsInfo->msAppInfo[i].srcMsNodeId,
                        nwCellularAbstractMsInfo->msAppInfo[i].destMsNodeId,
                        CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_POWEROFF,
                        i * MICRO_SECOND);
                    //send call drop msg
                    CellularAbstractMsSendAppCallDroppedMsg(
                        node,
                        nwCellularAbstractMsInfo->msAppInfo[i].appId,
                        nwCellularAbstractMsInfo->msAppInfo[i].srcMsNodeId,
                        nwCellularAbstractMsInfo->msAppInfo[i].destMsNodeId,
                        CELLULAR_ABSTRACT_CALL_DROP_CAUSE_SELF_POWEROFF,
                        i * MICRO_SECOND);
                    if (DEBUG_POWERONOFF)
                    {
                        printf("at %015" TYPES_64BITFMT "d node %d: disc"
                               "ongoing call src %d dest %d due to power"
                               "off\n",
                               node->getNodeTime(),
                               node->nodeId,
                         nwCellularAbstractMsInfo->msAppInfo[i].srcMsNodeId,
                       nwCellularAbstractMsInfo->msAppInfo[i].destMsNodeId);
                        fflush(stdout);
                    }
                }
                else
                {
                    //send deactivate msg out
                    CellularAbstractMsSendDeactivatePDPContextRequestMsg(
                        node,
                        nwCellularAbstractMsInfo->msAppInfo[i].appId,
                        nwCellularAbstractMsInfo->msAppInfo[i].applicationType,
                        nwCellularAbstractMsInfo->msAppInfo[i].srcMsNodeId,
                        nwCellularAbstractMsInfo->msAppInfo[i].destMsNodeId,
                        nwCellularAbstractMsInfo->msAppInfo[i].callSrcDestType,
                        CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_POWEROFF,
                        i * MICRO_SECOND);
                    //send call drop msg
                    CellularAbstractMsSendAppCallDroppedMsg(
                        node,
                        nwCellularAbstractMsInfo->msAppInfo[i].appId,
                        nwCellularAbstractMsInfo->msAppInfo[i].srcMsNodeId,
                        nwCellularAbstractMsInfo->msAppInfo[i].destMsNodeId,
                        CELLULAR_ABSTRACT_CALL_DROP_CAUSE_SELF_POWEROFF,
                        i * MICRO_SECOND);
                    if (DEBUG_POWERONOFF)
                    {
                        printf("at %015" TYPES_64BITFMT "d node %d: "
                               "deactivate ongoing PDP context src %d"
                               "dest %d due to power off\n",
                               node->getNodeTime(),
                               node->nodeId,
                               nwCellularAbstractMsInfo->msAppInfo[i].srcMsNodeId,
                               nwCellularAbstractMsInfo->msAppInfo[i].destMsNodeId);
                        fflush(stdout);
                    }
                }
            }
        }
    }
    if (nwCellularAbstractMsInfo->numActiveApplicaions > 0 ||
        nwCellularAbstractMsInfo->isLocationUpdateInProgress ==
        TRUE )
    {
        Message *powerOffMsg;
        powerOffMsg = MESSAGE_Duplicate(node, msg);
        MESSAGE_Send(
            node,
            powerOffMsg,
            CELLULAR_ABSTRACT_NO_COMUNICATION_POLLING_INTERVAL);
        //TODO: disconnect apps
    }
    else
    {
        //reset all the application info

        CellularAbstractMsPrepareLocationUpdate(
                node,
                CELLULAR_EST_CAUSE_LOCATION_UPDATING,
                CELLULAR_ABSTRACT_IMSI_DETACH);
    }

}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleStartCallMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Call start msg from APP.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractMsHandleStartCallMsg(Node *node, Message *msg)
{
    CellularAbstractChannelRequestInfo *chReqInfo;
    CellularAbstractCallStartMessageInfo *callStartMsg;
    CellularAbstractAssociatedBsSectorInfo *bsSectorInfo;
    //app related info
    CellularAbstractApplicationType appType;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    short appNumChannelReq;
    double appBandwidthReq;
    int itemIndex;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_NET2APP)
    {
        char clockStr[MAX_STRING_LENGTH];
        ctoa(node->getNodeTime(), clockStr);
        printf("at %s node %d NW-APP: process the call start msg\n",
            clockStr, node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    bsSectorInfo = nwCellularAbstractMsInfo->associatedBsSectorInfo;


    callStartMsg =
        (CellularAbstractCallStartMessageInfo *)MESSAGE_ReturnInfo(msg);

    appId = callStartMsg->appId;
    appType = callStartMsg->appType;
    appSrcNodeId = callStartMsg->appSrcNodeId;
    appDestNodeId = callStartMsg->appDestNodeId;
    appNumChannelReq = callStartMsg->appNumChannelReq;
    appBandwidthReq = callStartMsg->appBandwidthReq;

    if (DEBUG_NET2APP)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW-APP: process the "
               "call start msg withbandwidth %f\n",
            node->getNodeTime(), node->nodeId, appBandwidthReq);
        fflush(stdout);
    }

    if (nwCellularAbstractMsInfo->isBsSelected==FALSE ||
        nwCellularAbstractMsInfo->isPowerOn == FALSE ||
        nwCellularAbstractMsInfo->powerOffInProgress == TRUE)
    {
        //send the APP a msg about the failaure
        //notify the application layer, call failuare
        Message *callRejectToAppMsg;
        CellularAbstractCallRejectMessageInfo *callRejectToAppMsgInfo;
        callRejectToAppMsg =
            MESSAGE_Alloc(
                node,
                APP_LAYER,
                APP_CELLULAR_ABSTRACT,
                MSG_APP_CELLULAR_FromNetworkCallRejected);

        MESSAGE_InfoAlloc(
            node,
            callRejectToAppMsg,
            sizeof(CellularAbstractCallRejectMessageInfo));

        callRejectToAppMsgInfo =
            (CellularAbstractCallRejectMessageInfo *)
                MESSAGE_ReturnInfo(callRejectToAppMsg);

        callRejectToAppMsgInfo->appId = appId;
        callRejectToAppMsgInfo->appSrcNodeId = appSrcNodeId;
        callRejectToAppMsgInfo->appDestNodeId = appDestNodeId;

        callRejectToAppMsgInfo->rejectCause =
            CELLULAR_ABSTRACT_CALL_REJECT_CAUSE_NETWORK_NOT_FOUND;

        //TODO:instance other aribales

        MESSAGE_Send(node, callRejectToAppMsg, 0);

        //update stats
        nwCellularAbstractMsInfo->stats.numCallRejectSent ++;

        //update stas
        nwCellularAbstractMsInfo->stats.numCallStartRcvd ++;

        return;
    }

    // make sure not too many active transactions on going
    // including active applications and applications
    // requesting channel
    //look for the first unused item
    BOOL foundUnused = FALSE;
    int i;
    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS; i ++)
    {
        if (nwCellularAbstractMsInfo->msAppInfo[i].inUse == FALSE)
        {
            foundUnused = TRUE;
            break;
        }
    }

    //too many active application or transactions?
    if (nwCellularAbstractMsInfo->numActiveApplicaions >=
        CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS ||
        foundUnused == FALSE)
    {
        Message *callRejectToAppMsg;
        CellularAbstractCallRejectMessageInfo *callRejectToAppMsgInfo;
        callRejectToAppMsg =
            MESSAGE_Alloc(
                node,
                APP_LAYER,
                APP_CELLULAR_ABSTRACT,
                MSG_APP_CELLULAR_FromNetworkCallRejected);

        MESSAGE_InfoAlloc(
            node,
            callRejectToAppMsg,
            sizeof(CellularAbstractCallRejectMessageInfo));

        callRejectToAppMsgInfo =
            (CellularAbstractCallRejectMessageInfo *)
                MESSAGE_ReturnInfo(callRejectToAppMsg);

        callRejectToAppMsgInfo->appId = appId;
        callRejectToAppMsgInfo->appSrcNodeId = appSrcNodeId;
        callRejectToAppMsgInfo->appDestNodeId = appDestNodeId;
        callRejectToAppMsgInfo->rejectCause =
            CELLULAR_ABSTRACT_CALL_REJECT_CAUSE_TOO_MANY_ACTIVE_APP;

        MESSAGE_Send(node, callRejectToAppMsg, 0);

        //update stats
        nwCellularAbstractMsInfo->stats.numCallRejectSent ++;

    //update stas
    nwCellularAbstractMsInfo->stats.numCallStartRcvd ++;

        return;
    }

    //for a new apps, need to check if handover is pending
    //or ongoing, otherwise wait until handover is finish
    if (nwCellularAbstractMsInfo->handoverState !=
        CELLULAR_ABSTRACT_HANDOVER_STATE_IDLE)
    {
        Message *callStartMsgCopy;
        callStartMsgCopy = MESSAGE_Duplicate(node, msg);
        MESSAGE_Send(
            node,
            callStartMsgCopy,
            CELLULAR_ABSTRACT_HANDOVER_END_POLLING_INTERVAL);

        if (DEBUG_HANDOVER)
        {
            printf("at %015" TYPES_64BITFMT "d node %d HO--handover is"
                   "peding or ongoing, new application need to wait...\n",
                    node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
        return;
    }

     //update stas
    nwCellularAbstractMsInfo->stats.numCallStartRcvd ++;

    //update the transactionId;
    nwCellularAbstractMsInfo->numTransactions ++;

    //create a item fo rthis transaction
    CellularAbstractMsCreateAppInfoItem(
        node,
        nwCellularAbstractMsInfo->numTransactions,
        appId,
        appType,
        appSrcNodeId,
        appDestNodeId,
        appNumChannelReq,
        appBandwidthReq,
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
        &itemIndex);
    //duration only use for PDP
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].callDuration =
        callStartMsg->appDuration;

    //all the subsequent procedures will use this
    //transaction id and src to identify itself
    //call prepare channel request
    chReqInfo =
        nwCellularAbstractMsInfo->
        msAppInfo[itemIndex].channelRequestForApplication;

    //inita the cc state
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_NULL;

    CellularAbstractMsPrepareChannelRequest(
        node,
        chReqInfo,
        CELLULAR_EST_CAUSE_NORMAL_CALL,
        appNumChannelReq,
        appBandwidthReq,
        CELLULAR_ABSTRACT_CHANNEL_REQUEST_GENERAL,
        nwCellularAbstractMsInfo->numTransactions,
        0);//pageId 0 for caller

    if (DEBUG_RR)
    {
        printf("at %015" TYPES_64BITFMT "d node %d RR: preparing the"
               "channel request for the app %d with transaction id %d\n",
               node->getNodeTime(), node->nodeId,
               appId,
               nwCellularAbstractMsInfo->numTransactions);
        fflush(stdout);
    }
}

//************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleEndCallMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Call Endt msg from APP.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractMsHandleEndCallMsg(Node *node, Message *msg)
{
    CellularAbstractAssociatedBsSectorInfo *bsSectorInfo;
    CellularAbstractCallEndMessageInfo *callEndMsgInfo;
    CellularAbstractApplicationType appType;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    short appNumChannelReq;
    double appBandwidthReq;
    int itemIndex;
    int transactionId;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    if (DEBUG_NET2APP)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW-APP: process the"
               "call end msg\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    bsSectorInfo = nwCellularAbstractMsInfo->associatedBsSectorInfo;
    callEndMsgInfo =
        (CellularAbstractCallEndMessageInfo *)MESSAGE_ReturnInfo(msg);

    appId = callEndMsgInfo->appId;
    appType = callEndMsgInfo->appType;
    appSrcNodeId = callEndMsgInfo->appSrcNodeId;
    appDestNodeId = callEndMsgInfo->appDestNodeId;
    appNumChannelReq = callEndMsgInfo->appNumChannelReq;
    appBandwidthReq = callEndMsgInfo->appBandwidthReq;

    //check if handover failaure cause this app been
    //reset during the handover waiting period
    //initiate the call clear process by sending disonnect msg
    if (CellularAbstractMsLookForAppItemByAppId(
        node, appId, appSrcNodeId, appDestNodeId,
        &itemIndex, &transactionId) == FALSE)
    {
        if (DEBUG_CC||DEBUG_HANDOVER||DEBUG_GENERAL)
        {
            printf("at %015" TYPES_64BITFMT "d node %d HO--handover has"
                   "already removed the app src %d dest %d from the MS"
                   "due to HO failure\n",
                   node->getNodeTime(), node->nodeId,
                   appSrcNodeId, appDestNodeId);
            fflush(stdout);
        }
     //update stat
        nwCellularAbstractMsInfo->stats.numCallEndRcvd ++;
        return;
    }

    //for a apps, need to check if handover is pending or ongoing,
    //otherwise wait until handover is finish
    if (nwCellularAbstractMsInfo->handoverState !=
        CELLULAR_ABSTRACT_HANDOVER_STATE_IDLE)
    {
        Message *callEndMsgCopy;
        callEndMsgCopy = MESSAGE_Duplicate(node, msg);
        MESSAGE_Send(
            node,
            callEndMsgCopy,
            CELLULAR_ABSTRACT_HANDOVER_END_POLLING_INTERVAL);

        if (DEBUG_HANDOVER)
        {
            printf("at %015" TYPES_64BITFMT "d node %d HO--handover is"
                   "peding or ongoing, ending an application src %d dest"
                   " %d need to wait...\n",
                   node->getNodeTime(), node->nodeId,
                   appSrcNodeId, appDestNodeId);
            fflush(stdout);
        }
        return;
    }

    if (appType == CELLULAR_ABSTRACT_VIDEO_PHONE
        || appType == CELLULAR_ABSTRACT_TEXT_MAIL
        || appType == CELLULAR_ABSTRACT_PICTURE_MAIL
        || appType == CELLULAR_ABSTRACT_ANIMATION_MAIL
        || appType == CELLULAR_ABSTRACT_WEB)
    {
        CellularAbstractMsSendDeactivatePDPContextRequestMsg(
            node,
            appId,
            appType,
            appSrcNodeId,
            appDestNodeId,
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
            CELLULAR_ABSTRACT_CALL_DISCONNECT_NORMAL);
    }
    else if (appType == CELLULAR_ABSTRACT_VOICE_PHONE)
    {
        CellularAbstractMsSendCallDisconnectMsg(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            CELLULAR_ABSTRACT_CALL_DISCONNECT_NORMAL);
    }
     //update stat
    nwCellularAbstractMsInfo->stats.numCallEndRcvd ++;
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleNoNetworkFoundMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle network not found msg from MAC.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractMsHandleNoNetworkFoundMsg(Node *node, Message *msg)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    if (nwCellularAbstractMsInfo->isBsSelected == TRUE)
    {
        nwCellularAbstractMsInfo->isBsSelected = FALSE;
        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId =
            (NodeAddress) CELLULAR_ABSTRACT_INVALID_BS_ID;

        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedSectorId =
            CELLULAR_ABSTRACT_INVALID_SECTOR_ID;
    }
}

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleCallAnsweredMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Call answered msg from APP.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***************************************************************************
static
void CellularAbstractMsHandleCallAnsweredMsg(Node *node, Message *msg)
{
    CellularAbstractCallAnsweredMessageInfo *callAnswerInfo;
    CellularAbstractApplicationType appType;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo =
        nwCellularAbstractData->msLayer3Info;

    callAnswerInfo =
        (CellularAbstractCallAnsweredMessageInfo *)MESSAGE_ReturnInfo(msg);

    //to support PDP
    appType = callAnswerInfo->appType;
    if (appType == CELLULAR_ABSTRACT_VIDEO_PHONE
        || appType == CELLULAR_ABSTRACT_TEXT_MAIL
        || appType == CELLULAR_ABSTRACT_PICTURE_MAIL
        || appType == CELLULAR_ABSTRACT_ANIMATION_MAIL
        || appType == CELLULAR_ABSTRACT_WEB)
    {
        return;
    }
    CellularAbstractMsSendConnectMsg(
        node,
        callAnswerInfo->transactionId,
        callAnswerInfo->appId,
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
        callAnswerInfo->appSrcNodeId,
        0,
        callAnswerInfo->appDestNodeId,
        0);//TODO:instance the BS
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleImmediateAssignmentRejectMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Immediate assignemnt reject msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractMsHandleImmediateAssignmentRejectMsg(
        Node *node,
        Message *msg)
{
    CellularAbstractImmediateAssignmentRejectPkt *assignmentRejectPkt;
    CellularEstCause estCause;
    int transactionId;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;
    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    assignmentRejectPkt =
        (CellularAbstractImmediateAssignmentRejectPkt *)
        MESSAGE_ReturnPacket(msg);

    estCause = assignmentRejectPkt->estCause;
    transactionId = assignmentRejectPkt->transactionId;

    //update the stats
    nwCellularAbstractMsInfo->stats.numImmediateAssignmentRejectRcvd ++;

    if ((nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId !=
                assignmentRejectPkt->bsNodeId)
        || (nwCellularAbstractMsInfo->associatedBsSectorInfo->
                associatedSectorId != assignmentRejectPkt->sectorId))
    {
        if (DEBUG_RR)
        {
            printf("at %015" TYPES_64BITFMT "d node %d NW RR: rcvd assignment "
                   "reject but different from"
                   "current associated BS or sector,"
                   "discard this assignment\n",
                   node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }

        return;
    }

    //if poweroff msg is rcvd and MS starting power off,
    // only location update is permit
    if (nwCellularAbstractMsInfo->powerOffInProgress == TRUE)
    {
        if (estCause != CELLULAR_EST_CAUSE_LOCATION_UPDATING)
        {

            return;
        }
    }

    switch(estCause)
    {
        case CELLULAR_EST_CAUSE_LOCATION_UPDATING:
        {
            if (DEBUG_RR)
            {
                printf("at %015" TYPES_64BITFMT "d node %d: CHReq for" 
                       " locUpdate is rejected\n",
                       node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
            CellularAbstractChannelRequestInfo *msChannelReqInfo;

            msChannelReqInfo =
                (CellularAbstractChannelRequestInfo *)
                nwCellularAbstractMsInfo->channelReqForLocationUpdate;

            if (msChannelReqInfo->isRequestingChannel == FALSE)
            {

                return;
            }
            if (msChannelReqInfo->channelRequestTimer != NULL)
            {
                MESSAGE_CancelSelfMsg(
                    node, msChannelReqInfo->channelRequestTimer);
                msChannelReqInfo->channelRequestTimer = NULL;
            }
            if (msChannelReqInfo->channelRequestMsg != NULL)
            {
                MESSAGE_Free(node, msChannelReqInfo->channelRequestMsg);
                msChannelReqInfo->channelRequestMsg = NULL;
            }
            //start the T3126 if not running to see if we
            //can get one of the positiove reply
            if (nwCellularAbstractMsInfo->
                channelReqForLocationUpdate->timerT3126Msg == NULL)
            {
                CellularAbstractGenericTimerInfo timerInfo;
                timerInfo.timerType = MSG_NETWORK_CELLULAR_T3126Timer;

                timerInfo.transactionId =
                    assignmentRejectPkt->transactionId;

                timerInfo.srcNodeId=assignmentRejectPkt->msNodeId;

                nwCellularAbstractMsInfo->
                    channelReqForLocationUpdate->timerT3126Msg =
                    CellularAbstractLayer3StartTimer(
                        node,
                        DefaultCellularAbstractMaxRetryTimer_T3126Time,
                        &timerInfo,
                        sizeof(CellularAbstractGenericTimerInfo));
            }
            break;
        }
        case CELLULAR_EST_CAUSE_NORMAL_CALL:
        {
            int itemIndex;
            CellularAbstractChannelRequestInfo *msChannelReqInfo;
            ERROR_Assert(
                CellularAbstractMsLookForAppInfoItem(
                    node,
                    transactionId,
                    assignmentRejectPkt->msNodeId,
                    &itemIndex) == TRUE,
                "cannot finf the appInfo for this assignmnet reject msg");

            msChannelReqInfo =
                nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication;

            if (DEBUG_RR)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d RR: Noraml call assign reject"
                    "is rcvd: itemIndex is %d\n",
                    node->getNodeTime(), node->nodeId, itemIndex);
                fflush(stdout);
            }

            if (msChannelReqInfo->isRequestingChannel == FALSE)
            {

                return;
            }
            if (msChannelReqInfo->channelRequestMsg != NULL)
            {
                MESSAGE_Free(node, msChannelReqInfo->channelRequestMsg);
                msChannelReqInfo->channelRequestMsg = NULL;
            }
            if (msChannelReqInfo->channelRequestTimer != NULL)
            {
                MESSAGE_CancelSelfMsg(
                    node, msChannelReqInfo->channelRequestTimer);
                msChannelReqInfo->channelRequestTimer = NULL;
            }

            //start the T3126 if not running to see
            //if we can get one of the positiove reply
            if (msChannelReqInfo->timerT3126Msg == NULL)
            {
                CellularAbstractGenericTimerInfo timerInfo;
                timerInfo.timerType = MSG_NETWORK_CELLULAR_T3126Timer;
                timerInfo.transactionId=assignmentRejectPkt->transactionId;
                timerInfo.srcNodeId = assignmentRejectPkt->msNodeId;

                msChannelReqInfo->timerT3126Msg =
                    CellularAbstractLayer3StartTimer(
                        node,
                        DefaultCellularAbstractMaxRetryTimer_T3126Time,
                        &timerInfo,sizeof(CellularAbstractGenericTimerInfo));
            }
            break;
        }

        case CELLULAR_EST_CAUSE_ANSWER_TO_PAGING_TCH_CHANNEL:
        {
            int itemIndex;
            CellularAbstractChannelRequestInfo *msChannelReqInfo;

            ERROR_Assert(
                CellularAbstractMsLookForAppInfoItem(
                    node,
                    transactionId,
                    assignmentRejectPkt->msNodeId,
                    &itemIndex) == TRUE,
                "cannot find the appInfo for this assignment reject msg");

            msChannelReqInfo =
                nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication;

            if (DEBUG_RR)
            {
                printf("at %015" TYPES_64BITFMT "d node %d RR answer to page : got"
                    "the assignment reject for the pageId %d",
                    node->getNodeTime(), node->nodeId,
                    msChannelReqInfo->pageRequestId);
                fflush(stdout);
            }

            if (msChannelReqInfo->isRequestingChannel == FALSE)
            {
                return;
            }
            if (msChannelReqInfo->channelRequestMsg != NULL)
            {
                MESSAGE_Free(node, msChannelReqInfo->channelRequestMsg);
                msChannelReqInfo->channelRequestMsg = NULL;
            }
            if (msChannelReqInfo->channelRequestTimer != NULL)
            {
                MESSAGE_CancelSelfMsg(
                    node,
                    msChannelReqInfo->channelRequestTimer);
                msChannelReqInfo->channelRequestTimer = NULL;
            }

            //start the T3126 if not running to see
            //if we can get one of the positiove reply
            if (msChannelReqInfo->timerT3126Msg == NULL)
            {
                CellularAbstractGenericTimerInfo timerInfo;
                timerInfo.timerType = MSG_NETWORK_CELLULAR_T3126Timer;
                timerInfo.transactionId =
                    assignmentRejectPkt->transactionId;

                timerInfo.srcNodeId = assignmentRejectPkt->msNodeId;

                msChannelReqInfo->timerT3126Msg =
                    CellularAbstractLayer3StartTimer(
                        node,
                        DefaultCellularAbstractMaxRetryTimer_T3126Time,
                        &timerInfo,
                        sizeof(CellularAbstractGenericTimerInfo));
            }
            break;
        }
        default:
        {
            printf(
                "node %d NW RR: Unknow est cause "
                "do  not send this %d cause\n",
                node->nodeId,estCause);
            MESSAGE_Free(node, msg);
            assert(FALSE);
            abort();
            break;
        }
    }

}
//*******************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleImmediateAssignmentMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Immediate assignemnt msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractMsHandleImmediateAssignmentMsg(Node *node,
                                                    Message *msg)
{
    CellularAbstractImmediateAssignmentPkt *assignmentPkt;
    CellularEstCause estCause;
    int numChannelAllocated;
    int transactionId;
    double bandwidthAllocated;
    NodeAddress srcNodeId;
    int assignmentId;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    assignmentPkt =
        (CellularAbstractImmediateAssignmentPkt *)
        MESSAGE_ReturnPacket(msg);

    estCause = assignmentPkt->estCause;
    bandwidthAllocated = assignmentPkt->bandwidthAllocated;
    numChannelAllocated = assignmentPkt->numChannelRequired;
    transactionId = assignmentPkt->transactionId;
    srcNodeId = assignmentPkt->msNodeId;
    assignmentId = assignmentPkt->assignmentId;

    //update the stats
    nwCellularAbstractMsInfo->stats.numImmediateAssignmentRcvd++;


    if (DEBUG_RR )
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW RR: process immediate assignment"
            "message casuse %d with assignId %d \n",
            node->getNodeTime(), node->nodeId,
            estCause, assignmentPkt->assignmentId);
        fflush(stdout);
    }
    if ((nwCellularAbstractMsInfo->associatedBsSectorInfo->
            associatedBSNodeId != assignmentPkt->bsNodeId)
        || (nwCellularAbstractMsInfo->associatedBsSectorInfo->
                associatedSectorId != assignmentPkt->sectorId))
    {
        if (DEBUG_RR)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d NW RR: rcvd assignment"
                "but different from current"
                "associated BS or sector, discard this assigment\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }

        return;
    }

    //if poweroff msg is rcvd and MS starting power off,
    //only location update is permit
    if (nwCellularAbstractMsInfo->powerOffInProgress == TRUE)
    {
        if (estCause != CELLULAR_EST_CAUSE_LOCATION_UPDATING)
        {

            return;
        }
    }
    //build first initial message to let bs know
    //the ms are goign to use the channels
    switch(estCause)
    {
        case CELLULAR_EST_CAUSE_LOCATION_UPDATING:
        {
            //build the location update message
            Message *locUpdatemsg;
            CellularAbstractAssociatedBsSectorInfo *associatedBsSectorInfo;
            int lac;

            associatedBsSectorInfo =
                nwCellularAbstractMsInfo->associatedBsSectorInfo;

            lac = associatedBsSectorInfo->lac;

            if (DEBUG_RR)
            {
                printf("at %015" TYPES_64BITFMT "d node %d NW RR: rcvd assignment and"
                    "ready to build location update with lac %d\n",
                    node->getNodeTime(), node->nodeId, lac);
                fflush(stdout);
            }
            //if this is a repeative assignment due to multiple CH REQ,
            //ignore it, the network side will release resource
            if (nwCellularAbstractMsInfo->channelReqForLocationUpdate->
                    isRequestingChannel == FALSE)
            {
                // free the memory used to store the allocate channel info

                return;
            }

            //update stats
            nwCellularAbstractMsInfo->stats.numChannelRequestSuccess ++;

            nwCellularAbstractMsInfo->stats.totalAccessDelay +=
                node->getNodeTime() - nwCellularAbstractMsInfo->
                channelReqForLocationUpdate->reqInitTime;

            nwCellularAbstractMsInfo->stats.avgAccessDelay =
                (double) nwCellularAbstractMsInfo->stats.totalAccessDelay  /
                (double) nwCellularAbstractMsInfo->stats.numChannelRequestSuccess;

            CellularAbstractMsBuildLocationUpdateRequestMsg(
                node,
                &locUpdatemsg,
                nwCellularAbstractMsInfo->locationUpdatingType,
                lac,
                assignmentId);

            CellularAbstractLayer3SendProtocolMsgToMac(
                node,
                locUpdatemsg,
                CELLULAR_PD_MM,
                CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_LOCATION_UPDATE_REQUEST,
                CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
                assignmentPkt->channelAllocated[0],//only one ch is used now
                CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
                CELLULAR_ABSTRACT_RECEIVER_SINGLE,

                nwCellularAbstractMsInfo->
                    associatedBsSectorInfo->associatedBSNodeId);

            //update stats
            nwCellularAbstractMsInfo->stats.numLocationUpdateSent ++;

            nwCellularAbstractMsInfo->numLocationUpdateAttempt ++;

            //cancle the channel request tiemr
            if (nwCellularAbstractMsInfo->
                channelReqForLocationUpdate->channelRequestMsg != NULL)
            {
                MESSAGE_Free(
                    node,
                    nwCellularAbstractMsInfo->
                        channelReqForLocationUpdate->channelRequestMsg);

                nwCellularAbstractMsInfo->channelReqForLocationUpdate->
                        channelRequestMsg = NULL;

                nwCellularAbstractMsInfo->channelReqForLocationUpdate->
                    isRequestingChannel = FALSE;
            }

            if (nwCellularAbstractMsInfo->
                channelReqForLocationUpdate->channelRequestTimer != NULL)
            {
                MESSAGE_CancelSelfMsg(
                    node,
                    nwCellularAbstractMsInfo->
                        channelReqForLocationUpdate->channelRequestTimer);

                nwCellularAbstractMsInfo->
                    channelReqForLocationUpdate->channelRequestTimer = NULL;
            }

            //stop the T3126 if running
            if (nwCellularAbstractMsInfo->
                channelReqForLocationUpdate->timerT3126Msg != NULL)
            {
                MESSAGE_CancelSelfMsg(
                    node,
                    nwCellularAbstractMsInfo->
                        channelReqForLocationUpdate->timerT3126Msg);

                nwCellularAbstractMsInfo->
                    channelReqForLocationUpdate->timerT3126Msg = NULL;
            }

            //start a location update timer 3210
            CellularAbstractGenericTimerInfo timerInfo;
            timerInfo.timerType = MSG_NETWORK_CELLULAR_T3210Timer;
            timerInfo.transactionId = transactionId;

            nwCellularAbstractMsInfo->timerT3210Msg =
                CellularAbstractLayer3StartTimer(
                    node,
                DefaultCellularAbstractLocationUpdateRequestTimer_T3210Time,
                    &timerInfo,
                    sizeof(CellularAbstractGenericTimerInfo));
            break;
        }
        case CELLULAR_EST_CAUSE_NORMAL_CALL:
        {

            if (DEBUG_RR)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d Node %d RR: receive the channel assignment "
                    "and ready for the call setup\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }

            //get channelreqInfo by transaction id and srcNode addr;
            //get the intemIndex in AppInfo
            int itemIndex;
            int k;
            CellularAbstractChannelRequestInfo *msChannelReqInfo;
            CellularAbstractCMServiceType cmServiceType =
                             CELLULAR_ABSTRACT_CM_SERVICE_TYPE_INVALID;
            CellularAbstractApplicationType appType;

            ERROR_Assert(
                CellularAbstractMsLookForAppInfoItem(
                    node,
                    transactionId,
                    srcNodeId,
                    &itemIndex) == TRUE,
                "cannot find the appIfo for the immediate assignment");

            msChannelReqInfo =
                nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication;

            if (DEBUG_GENERAL)
            {
                printf(
                    "node %d: itemIndex is %d\n",
                    node->nodeId,
                    itemIndex);
                fflush(stdout);
            }
            if (DEBUG_RR || DEBUG_PROGRESS)
            {
                char clockStr[MAX_STRING_LENGTH];
                ctoa(node->getNodeTime(), clockStr);
                printf(
                    "at %015" TYPES_64BITFMT "d Node %d RR: receive the channel assignment "
                    "and ready for the call setup src %d dest %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].srcMsNodeId,
                    nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].destMsNodeId);
                fflush(stdout);
            }
            if (msChannelReqInfo->isRequestingChannel == FALSE)
            {
                return;
            }

            //update stats
            nwCellularAbstractMsInfo->stats.numChannelRequestSuccess ++;

            nwCellularAbstractMsInfo->stats.totalAccessDelay +=
                node->getNodeTime() - msChannelReqInfo->reqInitTime;

            //update the stauts and information
            nwCellularAbstractMsInfo->numActiveApplicaions ++;

            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].bandwidthAllocated =
                    bandwidthAllocated;

            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].isDedicatedChannelAssigned = TRUE;

            for (k = 0;
                k < CELLULAR_ABSTRACT_MAX_CHANNEL_ALLOWED_PER_APP;
                k ++)
            {
                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].assignedDLChannelIndex[k] =
                        assignmentPkt->channelAllocated[k];

                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].assignedULChannelIndex[k] =
                        assignmentPkt->channelAllocated[k];
            }

            //give MAC a inidcation of active application start
            if ((nwCellularAbstractMsInfo->numActiveApplicaions - 1) == 0)
            {
                Message *activeAppMsg;
                activeAppMsg =
                    MESSAGE_Alloc(
                        node,
                        MAC_LAYER,
                        MAC_PROTOCOL_CELLULAR,
                        MSG_MAC_CELLULAR_FromNetworkTransactionActive);

                MESSAGE_SetInstanceId(activeAppMsg,
                                     (short)nwCellularData->interfaceIndex);

                MESSAGE_Send(node, activeAppMsg, 0);

                if (DEBUG_NET2MAC)
                {
                    printf(
                        "at %015" TYPES_64BITFMT "d node %d: notify MAC, network state from idle"
                        " to active with appplication\n",
                        node->getNodeTime(), node->nodeId);
                    fflush(stdout);
                }

                //GUI_CELLULAR
                if (node->guiOption == TRUE)
                {
                    GUI_SetNodeIcon(
                        node->nodeId,
                        "icons/MS-communicating.png",
                        node->getNodeTime());
                }
                //GUI_CELLULAR
            }

            //cancle the channel request tiemr
            if (msChannelReqInfo->channelRequestMsg != NULL)
            {
                MESSAGE_Free(node, msChannelReqInfo->channelRequestMsg);
                msChannelReqInfo->channelRequestMsg = NULL;
                msChannelReqInfo->isRequestingChannel = FALSE;
            }
            if (msChannelReqInfo->channelRequestTimer != NULL)
            {
                MESSAGE_CancelSelfMsg(
                    node, msChannelReqInfo->channelRequestTimer);

                msChannelReqInfo->channelRequestTimer = NULL;
            }
            //stop the T3126 if running
            if (msChannelReqInfo->timerT3126Msg != NULL)
            {
                MESSAGE_CancelSelfMsg(
                    node, msChannelReqInfo->timerT3126Msg);
                msChannelReqInfo->timerT3126Msg = NULL;
            }
            //start the call setup procedure by
            //sending the CM service and scheduel the timer
            appType = nwCellularAbstractMsInfo->
                        msAppInfo[itemIndex].applicationType;
            if (appType == CELLULAR_ABSTRACT_VOICE_PHONE)
            {
                cmServiceType =
                    CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL_ESTABLISHMENT;
            }
            else if (appType == CELLULAR_ABSTRACT_VIDEO_PHONE ||
                     appType == CELLULAR_ABSTRACT_TEXT_MAIL ||
                     appType == CELLULAR_ABSTRACT_PICTURE_MAIL ||
                     appType == CELLULAR_ABSTRACT_ANIMATION_MAIL ||
                     appType == CELLULAR_ABSTRACT_WEB)

            {
                cmServiceType =
                    CELLULAR_ABSTRACT_PACKET_MODE_CONNECTION_ESTABLISHMENT;
            }
            ERROR_Assert(cmServiceType !=
                         CELLULAR_ABSTRACT_CM_SERVICE_TYPE_INVALID,
                         "unknown CM serivce type");
            CellularAbstractMsSendCMServiceRequest(
                node,
                transactionId,
                srcNodeId,
                cmServiceType,
                assignmentPkt->channelAllocated[0], //only one ch is used now
                assignmentId);

            break;
        }
        case CELLULAR_EST_CAUSE_ANSWER_TO_PAGING_TCH_CHANNEL:
        {

            if (DEBUG_RR)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d RR: recv immediate ssignment"
                    "for page repsonse\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }

            int itemIndex;
            int k;
            CellularAbstractChannelRequestInfo *msChannelReqInfo;

            ERROR_Assert(
                CellularAbstractMsLookForAppInfoItem(
                    node,
                    transactionId,
                    assignmentPkt->msNodeId,
                    &itemIndex) == TRUE,
                "cannot find the appInfo for this immediate asisgnment msg");

            msChannelReqInfo =
                nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication;

            if (msChannelReqInfo->isRequestingChannel == FALSE)
            {
                return;
            }

            //update stats
            nwCellularAbstractMsInfo->stats.numChannelRequestSuccess ++;

            nwCellularAbstractMsInfo->stats.totalAccessDelay +=
                node->getNodeTime() - msChannelReqInfo->reqInitTime;

            if (DEBUG_RR )
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d: got the assignment"
                    "for the pageId %d msNodeId %d\n",
                    node->getNodeTime(), node->nodeId,
                    msChannelReqInfo->pageRequestId,
                    assignmentPkt->msNodeId);
                fflush(stdout);
            }
            nwCellularAbstractMsInfo->numActiveApplicaions ++;

            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].bandwidthAllocated =
                bandwidthAllocated;

            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].isDedicatedChannelAssigned = TRUE;
            for (k = 0;
                k < CELLULAR_ABSTRACT_MAX_CHANNEL_ALLOWED_PER_APP;
                k++)
            {
                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].assignedDLChannelIndex[k] =
                        assignmentPkt->channelAllocated[k];
                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].assignedULChannelIndex[k] =
                        assignmentPkt->channelAllocated[k];
            }

            //give MAC a inidcation of active application start
            if ((nwCellularAbstractMsInfo->numActiveApplicaions - 1) == 0)
            {
                Message *activeAppMsg;

                activeAppMsg =
                    MESSAGE_Alloc(
                        node,
                        MAC_LAYER,
                        MAC_PROTOCOL_CELLULAR,
                        MSG_MAC_CELLULAR_FromNetworkTransactionActive);

                MESSAGE_SetInstanceId(
                    activeAppMsg,
                    (short)nwCellularData->interfaceIndex);

                MESSAGE_Send(node, activeAppMsg, 0);

                if (DEBUG_NET2MAC)
                {
                    printf(
                        "at %015" TYPES_64BITFMT "d node %d: notify MAC, "
                        "network state from idle"
                        "to active with appplication\n",
                        node->getNodeTime(), node->nodeId);
                    fflush(stdout);
                }

                //GUI_CELLULAR
                if (node->guiOption == TRUE)
                {

                    GUI_SetNodeIcon(
                        node->nodeId,
                        "icons/MS-communicating.png",
                        node->getNodeTime());

                }
                //GUI_CELLULAR
            }

            //build page response with this page id
            CellularAbstractMsSendPageResponseMsg(
                node,
                transactionId,
                nwCellularAbstractMsInfo->msAppInfo[itemIndex].appId,

                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].applicationType,

                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].srcMsNodeId,

                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].destMsNodeId,

                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].callSrcDestType,

                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].bandwidthRequired,

                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].numChannelRequired,

                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].callDuration,

                msChannelReqInfo->pageRequestId,
                assignmentPkt->channelAllocated[0],
                assignmentId);

            //update the stauts and inof mation
            nwCellularAbstractMsInfo->stats.numPageResponseSent ++;

            //cancle the channel request tiemr
            if (msChannelReqInfo->channelRequestMsg != NULL)
            {
                MESSAGE_Free(
                    node,
                    msChannelReqInfo->channelRequestMsg);
                msChannelReqInfo->channelRequestMsg = NULL;
                msChannelReqInfo->isRequestingChannel = FALSE;
            }
            if (msChannelReqInfo->channelRequestTimer != NULL)
            {
                MESSAGE_CancelSelfMsg(
                    node,
                    msChannelReqInfo->channelRequestTimer);
                msChannelReqInfo->channelRequestTimer = NULL;
            }
            //stop the T3126 if running
            if (msChannelReqInfo->timerT3126Msg != NULL)
            {
                MESSAGE_CancelSelfMsg(
                    node,
                    msChannelReqInfo->timerT3126Msg);
                msChannelReqInfo->timerT3126Msg = NULL;
            }
            break;
        }
        default:
        {
            printf(
                "node %d NW RR: Unknown est cause  "
                "do not send this %d cause\n",
                node->nodeId,estCause);

            MESSAGE_Free(node, msg);
            assert(FALSE);
            abort();
            break;
        }
    }
}
//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleMTCallRejectIndication
// LAYER      :: Layer3
// PURPOSE    :: Handle MT Call Reject Indication.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractMsHandleMTCallRejectIndication(Node *node,
                                                    Message *msg)
{
    CellularAbstractMTCallRejectIndication *mtCallRejectPkt;
    Message *callRejectToAppMsg;
    CellularAbstractCallRejectMessageInfo *callRejectToAppMsgInfo;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo =
        nwCellularAbstractData->msLayer3Info;
    mtCallRejectPkt =
        (CellularAbstractMTCallRejectIndication *)
            MESSAGE_ReturnPacket(msg);

    //send the APP a msg about the failaure
    //notify the application layer, call failuare
    callRejectToAppMsg =
        MESSAGE_Alloc(
            node,
            APP_LAYER,
            APP_CELLULAR_ABSTRACT,
            MSG_APP_CELLULAR_FromNetworkCallRejected);

    MESSAGE_InfoAlloc(
        node,
        callRejectToAppMsg,
        sizeof(CellularAbstractCallRejectMessageInfo));

    callRejectToAppMsgInfo =
        (CellularAbstractCallRejectMessageInfo *)
        MESSAGE_ReturnInfo(callRejectToAppMsg);

    callRejectToAppMsgInfo->appId = mtCallRejectPkt->appId;

    callRejectToAppMsgInfo->appSrcNodeId =
        mtCallRejectPkt->appSrcNodeId;

    callRejectToAppMsgInfo->appDestNodeId =
        mtCallRejectPkt->appDestNodeId;

    callRejectToAppMsgInfo->rejectCause =
        mtCallRejectPkt->rejectCause;

    //TODO:instance other aribales
    MESSAGE_Send(node, callRejectToAppMsg, 0);

    //update stats
    nwCellularAbstractMsInfo->stats.numCallRejectSent ++;
    if (DEBUG_CAC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d: CAC send APP a "
            "reject msg due to various cause\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleLocationUpdateAcceptMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle MT Call Reject Indication.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractMsHandleLocationUpdateAcceptMsg(Node *node,
                                                     Message *msg)
{
    CellularAbstractLocationUpdateAcceptPkt *locAccpetPkt;
    //update the statistics
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d MM: Receive a location update"
            "accept msg and ready to release the channel\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo =
        nwCellularAbstractData->msLayer3Info;

    locAccpetPkt =
        (CellularAbstractLocationUpdateAcceptPkt *)
        MESSAGE_ReturnPacket(msg);

    //stop 3210 if running
    if (nwCellularAbstractMsInfo->timerT3210Msg != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractMsInfo->timerT3210Msg);
        nwCellularAbstractMsInfo->timerT3210Msg = NULL;
        if (DEBUG_MM)
        {
            printf("at %015" TYPES_64BITFMT "d node %d MM: "
                " recv update accept, stop timer 3210\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }

    nwCellularAbstractMsInfo->numLocationUpdateAttempt = 0;

    //update stats
    nwCellularAbstractMsInfo->stats.numLocationUpdateSuccess ++;

    // start 3240
    //start the T3240 if not running to wait the channel release
    if (nwCellularAbstractMsInfo->
        channelReqForLocationUpdate->timerT3240Msg == NULL)
    {
        CellularAbstractGenericTimerInfo timerInfo;
        timerInfo.timerType = MSG_NETWORK_CELLULAR_T3240Timer;
        timerInfo.transactionId = 0;
        timerInfo.srcNodeId = node->nodeId;
        nwCellularAbstractMsInfo->
          channelReqForLocationUpdate->timerT3240Msg =
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractMsChannelReleaseTimer_T3240Time,
                &timerInfo,
                sizeof(CellularAbstractGenericTimerInfo));
    }
}

//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleLocationUpdateRejectMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle  Location Update Reject Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractMsHandleLocationUpdateRejectMsg(Node *node,
                                                     Message *msg)
{
    CellularAbstractLocationUpdateRejectPkt *locRejectPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d MM: Receive a location update Reject msg"
            "and ready to release the channel\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    locRejectPkt =
       (CellularAbstractLocationUpdateRejectPkt *)MESSAGE_ReturnPacket(msg);

    //stop 3210 if running
    if (nwCellularAbstractMsInfo->timerT3210Msg != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->timerT3210Msg);
        nwCellularAbstractMsInfo->timerT3210Msg = NULL;
    }

    nwCellularAbstractMsInfo->numLocationUpdateAttempt = 0;

    //update stats
    nwCellularAbstractMsInfo->stats.numLocationUpdateRejected ++;

    ////start 3240
    //start the T3240 if not running to wait the channel release
    if (nwCellularAbstractMsInfo->
        channelReqForLocationUpdate->timerT3240Msg == NULL)
    {
        CellularAbstractGenericTimerInfo timerInfo;
        timerInfo.timerType = MSG_NETWORK_CELLULAR_T3240Timer;
        timerInfo.transactionId = 0;
        timerInfo.srcNodeId = node->nodeId;
        nwCellularAbstractMsInfo->
            channelReqForLocationUpdate->timerT3240Msg =
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractMsChannelReleaseTimer_T3240Time,
                &timerInfo,
                sizeof(CellularAbstractGenericTimerInfo));
    }
}

//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleChannelReleaseMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Channel Release Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractMsHandleChannelReleaseMsg(Node *node, Message *msg)
{
    int itemIndex;
    CellularAbstractGenericTimerInfo timerInfo;
    CellularAbstractChannelReleasePkt *chReleasePkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo =
        nwCellularAbstractData->msLayer3Info;

    if (DEBUG_RR)
    {
        printf("at %015" TYPES_64BITFMT "d node %d RR: handle channnel release msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //update stats
    nwCellularAbstractMsInfo->stats.numChannelReleaseRcvd ++;

    //start timer 3110
    chReleasePkt =
        (CellularAbstractChannelReleasePkt *) MESSAGE_ReturnPacket(msg);
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T3110Timer;
    timerInfo.transactionId = chReleasePkt->transactionId;
    timerInfo.srcNodeId = chReleasePkt->msNodeId;

    CellularAbstractLayer3StartTimer(
        node,
        DefaultCellularAbstractMsChannelReleaseTimer_T3110Time,
        &timerInfo,
        sizeof(CellularAbstractGenericTimerInfo));

    //stop 3240 if runing
    if (chReleasePkt->transactionId == 0)
    {
        if (nwCellularAbstractMsInfo->
            channelReqForLocationUpdate->timerT3240Msg != NULL)
        {
            MESSAGE_CancelSelfMsg(
                node,
                nwCellularAbstractMsInfo->
                channelReqForLocationUpdate->timerT3240Msg);

            nwCellularAbstractMsInfo->
                channelReqForLocationUpdate->timerT3240Msg = NULL;
        }
    }
    else
    {
        if (
            CellularAbstractMsLookForAppInfoItem(
                node,
                chReleasePkt->transactionId,
                chReleasePkt->msNodeId,
                &itemIndex) == FALSE)
        {
            return;
        }

        if (nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].channelRequestForApplication->
            timerT3240Msg != NULL)
        {
            MESSAGE_CancelSelfMsg(
                node,
                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].channelRequestForApplication->
                        timerT3240Msg);

            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].channelRequestForApplication->
                timerT3240Msg = NULL;
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d CC: rcvd channel release so stop"
                    "T3240 but start 3110\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }
    }
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleCMServiceAccpetMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle CM Service Accpet Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractMsHandleCMServiceAccpetMsg(Node *node,Message *msg)
{
    CellularAbstractCMServiceAcceptPkt *cmAcceptPkt;
    int itemIndex;
    int transactionId;
    int appId;
    int channelIndex;
    CellularAbstractApplicationType appType;
    NodeAddress                     appSrcNodeId;
    NodeAddress                     appDestNodeId;
    int numChannelReq;
    double bandwidthReq;
    clocktype appDuration;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_MM || DEBUG_PROGRESS)
    {
        char clockStr[MAX_STRING_LENGTH];
        ctoa(node->getNodeTime(), clockStr);
        printf(
            "at %015" TYPES_64BITFMT "d node %d MM: handle CM service accept msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    //update stats
    nwCellularAbstractMsInfo->stats.numcmServiceAcceptRcvd ++;

    //get the index in AppInfo, then get the application infomation
    cmAcceptPkt =
        (CellularAbstractCMServiceAcceptPkt *)MESSAGE_ReturnPacket(msg);

    transactionId = cmAcceptPkt->transactionId;
    appSrcNodeId = cmAcceptPkt->msNodeId;

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            appSrcNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this CM request accept msg");

    appId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].appId;

    appType =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].applicationType;

    appDestNodeId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].destMsNodeId;

    channelIndex =
        nwCellularAbstractMsInfo->
        msAppInfo[itemIndex].assignedULChannelIndex[0];

    numChannelReq =
        nwCellularAbstractMsInfo->
        msAppInfo[itemIndex].numChannelRequired;

    bandwidthReq =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].bandwidthRequired;

    appDuration =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].callDuration;

    //stop the 3230 timer
    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT3230 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT3230);

        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT3230 = NULL;
    }
    if (appType == CELLULAR_ABSTRACT_VOICE_PHONE)
    {
        CellularAbstractMsSendCallSetupMsg(
            node,
            transactionId,
            appId,
            appType,
            appSrcNodeId,
            appDestNodeId,
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
            numChannelReq,
            bandwidthReq,
            channelIndex);

        nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
            CELLULAR_ABSTRACT_MS_CC_STATE_CALL_INITIATED;

        //update stats
        nwCellularAbstractMsInfo->stats.numVoiceCallSetupInit ++;
    }
    else if (appType == CELLULAR_ABSTRACT_VIDEO_PHONE
        || appType == CELLULAR_ABSTRACT_TEXT_MAIL
        || appType == CELLULAR_ABSTRACT_PICTURE_MAIL
        || appType == CELLULAR_ABSTRACT_ANIMATION_MAIL
        || appType == CELLULAR_ABSTRACT_WEB)
    {
        //stop the timer T303
        if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303 != NULL)
        {
            MESSAGE_CancelSelfMsg(
                node,
                nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303);

            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303 = NULL;
        }
        CellularAbstractMsSendActivatePDPContextRequestMsg(
            node,
            transactionId,
            appId,
            appType,
            appSrcNodeId,
            appDestNodeId,
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
            numChannelReq,
            bandwidthReq,
            appDuration,
            channelIndex);
        //update stats
        nwCellularAbstractMsInfo->stats.numDataCallActivationSent ++;

        //TODO:session mangement state and timer T3380

    }
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleCMServiceRejectMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle CM Service Accpet Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractMsHandleCMServiceRejectMsg(Node* node, Message* msg)
{
    CellularAbstractCMServiceRejectPkt *cmServiceRejectPkt;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    int transactionId;
    int itemIndex;
    CellularAbstractCallRejectCauseType rejectCause;
    Message* callRejectToAppMsg;
    CellularAbstractCallRejectMessageInfo* callRejectToAppMsgInfo;
    CellularAbstractGenericTimerInfo timerInfo;


    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_MM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d MM: rcvd CM service reject msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    //update stat
    nwCellularAbstractMsInfo->stats.numCmServiceRejectRdvd ++;

    //get the index in AppInfo
    cmServiceRejectPkt =
        (CellularAbstractCMServiceRejectPkt *)MESSAGE_ReturnPacket(msg);

    transactionId = cmServiceRejectPkt->transactionId;
    appSrcNodeId = cmServiceRejectPkt->msNodeId;
    rejectCause = cmServiceRejectPkt->rejectCause;

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            appSrcNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for the CM serive reject msg");

    //get the appIfo
    appId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].appId;

    appDestNodeId =
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].destBsNodeId;


    //stop the 3230 timer
    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT3230 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT3230);

        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT3230 = NULL;
    }

    //stop the timer T303
    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303);

        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303 = NULL;
    }

    //start imer 3240
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T3240Timer;
    timerInfo.transactionId = transactionId;
    timerInfo.srcNodeId = node->nodeId;
    nwCellularAbstractMsInfo->
        msAppInfo[itemIndex].channelRequestForApplication->timerT3240Msg =
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractMsChannelReleaseTimer_T3240Time,
                &timerInfo,
                sizeof(CellularAbstractGenericTimerInfo));


    //send the APP a msg about the failaure
    //notify the application layer, call failuare
    callRejectToAppMsg =
        MESSAGE_Alloc(
            node,
            APP_LAYER,
            APP_CELLULAR_ABSTRACT,
            MSG_APP_CELLULAR_FromNetworkCallRejected);

    MESSAGE_InfoAlloc(
        node,
        callRejectToAppMsg,
        sizeof(CellularAbstractCallRejectMessageInfo));

    callRejectToAppMsgInfo =
        (CellularAbstractCallRejectMessageInfo *)
        MESSAGE_ReturnInfo(callRejectToAppMsg);

    callRejectToAppMsgInfo->appId = appId;

    callRejectToAppMsgInfo->appSrcNodeId = appSrcNodeId;

    callRejectToAppMsgInfo->appDestNodeId = appDestNodeId;

    callRejectToAppMsgInfo->rejectCause = rejectCause;

    //send to app layer
    MESSAGE_Send(node, callRejectToAppMsg, 0);

    //update stats
    nwCellularAbstractMsInfo->stats.numCallRejectSent ++;

    if (DEBUG_NET2APP)
    {
        printf("at %015" TYPES_64BITFMT "d node %d: send APP a "
            "reject msg due to various cause\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleCallProceedingMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Call Proceeding Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractMsHandleCallProceedingMsg(Node *node,
                                               Message *msg)
{
    CellularAbstractCallProceedingPkt *callProcPkt;
    int transactionId;
    int appSrcNodeId;
    int itemIndex;
    CellularAbstractGenericTimerInfo timerInfo;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d MS node %d CC: rcvd call proceeding\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    callProcPkt =
        (CellularAbstractCallProceedingPkt *)MESSAGE_ReturnPacket(msg);

    //get the itemIndex
    transactionId = callProcPkt->transactionId;
    appSrcNodeId = callProcPkt->appSrcNodeId;

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            appSrcNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this call proceeding msg");

    //stop the timer T303
    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303);
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303 = NULL;
    }

    //TODO:start T310
    timerInfo.srcNodeId = node->nodeId;
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T310Timer;
    timerInfo.transactionId = transactionId;
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT310 =
        CellularAbstractLayer3StartTimer(
            node,
            DefaultCellularAbstractCallControl_T310Time,
            &timerInfo,
            sizeof(CellularAbstractGenericTimerInfo));

    //update the stat
    nwCellularAbstractMsInfo->stats.numMOCallProceedingRcvd ++;
    ///update the ms CC state
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_MOBILE_ORIG_CALL_PROCEEDING;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d MS node %d CC: rcvd call proceeding, "
            "stop t303 and start 310 , "
            "update cc state for trans %d\n",
            node->getNodeTime(),
            node->nodeId,
            transactionId);
        fflush(stdout);
    }
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandlePageRequest
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Page Request Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractMsHandlePageRequest(Node *node, Message *msg)
{
    CellularAbstractPageRequestPkt *pageReqPkt;
    int itemIndex;
    int appId;
    CellularAbstractApplicationType appType;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    double bandwidthRequired;
    int numChannelRequired;
    clocktype appDuration;
    CellularAbstractCallSrcDestType callSrcDestType;

    CellularAbstractChannelRequestInfo *chReqInfo;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR: rcvd page request\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    pageReqPkt=(CellularAbstractPageRequestPkt *)MESSAGE_ReturnPacket(msg);

    //in case MS is in the process of power  off
    if (nwCellularAbstractMsInfo->powerOffInProgress == TRUE)
    {
        return;
    }
    //in case node select new cell
    if (pageReqPkt->bsNodeId !=
       nwCellularAbstractMsInfo->associatedBsSectorInfo->associatedBSNodeId)
    {
        return;
    }
    else
    {
        //to eliminate the pageReq from different BS for the same application
        //Cause: when multiple BS page the same MS for the same APP
        //if MS has already build up a AppInfo item for this app
        //in old BS and move to current BS and the current
        //BS is paging for the same app.
        int i;
        BOOL found = FALSE;
        for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS; i ++)
        {
                if (nwCellularAbstractMsInfo->msAppInfo[i].inUse ==
                        TRUE &&
                    nwCellularAbstractMsInfo->msAppInfo[i].appId ==
                        pageReqPkt->appId &&
                    nwCellularAbstractMsInfo->msAppInfo[i].srcMsNodeId ==
                        pageReqPkt->appSrcNodeId &&
                    nwCellularAbstractMsInfo->msAppInfo[i].destMsNodeId ==
                        pageReqPkt->appDestNodeId)
                {
                    found = TRUE;
                    break;
                }
        }
        //if already create a appInfo then do nothing about it
        if (found == TRUE)
        {
            return;
        }

    }

    // make sure not too many active transactions on going
    // including active applications and applications
    // requesting channel
    //look for the first unused item
    int j;
    BOOL foundUnused = FALSE;
    for (j = 0; j < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS; j ++)
    {
        if (nwCellularAbstractMsInfo->msAppInfo[j].inUse == FALSE)
        {
            foundUnused = TRUE;
            break;
        }
    }
    //too many active application?this one should move to application layer
    if (nwCellularAbstractMsInfo->numActiveApplicaions >=
        CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS ||
        foundUnused == FALSE)
    {
        return;
    }

    if (nwCellularAbstractMsInfo->handoverState ==
        CELLULAR_ABSTRACT_HANDOVER_STATE_PROCEEDING)
    {
        return;
    }
    //update stas
    nwCellularAbstractMsInfo->stats.numPageRequestRcvd ++;

    //update the transactionId;
    nwCellularAbstractMsInfo->numTransactions ++;

    appId = pageReqPkt->appId;
    appType = pageReqPkt->appType;
    appSrcNodeId = pageReqPkt->appSrcNodeId;
    appDestNodeId = pageReqPkt->appDestNodeId;
    bandwidthRequired = pageReqPkt->bandwidthRequired;
    numChannelRequired = pageReqPkt->numChannelRequired;
    appDuration = pageReqPkt->appDuration;
    callSrcDestType = pageReqPkt->callSrcDestType;
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR: process the page req for"
            "appId %d from src %d to dest %d with bandwidth %f\n",
            node->getNodeTime(),
            node->nodeId,
            appId,
            appSrcNodeId,
            appDestNodeId,
            bandwidthRequired);
        fflush(stdout);
    }

    //create a item for this transaction
    CellularAbstractMsCreateAppInfoItem(
        node,
        nwCellularAbstractMsInfo->numTransactions,
        appId,
        appType,
        appSrcNodeId,
        appDestNodeId,
        numChannelRequired,
        bandwidthRequired,
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
        &itemIndex);

    nwCellularAbstractMsInfo->msAppInfo[itemIndex].callDuration =
        appDuration;

    //call prepare channel request
    chReqInfo =
        nwCellularAbstractMsInfo->
        msAppInfo[itemIndex].channelRequestForApplication;

    chReqInfo->pageRequestId = pageReqPkt->pageRequestId;

    //inita the cc state
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_NULL;

    CellularAbstractMsPrepareChannelRequest(
        node,
        chReqInfo,
        CELLULAR_EST_CAUSE_ANSWER_TO_PAGING_TCH_CHANNEL,
        numChannelRequired,
        bandwidthRequired,
        CELLULAR_ABSTRACT_CHANNEL_REQUEST_GENERAL,
        nwCellularAbstractMsInfo->numTransactions,
        pageReqPkt->pageRequestId);

    if (DEBUG_RR || DEBUG_PROGRESS)
    {
        char clockStr[MAX_STRING_LENGTH];
        ctoa(node->getNodeTime(), clockStr);
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR: preparing the channel"
            "request forpage response pageId %d"
            "the app %d (src %d dest %d) with local transaction id %d\n",
            node->getNodeTime(),
            node->nodeId,
            pageReqPkt->pageRequestId,
            appId,
            appSrcNodeId,
            appDestNodeId,
            nwCellularAbstractMsInfo->numTransactions
            );
        fflush(stdout);
    }
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleCallSetupMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Call Setup Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractMsHandleCallSetupMsg(Node *node, Message *msg)
{
    int transactionId;
    int                             appId;
    NodeAddress                     appSrcNodeId;
    NodeAddress                     appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;

    int itemIndex;
    CellularAbstractCallSetupPkt *callSetupPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    callSetupPkt =
        (CellularAbstractCallSetupPkt *)MESSAGE_ReturnPacket(msg);

    transactionId = callSetupPkt->transactionId;
    appId = callSetupPkt->appId;
    appSrcNodeId = callSetupPkt->appSrcNodeId;
    appDestNodeId = callSetupPkt->appDestNodeId;
    callSrcDestType = callSetupPkt->callSrcDestType;

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this call setup msg");
        //only dest ms come to here

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d rcvd call setup src %d dest %d\n",
            node->getNodeTime(),
            node->nodeId,
            callSetupPkt->appSrcNodeId,
            callSetupPkt->appDestNodeId);
        fflush(stdout);
    }

    //update stats
    nwCellularAbstractMsInfo->stats.numMTCallSetupRcvd ++;
    nwCellularAbstractMsInfo->stats.numVoiceCallSetupRcvd ++;

    //change the call control state to present
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_CALL_PRESENT;

    CellularAbstractMsSendCallConfirmMsg(
        node,
        transactionId,
        appId,
        callSrcDestType,
        appSrcNodeId,
        0,
        appDestNodeId,
        0);//TODO: the bs should be intsanced

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d MS node %d CC:MT call setup RCVD,"
            "change state from null to presnt\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    CellularAbstractMsSendCallAlertingMsg(
        node,
        transactionId,
        appId,
        callSrcDestType,
        appSrcNodeId,
        0,
        appDestNodeId,
        0);//TODO: the bs should be intsanced

    //notify the application a call is arrive
    CellularAbstractMsSendAppCallArriveMsg(
        node,
        appId,
        transactionId);
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleCallAlertingMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Call Alerting Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractMsHandleCallAlertingMsg(Node *node, Message *msg)
{
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;

    CellularAbstractCallAlertingPkt *callAlertingPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo =
        nwCellularAbstractData->msLayer3Info;

    callAlertingPkt =
        (CellularAbstractCallAlertingPkt *)MESSAGE_ReturnPacket(msg);

    transactionId = callAlertingPkt->transactionId;
    appId = callAlertingPkt->appId;
    appSrcNodeId = callAlertingPkt->appSrcNodeId;
    appDestNodeId = callAlertingPkt->appDestNodeId;
    callSrcDestType = callAlertingPkt->callSrcDestType;

    ERROR_Assert(
        callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
        "Only MO MS should RCVD call Alerting");

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this call alerting msg");

        //only src ms come to here

    //stop T310 and 303
    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT310 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].timerT310);

        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT310 = NULL;
    }
    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303);
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303 = NULL;
    }

    //change the ms cc state
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_CALL_DELIVERED;

    //update the stats
    nwCellularAbstractMsInfo->stats.numMOCallAlertingRcvd ++;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d MS node %d CC:RCVD MO Call Alerting,"
            "stop T310 and T303 if running\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
}
//********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleCallConnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Call Connect Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//********************************************************************
static
void CellularAbstractMsHandleCallConnectMsg(Node *node, Message *msg)
{
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress srcBsNodeId;
    NodeAddress appDestNodeId;

    CellularAbstractCallSrcDestType callSrcDestType;

    CellularAbstractCallConnectPkt *callConnectPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo =
        nwCellularAbstractData->msLayer3Info;

    callConnectPkt =
        (CellularAbstractCallConnectPkt *)MESSAGE_ReturnPacket(msg);

    transactionId = callConnectPkt->transactionId;
    appId = callConnectPkt->appId;
    appSrcNodeId = callConnectPkt->appSrcNodeId;

    srcBsNodeId =
        nwCellularAbstractMsInfo->
        associatedBsSectorInfo->associatedBSNodeId;

    appDestNodeId = callConnectPkt->appDestNodeId;
    callSrcDestType = callConnectPkt->callSrcDestType;

    ERROR_Assert(
        callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
        "Only MO MS should RCVD call coonet");

    //update the stats
    nwCellularAbstractMsInfo->stats.numMOCallConnectRcvd ++;

    //send connect ack and change ms cc state to active
    CellularAbstractMsSendConnectAckMsg(
        node, transactionId, appId, callSrcDestType,
        appSrcNodeId, srcBsNodeId, appDestNodeId, 0);//src ms use this

    //update the Cc state
    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this call connect msg");

    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_ACTIVE;

    //stop T310 and 303
    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT310 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT310);
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT310 = NULL;
    }

    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303);
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT303 = NULL;
    }
    //notify application layer the call is accpeted
    CellularAbstractMsSendAppCallAcceptMsg(
        node, appId, transactionId);
    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d CC:RCVD MO Call connect\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
}

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleRequestPDPContextActivationMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Request PDP Context Activation Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractMsHandleRequestPDPContextActivationMsg(Node *node,
                                                            Message *msg)
{
    CellularAbstractRequestPDPContextActivationPkt *reqPDPAcivationPkt;
    int itemIndex;
    int transactionId;
    int appId;

    CellularAbstractApplicationType appType;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;
    int numChannelReq;
    double bandwidthReq;
    clocktype appDuration;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    reqPDPAcivationPkt =
        (CellularAbstractRequestPDPContextActivationPkt *)
        MESSAGE_ReturnPacket(msg);

    transactionId = reqPDPAcivationPkt->transactionId;
    appId = reqPDPAcivationPkt->appId;
    appType = reqPDPAcivationPkt->appType;
    appSrcNodeId = reqPDPAcivationPkt->appSrcNodeId;
    appDestNodeId = reqPDPAcivationPkt->appDestNodeId;
    callSrcDestType = reqPDPAcivationPkt->callSrcDestType;
    numChannelReq = reqPDPAcivationPkt->numChannelRequired;
    bandwidthReq = reqPDPAcivationPkt->bandwidthRequired;
    appDuration = reqPDPAcivationPkt->appDuration;

    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %dSM MsHandleRequestPDPContextActivationMsg:"
            "traId %d,src %d,dest %d,appId %d\n",
            node->getNodeTime(), node->nodeId,
            transactionId, appSrcNodeId, appDestNodeId, appId);
        fflush(stdout);
    }

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            appDestNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this req PDP activation msg");

    //update stats
    nwCellularAbstractMsInfo->stats.numDataCallActivationRcvd ++;

    //send activatiePDP request
    CellularAbstractMsSendActivatePDPContextRequestMsg(
        node,
        transactionId,
        appId,
        appType,
        appSrcNodeId,
        appDestNodeId,
        callSrcDestType,
        numChannelReq,
        bandwidthReq,
        appDuration,
        nwCellularAbstractMsInfo->
            msAppInfo[itemIndex].assignedULChannelIndex[0]);

    //TODO:session mangement state and timer T3380
    if (DEBUG_SM)
    {
        printf("at %015" TYPES_64BITFMT "d MS node %d SM: handle Request "
            "PDP Context Activation msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleActivatePDPContextAcceptMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Activate PDP Context Accept Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractMsHandleActivatePDPContextAcceptMsg(Node *node,
                                                         Message *msg)
{
    int                             itemIndex;
    int                             transactionId;
    int                             appId;
    NodeAddress                     appSrcNodeId;
    NodeAddress                     srcBsNodeId;
    NodeAddress                     appDestNodeId;

    CellularAbstractCallSrcDestType callSrcDestType;

    CellularAbstractActivatePDPContextAcceptPkt *APCAcceptPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    APCAcceptPkt =
        (CellularAbstractActivatePDPContextAcceptPkt *)
        MESSAGE_ReturnPacket(msg);

    transactionId = APCAcceptPkt->transactionId;
    appId = APCAcceptPkt->appId;
    appSrcNodeId = APCAcceptPkt->appSrcNodeId;
    srcBsNodeId =
        nwCellularAbstractMsInfo->
        associatedBsSectorInfo->associatedBSNodeId;

    appDestNodeId = APCAcceptPkt->appDestNodeId;
    callSrcDestType = APCAcceptPkt->callSrcDestType;

    //update the Cc state
    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this Activation PDP accept msg");

    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_ACTIVE;

    //stop T3380 TODO

    //notify application layer the call is accpeted
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        CellularAbstractMsSendAppCallAcceptMsg(node, appId, transactionId);
    }
    else if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        //notify the application a call is arrive
        CellularAbstractMsSendAppCallArriveMsg(
            node,
            appId,
            transactionId);
    }
    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d MS node %d SM:RCVD actuvate PDP conetx"
            "accpet msg with type %d\n",
            node->getNodeTime(), node->nodeId,callSrcDestType);
        fflush(stdout);
    }
}

//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleDeactivatePDPContextAcceptMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Dectivate PDP Context Accept Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractMsHandleDeactivatePDPContextAcceptMsg(Node *node,
                                                           Message *msg)
{
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;

    NodeAddress appDestNodeId;

    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractGenericTimerInfo timerInfo;

    CellularAbstractDeactivatePDPContextAcceptPkt *DPCAcceptPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    DPCAcceptPkt =
        (CellularAbstractDeactivatePDPContextAcceptPkt *)
        MESSAGE_ReturnPacket(msg);

    transactionId = DPCAcceptPkt->transactionId;
    appId = DPCAcceptPkt->appId;
    appSrcNodeId = DPCAcceptPkt->appSrcNodeId;
    appDestNodeId = DPCAcceptPkt->appDestNodeId;
    callSrcDestType = DPCAcceptPkt->callSrcDestType;

    //update the stats TODO

    //update the Cc state
    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this Deactivation PDP accpet msg");

    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_NULL;

    //TODO stop SM control timer

    //start imer 3240
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T3240Timer;
    timerInfo.transactionId = transactionId;
    timerInfo.srcNodeId = node->nodeId;
    nwCellularAbstractMsInfo->
        msAppInfo[itemIndex].channelRequestForApplication->timerT3240Msg =
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractMsChannelReleaseTimer_T3240Time,
                &timerInfo,
                sizeof(CellularAbstractGenericTimerInfo));

    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d MS node %d SM:RCVD deactivate PDP conetx accpet"
            "msg with callsrcdesttype and start time 3240%d\n",
            node->getNodeTime(), node->nodeId,callSrcDestType);
        fflush(stdout);
    }
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleDeactivatePDPContextRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Deactivate PDP Context Request Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractMsHandleDeactivatePDPContextRequestMsg(Node *node,
                                                            Message *msg)
{
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;

    NodeAddress appDestNodeId;

    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractGenericTimerInfo timerInfo;
    CellularAbstractCallDisconectCauseType callDiscCause;

    CellularAbstractDeactivatePDPContextRequestPkt *DPCReqPkt;
    CellularAbstractDeactivatePDPContextAcceptPkt *DPCAcceptPkt;
    Message *DPCAcceptMsg;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;
    DPCReqPkt =
        (CellularAbstractDeactivatePDPContextRequestPkt *)
        MESSAGE_ReturnPacket(msg);


    if (nwCellularAbstractMsInfo->handoverState ==
        CELLULAR_ABSTRACT_HANDOVER_STATE_PROCEEDING)
    {
        Message *pdpDeactivateReqCopy;
        CellularAbstractLayer3BuildMessage(
            node,
            &pdpDeactivateReqCopy,
            NETWORK_LAYER,
            NETWORK_PROTOCOL_CELLULAR,
            MSG_NETWORK_CELLULAR_PollHandoverForCallManagement,
            DPCReqPkt,
            sizeof(CellularAbstractDeactivatePDPContextRequestPkt));

        CellularAbstractAddLayer3MsgHeader(
            node,
            &pdpDeactivateReqCopy,
            CELLULAR_PD_SM,
            CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_REQUEST);

        MESSAGE_Send(
            node,
            pdpDeactivateReqCopy,
            CELLULAR_ABSTRACT_HANDOVER_END_POLLING_INTERVAL);

        if (DEBUG_HANDOVER)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d HO--handover is ongoing,"
                "disc src %d dest %d need to wait...\n",
                node->getNodeTime(), node->nodeId,
                DPCReqPkt->appSrcNodeId,
                DPCReqPkt->appDestNodeId);
            fflush(stdout);
        }
        return;
    }


    transactionId = DPCReqPkt->transactionId;
    appId = DPCReqPkt->appId;
    appSrcNodeId = DPCReqPkt->appSrcNodeId;
    appDestNodeId = DPCReqPkt->appDestNodeId;
    callSrcDestType = DPCReqPkt->callSrcDestType;
    callDiscCause = DPCReqPkt->callDiscCause;
    //update the stats TODO
    //update the Cc state
    if (CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == FALSE)
    {
        if (DEBUG_SM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d: cannot find "
                "the appInfo for this Deactivate PDP"
                "request msg for call src %d dest %d srcdest type %d,"
                "may be due to handover failuare\n",
                node->getNodeTime(),
                node->nodeId,
                appSrcNodeId,
                appDestNodeId,
                callSrcDestType);
            fflush(stdout);
        }
        return;
    }
    //send app layer a msg
    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
        CELLULAR_ABSTRACT_MS_CC_STATE_ACTIVE)
    {
        if (callDiscCause == CELLULAR_ABSTRACT_CALL_DISCONNECT_NORMAL)
        {
            CellularAbstractMsSendAppCallEndByRemote(
                node,
                appId,
                appSrcNodeId,
                appDestNodeId);
        }
        else if (callDiscCause ==
            CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_HANDOVER)
        {
            CellularAbstractMsSendAppCallDroppedMsg(
                node,
                appId,
                appSrcNodeId,
                appDestNodeId,
                CELLULAR_ABSTRACT_CALL_DROP_CAUSE_HANDOVER_FAILURE);
        }
        else if (callDiscCause ==
            CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_POWEROFF)
        {
            CellularAbstractMsSendAppCallDroppedMsg(
                node,
                appId,
                appSrcNodeId,
                appDestNodeId,
                CELLULAR_ABSTRACT_CALL_DROP_CAUSE_REMOTEUSER_POWEROFF);
        }
    }

    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
        CELLULAR_ABSTRACT_MS_CC_STATE_NULL)
    {
        if (DEBUG_SM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d MS node %d SM:RCVD deactivate PDP conetx req"
                "msg for type %d and is already in deactivation process\n",
                node->getNodeTime(),
                node->nodeId,
                callSrcDestType);
            fflush(stdout);
        }

        return;
    }
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_NULL;

    //send deactivate PDP context accept
    DPCAcceptPkt =
        (CellularAbstractDeactivatePDPContextAcceptPkt *)
        MEM_malloc(sizeof(CellularAbstractDeactivatePDPContextAcceptPkt));

    DPCAcceptPkt->appId = appId;
    DPCAcceptPkt->appDestNodeId = appDestNodeId;
    DPCAcceptPkt->appSrcNodeId = appSrcNodeId;
    DPCAcceptPkt->callSrcDestType = callSrcDestType;
    DPCAcceptPkt->transactionId = transactionId;

    CellularAbstractLayer3BuildMessage(
        node,
        &DPCAcceptMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        DPCAcceptPkt,
        sizeof(CellularAbstractDeactivatePDPContextAcceptPkt));

    //update stats TODO

    //send the setup msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        DPCAcceptMsg,
        CELLULAR_PD_SM,//protocl discritptor
        CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_ACCEPT,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,//interlayer info type

        nwCellularAbstractMsInfo->
        msAppInfo[itemIndex].assignedULChannelIndex[0],

        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only assocatiated BS

        nwCellularAbstractMsInfo->
        associatedBsSectorInfo->associatedBSNodeId);

    MEM_free(DPCAcceptPkt);

    //TODO stop SM control timer
    //start imer 3240
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T3240Timer;
    timerInfo.transactionId = transactionId;
    timerInfo.srcNodeId = node->nodeId;
    nwCellularAbstractMsInfo->
        msAppInfo[itemIndex].channelRequestForApplication->timerT3240Msg =
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractMsChannelReleaseTimer_T3240Time,
                &timerInfo,sizeof(CellularAbstractGenericTimerInfo));

    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d MS node %d SM:RCVD deactivate PDP conetx request"
            "msg and sent accept to NW with type %d start 3240\n",
            node->getNodeTime(),
            node->nodeId,
            callSrcDestType);
        fflush(stdout);
    }
}

//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleCallConnectAckMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Call Connect Ack Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractMsHandleCallConnectAckMsg(Node *node, Message *msg)
{
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;

    CellularAbstractCallConnectAckPkt *callConnectAckPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    callConnectAckPkt =
        (CellularAbstractCallConnectAckPkt *)MESSAGE_ReturnPacket(msg);
    appId = callConnectAckPkt->appId;
    appSrcNodeId = callConnectAckPkt->appSrcNodeId;
    appDestNodeId = callConnectAckPkt->appDestNodeId;
    transactionId = callConnectAckPkt->transactionId;

    callSrcDestType = callConnectAckPkt->callSrcDestType;

    ERROR_Assert(
        callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
        "Only MT call MS should RCVD call coonet ack");

    ERROR_Assert(
        node->nodeId == appDestNodeId,
        "Only MT call's MS should RCVD call coonet ack 2");

    ERROR_Assert(
        CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this call connect ack msg");

        //only dest ms come to here

    //update the stats
    nwCellularAbstractMsInfo->stats.numMTCallConnectAckRcvd ++;

    //stop T313
    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT313 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT313);
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT313 = NULL;
    }

    //change the ms cc state
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_ACTIVE;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d CC:RCVD MT Call connect ACK\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
}

//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleCallDisconnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Call Disconnect Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractMsHandleCallDisconnectMsg(Node *node, Message *msg)
{
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractTimer308Info timerInfo;

    CellularAbstractCallDisconnectPkt *callDisconnectPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    callDisconnectPkt =
        (CellularAbstractCallDisconnectPkt *)MESSAGE_ReturnPacket(msg);

    appId = callDisconnectPkt->appId;
    appSrcNodeId = callDisconnectPkt->appSrcNodeId;
    appDestNodeId = callDisconnectPkt->appDestNodeId;
    transactionId = callDisconnectPkt->transactionId;
    callSrcDestType = callDisconnectPkt->callSrcDestType;

    //if for soem reason the app has been reset due to handover failuare?
    if (CellularAbstractMsLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == FALSE)
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d cannot find the appInfo for"
                " call src %d dest %d, could be"
                "reset by handover failuare\n",
                node->getNodeTime(),
                node->nodeId,
                appSrcNodeId,
                appDestNodeId);
            fflush(stdout);
        }
        return;
    }

    if (nwCellularAbstractMsInfo->handoverState ==
        CELLULAR_ABSTRACT_HANDOVER_STATE_PROCEEDING)
    {
        Message *callDiscMsgCopy;

        CellularAbstractLayer3BuildMessage(
            node,
            &callDiscMsgCopy,
            NETWORK_LAYER,
            NETWORK_PROTOCOL_CELLULAR,
            MSG_NETWORK_CELLULAR_PollHandoverForCallManagement,
            callDisconnectPkt,
            sizeof(CellularAbstractCallDisconnectPkt));

        CellularAbstractAddLayer3MsgHeader(
            node,
            &callDiscMsgCopy,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_DISCONNECT);

        MESSAGE_Send(
            node,
            callDiscMsgCopy,
            CELLULAR_ABSTRACT_HANDOVER_END_POLLING_INTERVAL);

        if (DEBUG_HANDOVER)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d HO--handover is ongoing,"
                "disc src %d dest %d need to wait...\n",
                node->getNodeTime(), node->nodeId,
                appSrcNodeId, appDestNodeId);
            fflush(stdout);
        }
        return;
    }
    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
        CELLULAR_ABSTRACT_MS_CC_STATE_NULL
        || nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
           CELLULAR_ABSTRACT_MS_CC_STATE_DISCONNECT_INDICATION
        || nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
           CELLULAR_ABSTRACT_MS_CC_STATE_RELEASE_REQUEST)
    {
        return;
    }
    else if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
        CELLULAR_ABSTRACT_MS_CC_STATE_MOBILE_ORIG_CALL_PROCEEDING
        || nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
           CELLULAR_ABSTRACT_MS_CC_STATE_CALL_DELIVERED
        || nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
           CELLULAR_ABSTRACT_MS_CC_STATE_CALL_PRESENT
        || nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
           CELLULAR_ABSTRACT_MS_CC_STATE_CALL_RECEIVED
        || nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
           CELLULAR_ABSTRACT_MS_CC_STATE_CONNECT_REQUEST
        || nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
           CELLULAR_ABSTRACT_MS_CC_STATE_MOBILE_TERM_CALL_CONFIRMED
        || nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
           CELLULAR_ABSTRACT_MS_CC_STATE_ACTIVE)
    {
        if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
            CELLULAR_ABSTRACT_MS_CC_STATE_ACTIVE)
        {

            //notify the application layer
            if (callDisconnectPkt->callDiscCause ==
                CELLULAR_ABSTRACT_CALL_DISCONNECT_NORMAL)
            {
                CellularAbstractMsSendAppCallEndByRemote(
                    node, appId, appSrcNodeId, appDestNodeId);
            }
            else if (callDisconnectPkt->callDiscCause ==
                CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_HANDOVER)
            {
                CellularAbstractMsSendAppCallDroppedMsg(
                    node,
                    appId,
                    appSrcNodeId,
                    appDestNodeId,
                    CELLULAR_ABSTRACT_CALL_DROP_CAUSE_HANDOVER_FAILURE);
            }
            else if (callDisconnectPkt->callDiscCause ==
                CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_POWEROFF)
            {
                CellularAbstractMsSendAppCallDroppedMsg(
                    node,
                    appId,
                    appSrcNodeId,
                    appDestNodeId,
                    CELLULAR_ABSTRACT_CALL_DROP_CAUSE_REMOTEUSER_POWEROFF);
            }
        }

        nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
            CELLULAR_ABSTRACT_MS_CC_STATE_DISCONNECT_INDICATION;

        //stop all running control timer
        CellularAbstractMsStopCallControlTimer(node, itemIndex);

        //send release msg to network side
        CellularAbstractMsSendCallReleaseMsg(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            CELLULAR_ABSTRACT_CALL_RELEASE_BY_MS);

        //start timer T308
        timerInfo.srcNodeId = node->nodeId;
        timerInfo.timerType = MSG_NETWORK_CELLULAR_T308Timer;
        timerInfo.transactionId = transactionId;
        timerInfo.numExpiration = 0;

        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT308 =
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractCallControl_T308Time,
                &timerInfo,
                sizeof(CellularAbstractTimer308Info));

        //change state to release request
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
            CELLULAR_ABSTRACT_MS_CC_STATE_RELEASE_REQUEST;
    }
    else if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
                CELLULAR_ABSTRACT_MS_CC_STATE_DISCONNECT_REQUEST)
    {
        //stop all running control timer
        CellularAbstractMsStopCallControlTimer(node, itemIndex);

        //send release msg to network side
        CellularAbstractMsSendCallReleaseMsg(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            CELLULAR_ABSTRACT_CALL_RELEASE_BY_MS);

        //start timer T308
        timerInfo.srcNodeId = node->nodeId;
        timerInfo.timerType = MSG_NETWORK_CELLULAR_T308Timer;
        timerInfo.transactionId = transactionId;
        timerInfo.numExpiration = 0;
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].timerT308 =
        CellularAbstractLayer3StartTimer(
            node, DefaultCellularAbstractCallControl_T308Time,
            &timerInfo, sizeof(CellularAbstractTimer308Info));

        //change state to release request
        nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
            CELLULAR_ABSTRACT_MS_CC_STATE_RELEASE_REQUEST;
    }
}
//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleCallReleaseMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Call Release Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractMsHandleCallReleaseMsg(Node *node, Message *msg)
{
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractCallReleaseType callReleaseType;
    CellularAbstractGenericTimerInfo timerInfo;

    CellularAbstractCallReleasePkt *callReleasePkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    callReleasePkt =
        (CellularAbstractCallReleasePkt *)MESSAGE_ReturnPacket(msg);

    appId = callReleasePkt->appId;
    appSrcNodeId = callReleasePkt->appSrcNodeId;
    appDestNodeId = callReleasePkt->appDestNodeId;
    transactionId = callReleasePkt->transactionId;
    callSrcDestType = callReleasePkt->callSrcDestType;
    callReleaseType = callReleasePkt->callReleaseType;

    if (
        CellularAbstractMsLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            &itemIndex,
            &transactionId) == FALSE)
    {
        // already release, do nothing
        return;

    }

    if (nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
        CELLULAR_ABSTRACT_MS_CC_STATE_NULL
        || nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState ==
           CELLULAR_ABSTRACT_MS_CC_STATE_RELEASE_REQUEST)
    {
        return;
    }

    //stop all the call control timer
    CellularAbstractMsStopCallControlTimer(node, itemIndex);

    //send call complete CellularAbstractCallReleaseCompletePkt
    CellularAbstractMsSendCallReleaseCompleteMsg(
        node, appId, transactionId,
        appSrcNodeId, appDestNodeId, callSrcDestType,
        CELLULAR_ABSTRACT_CALL_RELEASE_COMPLETE_BY_MS);

    //cc state to null
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_NULL;

    //TODO release MM connection

    //update stat
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        nwCellularAbstractMsInfo->stats.numMOCallReleaseByNwRcvd ++;
    }
    else if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        nwCellularAbstractMsInfo->stats.numMTCallReleaseByNwRcvd ++;
    }

    //start 3240 wait for channel release msg from network
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T3240Timer;
    timerInfo.transactionId = transactionId;
    timerInfo.srcNodeId = node->nodeId;

    nwCellularAbstractMsInfo->
        msAppInfo[itemIndex].channelRequestForApplication->timerT3240Msg =
        CellularAbstractLayer3StartTimer(
            node,
            DefaultCellularAbstractMsChannelReleaseTimer_T3240Time,
            &timerInfo,
            sizeof(CellularAbstractGenericTimerInfo));

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d:Rcvd  a call release "
            "and send call release complete and"
            "start T3240 waiting for channel release\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleCallReleaseCompleteMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Call Release Complete Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractMsHandleCallReleaseCompleteMsg(Node *node,
                                                    Message *msg)
{
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractCallReleaseCompleteType  callReleaseCompleteType;
    CellularAbstractGenericTimerInfo timerInfo;

    CellularAbstractCallReleaseCompletePkt *callReleaseCompletePkt;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData
        = (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData
        =(CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo =  nwCellularAbstractData->msLayer3Info;

    callReleaseCompletePkt =
        (CellularAbstractCallReleaseCompletePkt *)MESSAGE_ReturnPacket(msg);

    appId = callReleaseCompletePkt->appId;
    appSrcNodeId = callReleaseCompletePkt->appSrcNodeId;
    appDestNodeId = callReleaseCompletePkt->appDestNodeId;
    callSrcDestType = callReleaseCompletePkt->callSrcDestType;

    callReleaseCompleteType =
        callReleaseCompletePkt->callReleaseCompleteType;

    ERROR_Assert(
        CellularAbstractMsLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            &itemIndex,
            &transactionId) == TRUE,
        "cannot find the appInfo for this call release complete msg");

    //stop all the call control timer
    CellularAbstractMsStopCallControlTimer(node, itemIndex);

    //cc state to null
    nwCellularAbstractMsInfo->msAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_NULL;

    //TODO release MM connection

    /*
    //update stat
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        nwCellularAbstractMsInfo->stats.numMOCallReleaseByNwRcvd ++;
    else if (callSrcDestType==CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        nwCellularAbstractMsInfo->stats.numMTCallReleaseByNwRcvd ++;
    */

    //start 3240 wait for channel release msg from network
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T3240Timer;
    timerInfo.transactionId = transactionId;
    timerInfo.srcNodeId = node->nodeId;
    nwCellularAbstractMsInfo->
        msAppInfo[itemIndex].channelRequestForApplication->timerT3240Msg =
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractMsChannelReleaseTimer_T3240Time,
                &timerInfo,sizeof(CellularAbstractGenericTimerInfo));

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d:Rcvd  a call release complete by network"
            "start T3240 waiting for channel release\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

}
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleRIHandoverCommandMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle RI Handover Command Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractMsHandleRIHandoverCommandMsg(Node *node, Message *msg)
{
    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d rcvd and ready to "
            "handle RI handover command msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    int i;
    int itemIndex = -1;
    CellularAbstractHandoverCommandPkt* hoCommandPkt;
    Message *cellSelectMsg;
    CellularAbstractSelectCellInfo *cellSelectMsgInfo;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo  = nwCellularAbstractData->msLayer3Info;

    //update stats
    nwCellularAbstractMsInfo->stats.numRIHandoverCommandRcvd ++;

    hoCommandPkt =
        (CellularAbstractHandoverCommandPkt *)MESSAGE_ReturnPacket(msg);

    for (i = 0; i < hoCommandPkt->numApplication; i ++)
    {
        if (hoCommandPkt->handoverAppInfo[i].isHandoverAllowed == TRUE)
        {
            int k;
            ERROR_Assert(
                CellularAbstractMsLookForAppInfoItem(
                    node,
                    hoCommandPkt->handoverAppInfo[i].transactionId,
                    node->nodeId,
                    &itemIndex) == TRUE,
                "cannot find the appInfo for this ho command msg");

            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].bandwidthAllocated =
                hoCommandPkt->handoverAppInfo[i].bandwidthAllocated;

            for (k = 0;
                k < CELLULAR_ABSTRACT_MAX_CHANNEL_ALLOWED_PER_APP;
                k ++)
            {
                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].assignedDLChannelIndex[k] =
                    hoCommandPkt->handoverAppInfo[i].channelAllocated[k];

                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].assignedULChannelIndex[k] =
                    hoCommandPkt->handoverAppInfo[i].channelAllocated[k];
            }

            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].isHandoverInProgress = FALSE;
        }
        else
        {   //deal with handover failure
            if (DEBUG_HANDOVER)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d appId %d tran %d,appSrc %d dest %d"
                    "is rejejcted for handover\n",
                    node->getNodeTime(),
                    node->nodeId,
                    hoCommandPkt->handoverAppInfo[i].appId,
                    hoCommandPkt->handoverAppInfo[i].transactionId,
                    hoCommandPkt->handoverAppInfo[i].appSrcNodeId,
                    hoCommandPkt->handoverAppInfo[i].appDestNodeId);
                fflush(stdout);
            }
            ERROR_Assert(
                CellularAbstractMsLookForAppInfoItem(
                    node,
                    hoCommandPkt->handoverAppInfo[i].transactionId,
                    node->nodeId,
                    &itemIndex) == TRUE,
                "cannot find the appInfo for this ho command msg");

            //send call drop msg
            CellularAbstractMsSendAppCallDroppedMsg(
                node,
                nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].appId,

                nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].srcMsNodeId,

                nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].destMsNodeId,

                CELLULAR_ABSTRACT_CALL_DROP_CAUSE_HANDOVER_FAILURE,
                i * MICRO_SECOND);
            //and reset appinfo item
            CellularAbstractMsResetAppItem(node, itemIndex);
            nwCellularAbstractMsInfo->numActiveApplicaions --;
        }
    }

    //swich the accoicted BS sector info to the target bs sector
    nwCellularAbstractMsInfo->associatedBsSectorInfo->
        associatedBSNodeId = hoCommandPkt->targetBsNodeId;

    nwCellularAbstractMsInfo->associatedBsSectorInfo->
        associatedSectorId = hoCommandPkt->targetSectorId;

    // update the other information,such as TXinterger,
    //which is available in BsSectorCandidate list

    CellularAbstractBsSectorCandidate *currentCandidate;
    int found = FALSE;
    currentCandidate=nwCellularAbstractMsInfo->bsSectorCandidate;
    while (currentCandidate != NULL)
    {
        if (DEBUG_GENERAL)
        {
            printf(
                "Node%d associatedBSNodeId = %d, sysinfo bsNodeId = %d\n",
                node->nodeId,
                nwCellularAbstractMsInfo->
                    associatedBsSectorInfo->associatedBSNodeId,
                currentCandidate->sysInfo.bsNodeId);
            fflush(stdout);
        }
        if (currentCandidate->sysInfo.bsNodeId ==
            nwCellularAbstractMsInfo->
                associatedBsSectorInfo->associatedBSNodeId)
        {
            found = TRUE;
            break;
        }
        else
        {
            currentCandidate = currentCandidate->nextCandidate;
        }
    }

    ERROR_Assert(
        found == TRUE,
        "MOBILITY IS TOO HIGH!THE target BS is not in MS's range now!");

    nwCellularAbstractMsInfo->associatedBsSectorInfo->lac =
        currentCandidate->sysInfo.lac;

    nwCellularAbstractMsInfo->associatedBsSectorInfo->
        associatedBSNodeAddress = currentCandidate->sysInfo.bsNodeAddress;

    nwCellularAbstractMsInfo->associatedBsSectorInfo->
        cellIdentity = currentCandidate->sysInfo.cellId;

    nwCellularAbstractMsInfo->associatedBsSectorInfo->
        controlDLChannelIndex =
        currentCandidate->sysInfo.controlDLChannelIndex;

    nwCellularAbstractMsInfo->associatedBsSectorInfo->
        controlULChannelIndex =
        currentCandidate->sysInfo.controlULChannelIndex;

    if (currentCandidate->sysInfo.congestionControlPolicy ==
        CELLULAR_ABSTRACT_CONGESTION_CONTROL_ROUND_ROBIN)
    {
        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->congestionControlPolicy =
                CELLULAR_ABSTRACT_CONGESTION_CONTROL_ROUND_ROBIN;

        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->oneControlDuration =
            currentCandidate->sysInfo.oneControlDuration;

        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->numAccessClass =
            (short)currentCandidate->sysInfo.numAccessClass;

        nwCellularAbstractMsInfo->msAccessClass =
            (int)(RANDOM_erand(nwCellularData->randSeed) *
            currentCandidate->sysInfo.numAccessClass);

        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->refrainProb =
            currentCandidate->sysInfo.refrainProb;
    }

    nwCellularAbstractMsInfo->txInteger =
        (short)currentCandidate->sysInfo.txInteger;

    nwCellularAbstractMsInfo->maxReTrans =
        (short)currentCandidate->sysInfo.maxReTrans;

    //inform MAC the selction so they can
    //monitoring the PAGCH besides the BCCH
    if (hoCommandPkt->handoverType !=
        CELLULAR_ABSTRACT_HANDOVER_TYPE_INTRA_CELL)
    {
        cellSelectMsg =
            MESSAGE_Alloc(
                node,
                MAC_LAYER,
                MAC_PROTOCOL_CELLULAR,
                MSG_MAC_CELLULAR_FromNetworkCellSelected);

        MESSAGE_InfoAlloc(
            node,
            cellSelectMsg,
            sizeof(CellularAbstractSelectCellInfo));

        cellSelectMsgInfo =
            (CellularAbstractSelectCellInfo *)
            MESSAGE_ReturnInfo(cellSelectMsg);

        cellSelectMsgInfo->bsNodeId =
            nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId;

        cellSelectMsgInfo->sectorId =
            nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedSectorId;

        cellSelectMsgInfo->controlDLChannelIndex =
            nwCellularAbstractMsInfo->
            associatedBsSectorInfo->controlDLChannelIndex;

        cellSelectMsgInfo->controlULChannelIndex =
            nwCellularAbstractMsInfo->
            associatedBsSectorInfo->controlULChannelIndex;


        MESSAGE_SetInstanceId(cellSelectMsg,
                             (short)nwCellularData->interfaceIndex);
        MESSAGE_Send(node, cellSelectMsg, 0);
    }//only when BS change we need to give MAC notification

    if (DEBUG_NET2MAC)
    {
        printf(
            "node %d send mac a cell select msg to notify the DL UL info\n",
            node->nodeId);
        fflush(stdout);
    }

    //send handover complete to BS
    CellularAbstractHandoverCompletePkt *hoCompletePkt;
    Message *hoCompleteMsg;
    hoCompletePkt =
        (CellularAbstractHandoverCompletePkt *)
        MEM_malloc(sizeof(CellularAbstractHandoverCompletePkt));

    memcpy(
        hoCompletePkt,
        hoCommandPkt,
        sizeof(CellularAbstractHandoverCompletePkt));

    CellularAbstractLayer3BuildMessage(
        node,
        &hoCompleteMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        hoCompletePkt,
        sizeof(CellularAbstractHandoverCompletePkt));

    //send the setup msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        hoCompleteMsg,
        CELLULAR_PD_RR,//protocl discritptor
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_RI_HANDOVER_COMPLETE,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,

        nwCellularAbstractMsInfo->
        msAppInfo[itemIndex].assignedULChannelIndex[0],

        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only assocatiated BS

        nwCellularAbstractMsInfo->
            associatedBsSectorInfo->associatedBSNodeId);

    MEM_free(hoCompletePkt);

    //update stats
    nwCellularAbstractMsInfo->stats.numRIHandoverCompleteSent ++;

    //reset the handover state
    nwCellularAbstractMsInfo->handoverState =
        CELLULAR_ABSTRACT_HANDOVER_STATE_IDLE;

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HO: build and send "
            "intra-cell handover complete to BS %d\n",
            node->getNodeTime(),
            node->nodeId,
            nwCellularAbstractMsInfo->
                associatedBsSectorInfo->associatedBSNodeId);
        fflush(stdout);
    }
}
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractMsHandleHandoverRequiredRejectMsg
// LAYER      :: Layer3
// PURPOSE    :: Ms Handle Handover Required Reject Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractMsHandleHandoverRequiredRejectMsg(Node *node,
                                                       Message *msg)
{
    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d rcvd and ready to handle"
            "handover requried reject msg\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
    int i;
    int itemIndex;
    CellularAbstractHandoverRequiredRejectPkt *hoRequiredRejectPkt;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo  = nwCellularAbstractData->msLayer3Info;

    //update stats
    nwCellularAbstractMsInfo->stats.numHandoverRequiredRejectRcvd ++;

    hoRequiredRejectPkt =
        (CellularAbstractHandoverRequiredRejectPkt *)
        MESSAGE_ReturnPacket(msg);

    for (i = 0; i < hoRequiredRejectPkt->numApplication; i ++)
    {
        //deal with handover failure
        if (DEBUG_HANDOVER)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d appId %d tran %d,appSrc %d dest %d"
                "is rejejcted for handover\n",
                node->getNodeTime(), node->nodeId,
                hoRequiredRejectPkt->handoverAppInfo[i].appId,
                hoRequiredRejectPkt->handoverAppInfo[i].transactionId,
                hoRequiredRejectPkt->handoverAppInfo[i].appSrcNodeId,
                hoRequiredRejectPkt->handoverAppInfo[i].appDestNodeId);
            fflush(stdout);
        }
        ERROR_Assert(
            CellularAbstractMsLookForAppInfoItem(
                node,
                hoRequiredRejectPkt->handoverAppInfo[i].transactionId,
                node->nodeId,
                &itemIndex) == TRUE,
            "cannot find the appInfo for this ho command msg");

        //update the handover state to idle
        nwCellularAbstractMsInfo->
                        msAppInfo[itemIndex].isHandoverInProgress = FALSE;
        //send call drop msg
        CellularAbstractMsSendAppCallDroppedMsg(
            node,
            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].appId,

            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].srcMsNodeId,

            nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].destMsNodeId,

            CELLULAR_ABSTRACT_CALL_DROP_CAUSE_HANDOVER_FAILURE,
            i * MICRO_SECOND);
        //disconnect the call or deactivate the PDP context
        if (nwCellularAbstractMsInfo->
                msAppInfo[itemIndex].applicationType ==
                CELLULAR_ABSTRACT_VOICE_PHONE)
        {
            //send call disconnect msg
            CellularAbstractMsSendCallDisconnectMsg(
                node,

                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].appId,

                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].srcMsNodeId,

                nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].destMsNodeId,

                CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_HANDOVER,
                i * MICRO_SECOND);

            if (DEBUG_HANDOVER)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d send call disc "
                    "msg out for appId %d tran %d,"
                    "appSrc %d dest %d\n",
                    node->getNodeTime(), node->nodeId,
                    hoRequiredRejectPkt->handoverAppInfo[i].appId,
                    hoRequiredRejectPkt->handoverAppInfo[i].transactionId,
                    hoRequiredRejectPkt->handoverAppInfo[i].appSrcNodeId,
                    hoRequiredRejectPkt->handoverAppInfo[i].appDestNodeId);
                fflush(stdout);
            }

        }
        else
        {
            //send deactivate PDP request
            if (nwCellularAbstractMsInfo->
                    msAppInfo[itemIndex].callSrcDestType ==
                    CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
            {
                //only src MS need to deactivate
                //for those terminating call, SC will init. the deactivation
                CellularAbstractMsSendDeactivatePDPContextRequestMsg(
                    node,
                    nwCellularAbstractMsInfo->
                        msAppInfo[itemIndex].appId,

                    nwCellularAbstractMsInfo->
                        msAppInfo[itemIndex].applicationType,

                    nwCellularAbstractMsInfo->
                        msAppInfo[itemIndex].srcMsNodeId,

                    nwCellularAbstractMsInfo->
                        msAppInfo[itemIndex].destMsNodeId,

                    nwCellularAbstractMsInfo->
                        msAppInfo[itemIndex].callSrcDestType,

                    CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_HANDOVER,
                    i * MICRO_SECOND);

                if (DEBUG_HANDOVER)
                {
                    printf(
                        "at %015" TYPES_64BITFMT "d node %d send deactivate PDP msg out for"
                        "appId %d tran %d, appSrc %d dest %d\n",
                        node->getNodeTime(),
                        node->nodeId,
                        hoRequiredRejectPkt->handoverAppInfo[i].appId,
                      hoRequiredRejectPkt->handoverAppInfo[i].transactionId,
                        hoRequiredRejectPkt->handoverAppInfo[i].appSrcNodeId,
                      hoRequiredRejectPkt->handoverAppInfo[i].appDestNodeId);
                    fflush(stdout);
                }
            }
        }
    }

    //reset the handover state
    nwCellularAbstractMsInfo->handoverState =
        CELLULAR_ABSTRACT_HANDOVER_STATE_IDLE;
}
///////////////////////////////////////////////////////////////////////
//BLOCK: BS FUNCTIONS                                               //
//                                                                  //
///////////////////////////////////////////////////////////////////////
//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractFindOneIdleChannelFromChannelBank
// LAYER      :: Layer3
// PURPOSE    :: Look for a free channel in the channel bank.
// PARAMETERS ::
// + node             : Node*   : Pointer to node.
// + sectorId         : int     : sector Id.
// + estCause         : CellularEstCause : COnnection establish cause
// + channelRequestType: CellularAbstractChannelRequestType: 
//                               Type of channel request
// + retChannelIndex  : int *   : Pointer to channel index found
// RETURN     :: void : NULL
// **/
//***********************************************************************
#if 0
static
BOOL CellularAbstractFindOneIdleChannelFromChannelBank(
        Node *node,
        int sectorId,
        CellularEstCause estCause,
        CellularAbstractChannelRequestType channelRequestType,
        int *retChannelIndex)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;
    CellularAbstractSectorInfo *sectorInfo;
    int numSectorInCell;
    int sectorIndex;
    int numChannelAssignedToSector;
    BOOL found;
    int i;

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR Enter: Look for a free channel for"
            "estCause %d and channelRequest Type %d in sector %d\n",
            node->getNodeTime(), node->nodeId, estCause,
            channelRequestType, sectorId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    sectorInfo = nwCellularAbstractBsInfo->bsSectorInfo;
    numSectorInCell = nwCellularAbstractBsInfo->numSectorInCell;
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d the total secto is %d\n",
            node->getNodeTime(), node->nodeId,
            nwCellularAbstractBsInfo->numSectorInCell);
        fflush(stdout);
    }

    ERROR_Assert(
        sectorId <= numSectorInCell,
        "The sector Id does not match "
        "(bigger than) the BS configuration");

    for (sectorIndex = 0; sectorIndex < numSectorInCell; sectorIndex ++)
    {
        //looking for the sector
        if (DEBUG_RR)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d visit the sec info, the sec id is %d\n",
                node->getNodeTime(), node->nodeId,
                (sectorInfo+sectorIndex)->sectorId);
            fflush(stdout);
        }
        if ((sectorInfo+sectorIndex)->sectorId==sectorId)
        {
            break;
        }
    }

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d found the sector %d in BSSECOT INFO\n",
            node->getNodeTime(), node->nodeId,
            sectorInfo[sectorIndex].sectorId);
        fflush(stdout);
    }

    //get the number of channel assigned to this sector
    numChannelAssignedToSector =
        sectorInfo[sectorIndex].numChannelAssigned;

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d "
            "found the sector %d in BSSECOT INFO with %d channels\n",
            node->getNodeTime(), node->nodeId,
            (sectorInfo+sectorIndex)->sectorId,
            numChannelAssignedToSector);
        fflush(stdout);
    }

    found = FALSE;
    for (i = 0; i < numChannelAssignedToSector; i ++)
    {
        int sectorChannelIndex;
        int bsNumChannelAssigned;
        int j;
        CellularAbstractChannelDescription *bsChannelBank;

        sectorChannelIndex =
            (sectorInfo+sectorIndex)->channelIndex[i];

        if (DEBUG_RR)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d found one channel "
                "allocate to this sector with index %d\n",
                node->getNodeTime(), node->nodeId, sectorChannelIndex);
            fflush(stdout);
        }

        bsChannelBank = nwCellularAbstractBsInfo->bsChannelBank;
        bsNumChannelAssigned = nwCellularAbstractBsInfo->numChannelAssigned;
        //look for the channel
        for (j=0;j<bsNumChannelAssigned;j++)
        {
            if ((bsChannelBank+j)->channelIndex==sectorChannelIndex)break;
        }
        if (DEBUG_RR)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d found the channel allocate to this sector"
                "with index %d in channel bank index %d\n",
                node->getNodeTime(), node->nodeId, sectorChannelIndex, j);
            fflush(stdout);
        }

        /*the case when channelRequestType is not available
        if ((bsChannelBank+j)->isControlChannel==FALSE &&
            (bsChannelBank+j)->isChannelInUse==FALSE &&
            ((bsChannelBank+j)->channelStatus==
             CELLULAR_ABSTRACT_CHANNEL_STATUS_IDLE)
        {
            found=TRUE;
            *retChannelIndex=sectorChannelIndex;
            (bsChannelBank+j)->channelStatus=
                CELLULAR_ABSTRACT_CHANNEL_STATUS_TENTATIVE;
            if (DEBUG_RR)printf("this channel is free!\n");
        }
        */

        //check to see if the channel is idle or not
        //call admission control may be called
        switch (channelRequestType)
        {
            case CELLULAR_ABSTRACT_CHANNEL_REQUEST_GENERAL:
            {
                //more cllassfificatio n can be further made
                if ((bsChannelBank + j)->isControlChannel == FALSE &&
                    (bsChannelBank + j)->isChannelInUse == FALSE &&
                    ((bsChannelBank + j)->channelStatus ==
                        CELLULAR_ABSTRACT_CHANNEL_STATUS_IDLE ||
                    (bsChannelBank + j)->channelStatus ==
                        CELLULAR_ABSTRACT_CHANNEL_STATUS_RESERVED_GENERAL))
                {
                    found = TRUE;
                    *retChannelIndex = sectorChannelIndex;

                    (bsChannelBank + j)->channelStatus =
                        CELLULAR_ABSTRACT_CHANNEL_STATUS_TENTATIVE;

                    if (DEBUG_RR)
                    {
                        printf("at %015" TYPES_64BITFMT "d node %d this channel is free!\n",
                                node->getNodeTime(), node->nodeId);
                        fflush(stdout);
                    }
                }
                break;
            }
            case CELLULAR_ABSTRACT_CHANNEL_REQUEST_VOICE:
            {
                //more cllassfificatio n can be further made
                if ((bsChannelBank + j)->isControlChannel == FALSE &&
                    (bsChannelBank + j)->isChannelInUse == FALSE &&
                    ((bsChannelBank + j)->channelStatus ==
                        CELLULAR_ABSTRACT_CHANNEL_STATUS_IDLE ||
                    (bsChannelBank + j)->channelStatus ==
                        CELLULAR_ABSTRACT_CHANNEL_STATUS_RESERVED_VOICE))

                {
                    found = TRUE;
                    *retChannelIndex = sectorChannelIndex;
                    (bsChannelBank + j)->channelStatus =
                        CELLULAR_ABSTRACT_CHANNEL_STATUS_TENTATIVE;
                }
                break;
            }
            case CELLULAR_ABSTRACT_CHANNEL_REQUEST_DATA:
            {
                //more cllassfificatio n can be further made
                if ((bsChannelBank + j)->isControlChannel == FALSE &&
                    (bsChannelBank + j)->isChannelInUse == FALSE &&
                    ((bsChannelBank + j)->channelStatus ==
                        CELLULAR_ABSTRACT_CHANNEL_STATUS_IDLE ||
                    (bsChannelBank + j)->channelStatus ==
                        CELLULAR_ABSTRACT_CHANNEL_STATUS_RESERVED_DATA))
                {
                    found = TRUE;
                    *retChannelIndex = sectorChannelIndex;
                    (bsChannelBank + j)->channelStatus =
                        CELLULAR_ABSTRACT_CHANNEL_STATUS_TENTATIVE;
                }
                break;
            }
        }
        if (found == TRUE)
        {
            break;
        }
    }

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d Exit: Look for a free channel,"
            "estCause %d, Request Type %d\n",
            node->getNodeTime(), node->nodeId, estCause, channelRequestType);
        fflush(stdout);
    }
    return found;
}
#endif
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractBandwidthAllocation
// LAYER      :: Layer3
// PURPOSE    :: Allocate bandwidth in the specified sector .
// PARAMETERS ::
// + node             : Node*   : Pointer to node.
// + sectorId         : int     : sector Id.
// + estCause         : CellularEstCause : COnnection establish cause
// + channelRequestType: CellularAbstractChannelRequestType:
//                       Type of channel request
// + bandwidthRequired: double  : Bandwidth requirement
// + retBandwidth     : double* : Pointer to bandwidth allocated
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractBandwidthAllocation(
        Node *node,
        int sectorId,
        CellularEstCause estCause,
        CellularAbstractChannelRequestType channelRequestType,
        double bandwidthRequired,
        double *retBandwidth)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;
    CellularAbstractSectorInfo *sectorInfo;
    short numSectorInCell;
    short sectorIndex;
    double bandwidthAssignedToSector;
    double availableBandwidth;

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d Enter: Look for free bandwidth for"
            "estCause %d and channelRequest Type %d in sector %d\n",
            node->getNodeTime(), node->nodeId,
            estCause, channelRequestType, sectorId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    sectorInfo  = nwCellularAbstractBsInfo->bsSectorInfo;

    numSectorInCell=nwCellularAbstractBsInfo->numSectorInCell;
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d the total secto is %d\n",
            node->getNodeTime(), node->nodeId,
            nwCellularAbstractBsInfo->numSectorInCell);
        fflush(stdout);
    }

    ERROR_Assert(
        sectorId <= numSectorInCell,
        "The sector Id does not match (bigger than) the BS configuration");

    for (sectorIndex = 0; sectorIndex < numSectorInCell; sectorIndex ++)
    {
        //looking for the sector
        if (DEBUG_RR)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d visit the sector info,"
                "the sector id is %d\n",
                node->getNodeTime(), node->nodeId,
                (sectorInfo+sectorIndex)->sectorId);
            fflush(stdout);
        }
        if ((sectorInfo + sectorIndex)->sectorId == sectorId)
        {
            break;
        }
    }
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d found the "
            "sector %d in BSSECTOR INFO\n",
            node->getNodeTime(), node->nodeId,
            sectorInfo[sectorIndex].sectorId);
        fflush(stdout);
    }

    //get the bandwidth assigned to this sector
    bandwidthAssignedToSector =
        sectorInfo[sectorIndex].sectorBandwidthAllocated;
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d found the sector %d in "
            "BSSECOT INFO with %f bandwidth\n",
            node->getNodeTime(),
            node->nodeId,
            (sectorInfo + sectorIndex)->sectorId,
            bandwidthAssignedToSector);
        fflush(stdout);
    }

    if (DEBUG_RESOURCE && 0)
    {
        char time[MAX_STRING_LENGTH] = {0};
        TIME_PrintClockInSecond(node->getNodeTime(), time);
        printf(
        "NODE %d TIME %s SECTOR %d USED %f\n",
            node->nodeId,time,sectorId,
            sectorInfo[sectorIndex].bandwidthInUse);
        printf("NODE %d TIME %s SECTOR %d USED %f\n",
            node->nodeId,time,0,nwCellularAbstractBsInfo->bandwidthInUse);
    }

    availableBandwidth =
        bandwidthAssignedToSector - sectorInfo[sectorIndex].bandwidthInUse;
    if (bandwidthRequired < availableBandwidth)
    {
        if (((int)(bandwidthRequired / CELLULAR_ABSTRACT_BANDWIDTH_UNIT))
            * CELLULAR_ABSTRACT_BANDWIDTH_UNIT < bandwidthRequired)
        {
            if ((((int)(bandwidthRequired
                    / CELLULAR_ABSTRACT_BANDWIDTH_UNIT) + 1)
                    * CELLULAR_ABSTRACT_BANDWIDTH_UNIT) >
               availableBandwidth)
            {
                *retBandwidth = availableBandwidth;
            }
            else
            {
                *retBandwidth = ((int)(bandwidthRequired
                    / CELLULAR_ABSTRACT_BANDWIDTH_UNIT) + 1)
                    * CELLULAR_ABSTRACT_BANDWIDTH_UNIT;

            }
        }
        else
        {
            *retBandwidth = bandwidthRequired;
        }

        sectorInfo[sectorIndex].bandwidthInUse =
            sectorInfo[sectorIndex].bandwidthInUse + (*retBandwidth);

        nwCellularAbstractBsInfo->bandwidthInUse =
            nwCellularAbstractBsInfo->bandwidthInUse + (*retBandwidth);
    }
    else
    {
        *retBandwidth = 0;
    }
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR, allocate %f bandwidth "
            "in sector %d with %f in use of total %f\n",
            node->getNodeTime(),
            node->nodeId,
            *retBandwidth,
            sectorId,
            sectorInfo[sectorIndex].bandwidthInUse,
            bandwidthAssignedToSector);
        fflush(stdout);
    }

    if (DEBUG_RESOURCE)
    {
        char time[MAX_STRING_LENGTH] = {0};
        TIME_PrintClockInSecond(node->getNodeTime(), time);
        printf(
            "NODE %d TIME %s SECTOR %d USED %f\n",
            node->nodeId, time, sectorId,
            sectorInfo[sectorIndex].bandwidthInUse);
        fflush(stdout);

        printf("NODE %d TIME %s SECTOR %d USED %f\n",
            node->nodeId, time, 0,
            nwCellularAbstractBsInfo->bandwidthInUse);
        fflush(stdout);
    }
}

//************************************************************************
// /**
// FUNCTION   :: CellularAbstractBandwidthDeallocation
// LAYER      :: Layer3
// PURPOSE    :: Dellocate bandwidth in the specified sector .
// PARAMETERS ::
// + node             : Node*   : Pointer to node.
// + sectorId         : int     : sector Id.
// + bandwidthAllocated: double : Bandwidth deallocated
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractBandwidthDeallocation(
        Node *node,
        int sectorId,
        double bandwidthAllocated)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;
    CellularAbstractSectorInfo *sectorInfo;
    short numSectorInCell;
    short sectorIndex;

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d Enter: "
            "Deallocate bandwidth %f in sector %d\n",
            node->getNodeTime(), node->nodeId, bandwidthAllocated, sectorId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    sectorInfo = nwCellularAbstractBsInfo->bsSectorInfo;
    numSectorInCell = nwCellularAbstractBsInfo->numSectorInCell;

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d the total sector is %d\n",
            node->getNodeTime(), node->nodeId,
            nwCellularAbstractBsInfo->numSectorInCell);
        fflush(stdout);
    }
    ERROR_Assert(
        sectorId<=numSectorInCell,
        "The sector Id does not match (bigger than) the BS configuration");

    for (sectorIndex = 0; sectorIndex < numSectorInCell; sectorIndex ++)
    {
        //looking for the sector
        if (DEBUG_RR)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d visit the sector info, "
                "the sector id is %d\n",
                node->getNodeTime(), node->nodeId,
                (sectorInfo + sectorIndex)->sectorId);
            fflush(stdout);
        }
        if ((sectorInfo + sectorIndex)->sectorId == sectorId)
        {
            break;
        }
    }
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d found the sector %d in BSSECOT INFO\n",
            node->getNodeTime(), node->nodeId,
            sectorInfo[sectorIndex].sectorId);
        fflush(stdout);
    }

    if (DEBUG_RESOURCE && 0)
    {
        char time[MAX_STRING_LENGTH] = {0};
        TIME_PrintClockInSecond(node->getNodeTime(), time);
        printf(
            "NODE %d TIME %s SECTOR %d USED %f\n",
            node->nodeId, time, sectorId,
            sectorInfo[sectorIndex].bandwidthInUse);
        printf(
            "NODE %d TIME %s SECTOR %d USED %f\n",
            node->nodeId, time, 0,
            nwCellularAbstractBsInfo->bandwidthInUse);
    }
    sectorInfo[sectorIndex].bandwidthInUse =
        sectorInfo[sectorIndex].bandwidthInUse-bandwidthAllocated;

    ERROR_Assert(
        sectorInfo[sectorIndex].bandwidthInUse >= 0,
        "The setor: the bandwidth freed is "
        "inconsistece with the total in use");

    nwCellularAbstractBsInfo->bandwidthInUse =
        nwCellularAbstractBsInfo->bandwidthInUse-bandwidthAllocated;

    ERROR_Assert(
        nwCellularAbstractBsInfo->bandwidthInUse >= 0,
        "The BS: the bandwidth freed is "
        "inconsistece with the total in use");

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d: RR Free bandwidth %f in sector %d\n",
            node->getNodeTime(),
            node->nodeId,
            bandwidthAllocated,
            sectorInfo[sectorIndex].sectorId);
        fflush(stdout);
    }
    if (DEBUG_RESOURCE)
    {
        char time[MAX_STRING_LENGTH] = {0};
        TIME_PrintClockInSecond(node->getNodeTime(), time);
        printf(
            "NODE %d TIME %s SECTOR %d USED %f\n",
            node->nodeId,
            time,
            sectorId,
            sectorInfo[sectorIndex].bandwidthInUse);
        fflush(stdout);

        printf(
            "NODE %d TIME %s SECTOR %d USED %f\n",
            node->nodeId,
            time,
            0,
            nwCellularAbstractBsInfo->bandwidthInUse);
        fflush(stdout);
    }
}

//********************************************************************
// /**
// FUNCTION   :: CellularAbstractBsCreateAppInfoItem
// LAYER      :: Layer3
// PURPOSE    :: Create an application info record at BS.
// PARAMETERS ::
// + node             : Node* : Pointer to node.
// + transactionId    : int   : Transaction id
// + srcNodeId        : NodeAddress : Source address
// + sectorId         : int   : Sector Id.
// + bandwidthAllocated: double : Bandwidth allocated
// + itemIndex        : int * : Pointed to record index
// RETURN     :: void : NULL
// **/
//********************************************************************
static
void CellularAbstractBsCreateAppInfoItem(
        Node *node,
        int transactionId,
        NodeAddress srcNodeId,
        int sectorId,
        double bandwidthAllocated,
        int *itemIndex)
{
    int i;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;
    BOOL found = FALSE;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    //look for the first un used item
    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS; i ++)
    {
        if (nwCellularAbstractBsInfo->bsAppInfo[i].inUse == FALSE)
        {
            found = TRUE;
            break;
        }
    }

    //make sure there is enough room to keep these information
    ERROR_Assert(
        found==TRUE,
        "TOO MANY CONCURRENT TRANSACIONS!INCREASE THE value of"
        "CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS!");

    //update the item
    nwCellularAbstractBsInfo->bsAppInfo[i].inUse = TRUE;

    //it means this item is creat by the request
    //from this node, it cold be src or dest
    nwCellularAbstractBsInfo->bsAppInfo[i].msNodeId = srcNodeId;

    nwCellularAbstractBsInfo->bsAppInfo[i].sectorId = sectorId;
    nwCellularAbstractBsInfo->bsAppInfo[i].transactionId = transactionId;

    nwCellularAbstractBsInfo->
        bsAppInfo[i].bandwidthAllocated = bandwidthAllocated;

    nwCellularAbstractBsInfo->
        bsAppInfo[i].assignedDLChannelIndex[0] = 0;

    nwCellularAbstractBsInfo->
        bsAppInfo[i].assignedULChannelIndex[0] = 0;

    nwCellularAbstractBsInfo->
        bsAppInfo[i].isDedicatedChannelAssigned = TRUE;

    *itemIndex = i;

    if (DEBUG_GENERAL)
    {
        printf(
            "node %d: create a appInfo for node %d transactionId"
            "%d in sector %d with aloocated BW %f\n",
            node->nodeId,
            nwCellularAbstractBsInfo->bsAppInfo[i].msNodeId,
            nwCellularAbstractBsInfo->bsAppInfo[i].transactionId,
            nwCellularAbstractBsInfo->bsAppInfo[i].sectorId,
            nwCellularAbstractBsInfo->bsAppInfo[i].bandwidthAllocated);
        fflush(stdout);
    }
}

//************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsLookForAppInfoItem
// LAYER      :: Layer3
// PURPOSE    :: Look for an application info record at BS.
// PARAMETERS ::
// + node             : Node*                           : Pointer to node.
// + transactionId    : int                             : Transaction id
// + srcNodeId        : NodeAddress                     : Source address
// + itemIndex        : int *                           : Record index
// RETURN     :: BOOL : found
// **/
//*************************************************************************
static
BOOL CellularAbstractBsLookForAppInfoItem(Node *node,
                                          int transactionId,
                                          NodeAddress srcNodeId,
                                          int *itemIndex)
{
    int i;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;
    BOOL found = FALSE;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    if (DEBUG_GENERAL)
    {
        printf(
            "Node %d: look for appItem for src %d transactionid %d \n",
            node->nodeId, srcNodeId, transactionId);
        fflush(stdout);
    }

    //look for the first  item
    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS; i ++)
    {
        if (nwCellularAbstractBsInfo->bsAppInfo[i].inUse == TRUE &&
            nwCellularAbstractBsInfo->bsAppInfo[i].msNodeId == srcNodeId &&
            nwCellularAbstractBsInfo->
                bsAppInfo[i].transactionId == transactionId)
        {
            found = TRUE;
            if (DEBUG_GENERAL)
            {
                printf(
                    "Node %d: found src %d transactionid %d"
                    "in sector %d with bandwdith %f\n",
                    node->nodeId, srcNodeId, transactionId,
                    nwCellularAbstractBsInfo->bsAppInfo[i].sectorId,
                    nwCellularAbstractBsInfo->
                        bsAppInfo[i].bandwidthAllocated);
                fflush(stdout);
            }
            break;
        }
    }

    *itemIndex=i;
    return found;
}

//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsResetAppInfo
// LAYER      :: Layer3
// PURPOSE    :: Reset an application info record at BS.
// PARAMETERS ::
// + node             : Node*                           : Pointer to node.
// + itemIndex        : int                             : The record index
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractBsResetAppInfo(Node *node, int itemIndex)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    if (DEBUG_GENERAL)
    {
        printf(
            "node %d: reset for src  %d, transId %d\n",
            node->nodeId,
            nwCellularAbstractBsInfo->bsAppInfo[itemIndex].msNodeId,
            nwCellularAbstractBsInfo->bsAppInfo[itemIndex].transactionId);
        fflush(stdout);
    }

    nwCellularAbstractBsInfo->bsAppInfo[itemIndex].inUse = FALSE;

    nwCellularAbstractBsInfo->
        bsAppInfo[itemIndex].isDedicatedChannelAssigned = FALSE;

    //TODO; reset others
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsForwardMsgToMs
// LAYER      :: Layer3
// PURPOSE    :: BS forward msg to MS.
// PARAMETERS ::
// + node             : Node*                        : Pointer to node.
// + msg              : Message *                    : Message to be handled
// + messageType      : CellularAbstractMessageType  : Type of message
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractBsForwardMsgToMs(Node *node,
                                      Message *msg,
                                      CellularAbstractMessageType messageType)
{

    //variables for forward msg
    Message *outMsg;
    int packetSize = 0;
    void* packetData = NULL;
    CellularProtocolDiscriminator protocolDiscriminator=CELLULAR_PD_INVALID;
    NodeAddress recvId = CELLULAR_ABSTRACT_INVALID_MS_ID;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    if (messageType ==
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_LOCATION_UPDATE_REJECT)
    {
        CellularAbstractLocationUpdateRejectPkt *locRejectPkt;
        locRejectPkt =
            (CellularAbstractLocationUpdateRejectPkt *)
            MESSAGE_ReturnPacket(msg);

        packetData = (void *)locRejectPkt;
        packetSize = sizeof(CellularAbstractLocationUpdateRejectPkt);
        protocolDiscriminator = CELLULAR_PD_MM;
        recvId = locRejectPkt->msNodeId;

        if (DEBUG_MM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d MM: prepare to forward LOCATION Reject"
                "msg to %d\n",
                node->getNodeTime(),
                node->nodeId,
                recvId);
            fflush(stdout);
        }
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_LOCATION_UPDATE_ACCEPT)
    {
        CellularAbstractLocationUpdateAcceptPkt *locAcceptPkt;
        locAcceptPkt =
            (CellularAbstractLocationUpdateAcceptPkt *)
            MESSAGE_ReturnPacket(msg);

        packetData = (void *)locAcceptPkt;
        packetSize = sizeof(CellularAbstractLocationUpdateAcceptPkt);
        protocolDiscriminator = CELLULAR_PD_MM;
        recvId = locAcceptPkt->msNodeId;

        if (DEBUG_MM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d MM: prepare to forward LOCATION Accept"
                "msg to %d\n",
                node->getNodeTime(), node->nodeId,
                recvId);
            fflush(stdout);
        }
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_CM_SERVICE_ACCEPT)
    {
        CellularAbstractCMServiceAcceptPkt *cmAcceptPkt;
        cmAcceptPkt =
            (CellularAbstractCMServiceAcceptPkt *)
            MESSAGE_ReturnPacket(msg);

        packetData = (void *)cmAcceptPkt;
        packetSize = sizeof(CellularAbstractCMServiceAcceptPkt);
        protocolDiscriminator = CELLULAR_PD_MM;
        recvId = cmAcceptPkt->msNodeId;

        //update stats
        nwCellularAbstractBsInfo->stats.numCmServiceAcceptRcvd ++;
        nwCellularAbstractBsInfo->stats.numCmServiceAcceptFwd ++;

        if (DEBUG_MM||DEBUG_PROGRESS)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d MM:prepare to forward"
                "CM Service Accept msg to %d sizeof CMaccept %"
                TYPES_SIZEOFMFT "u CM request %" TYPES_SIZEOFMFT "u \n",
                node->getNodeTime(), node->nodeId,
                recvId,
                sizeof(CellularAbstractCMServiceAcceptPkt),
                sizeof(CellularAbstractCMServiceRequestPkt));
            fflush(stdout);
        }
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CALL_PROCEEDING)//to src ms
    {
        CellularAbstractCallProceedingPkt *callProcPkt;
        callProcPkt =
            (CellularAbstractCallProceedingPkt *)
                MESSAGE_ReturnPacket(msg);

        packetData = (void *)callProcPkt;
        packetSize = sizeof(CellularAbstractCallProceedingPkt);
        protocolDiscriminator = CELLULAR_PD_CC;
        recvId = callProcPkt->appSrcNodeId;

        //update the stats
        nwCellularAbstractBsInfo->stats.numCallProceedingRcvd ++;
        nwCellularAbstractBsInfo->stats.numCallProceedingFwd ++;

        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC: prepare to MO foward"
                "call proceeding to MS %d\n",
                node->getNodeTime(),
                node->nodeId,
                recvId);
            fflush(stdout);
        }
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_SETUP)
    {
        //setup only fwd to dest Ms by BS
        CellularAbstractCallSetupPkt *callSetupPkt;

        callSetupPkt =
            (CellularAbstractCallSetupPkt *)MESSAGE_ReturnPacket(msg);
        packetData = (void *)callSetupPkt;
        packetSize = sizeof(CellularAbstractCallSetupPkt);
        protocolDiscriminator = CELLULAR_PD_CC;
        recvId = callSetupPkt->appDestNodeId;

        //update the stats
        nwCellularAbstractBsInfo->stats.numMTCallSetupFwd ++;
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC:prepare to "
                "forward MT call setup to MS %d\n",
                node->getNodeTime(),
                node->nodeId,
                recvId);
            fflush(stdout);
        }
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_ALERTING)
    {
        CellularAbstractCallAlertingPkt *callAlertingPkt;

        callAlertingPkt =
            (CellularAbstractCallAlertingPkt *)
            MESSAGE_ReturnPacket(msg);

        packetData = (void *)callAlertingPkt;
        packetSize = sizeof(CellularAbstractCallAlertingPkt);
        protocolDiscriminator = CELLULAR_PD_CC;
        recvId = callAlertingPkt->appSrcNodeId;

        //update the stats
        nwCellularAbstractBsInfo->stats.numMOCallAlertingFwd ++;

        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC: forward MO call"
                "Alerting to MS %d\n",
                node->getNodeTime(),
                node->nodeId,
                recvId);
            fflush(stdout);
        }
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT)
    {
        CellularAbstractCallConnectPkt *callConnectPkt;

        callConnectPkt =
            (CellularAbstractCallConnectPkt *)MESSAGE_ReturnPacket(msg);

        packetData = (void *)callConnectPkt;
        packetSize = sizeof(CellularAbstractCallConnectPkt);
        protocolDiscriminator = CELLULAR_PD_CC;
        recvId = callConnectPkt->appSrcNodeId;

        //update the stats
        nwCellularAbstractBsInfo->stats.numMOCallConnectFwd ++;

        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC: prepare to forward"
                "MO call Connect to MS %d\n",
                node->getNodeTime(),
                node->nodeId,
                recvId);
            fflush(stdout);
        }
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT_ACKNOWLEDGE)
    {
        //to dest ms
        CellularAbstractCallConnectAckPkt *callConnectAckPkt;

        callConnectAckPkt =
            (CellularAbstractCallConnectAckPkt *)
            MESSAGE_ReturnPacket(msg);

        packetData = (void *)callConnectAckPkt;
        packetSize = sizeof(CellularAbstractCallConnectAckPkt);
        protocolDiscriminator = CELLULAR_PD_CC;
        recvId = callConnectAckPkt->appDestNodeId;

        //update the stats
        nwCellularAbstractBsInfo->stats.numMTCallConnectAckFwd ++;

        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC: prepare to forward MT "
                "call Connect Ack to MS %d\n",
                node->getNodeTime(),
                node->nodeId,
                recvId);
            fflush(stdout);
        }
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_SM_ACTIVATE_PDP_CONTEXT_ACCEPT)//to src ms
    {
        CellularAbstractActivatePDPContextAcceptPkt *APCAcceptPkt;

        APCAcceptPkt =
            (CellularAbstractActivatePDPContextAcceptPkt *)
            MESSAGE_ReturnPacket(msg);

        packetData = (void *)APCAcceptPkt;
        packetSize = sizeof(CellularAbstractActivatePDPContextAcceptPkt);
        protocolDiscriminator = CELLULAR_PD_SM;

        if (APCAcceptPkt->callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            recvId = APCAcceptPkt->appSrcNodeId;
            if (DEBUG_SM)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d BS node %d SM: prepare to foward"
                    "MO ACTIVATE_PDP_CONTEXT_ACCEPT to MS %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    recvId);
                fflush(stdout);
            }
        }
        else if (APCAcceptPkt->callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {
            recvId = APCAcceptPkt->appDestNodeId;
            if (DEBUG_SM)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d BS node %d SM: prepare to foward MT "
                    "ACTIVATE_PDP_CONTEXT_ACCEPT to MS %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    recvId);
                fflush(stdout);
            }
        }

        //update the stats TODO
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_SM_REQUEST_PDP_CONTEXT_ACTIVATION)
    {
        CellularAbstractRequestPDPContextActivationPkt
            *reqPDPActiationPkt;

        reqPDPActiationPkt =
            (CellularAbstractRequestPDPContextActivationPkt *)
            MESSAGE_ReturnPacket(msg);

        packetData = (void *)reqPDPActiationPkt;
        packetSize = sizeof(CellularAbstractRequestPDPContextActivationPkt);
        protocolDiscriminator = CELLULAR_PD_SM;
        recvId = reqPDPActiationPkt->appDestNodeId;

        //update the stats TODO

        if (DEBUG_SM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d BS node %d SM: prepare to foward MT "
                "REQUEST_PDP_CONTEXT_ACTIVATION to MS %d\n",
                node->getNodeTime(),
                node->nodeId,
                recvId);
            fflush(stdout);
        }
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_CALL_REJECT_INDICATION)
    {
        CellularAbstractMTCallRejectIndication *mtCallRejectPkt;
        mtCallRejectPkt =
            (CellularAbstractMTCallRejectIndication *)
            MESSAGE_ReturnPacket(msg);

        packetData = (void *)mtCallRejectPkt;
        packetSize = sizeof(CellularAbstractMTCallRejectIndication);
        protocolDiscriminator = CELLULAR_PD_CC;
        recvId = mtCallRejectPkt->appSrcNodeId;

        //updates stats TODO

        if (DEBUG_CAC||DEBUG_CC||DEBUG_SM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC/SM: foward "
                "CALL_REJECT_INDICATION to SRC MS %d\n",
                node->getNodeTime(),
                node->nodeId,
                recvId);
            fflush(stdout);
        }
    }

    ERROR_Assert(packetData != NULL, "PacketData is NULL");

    //build the out msg
    CellularAbstractLayer3BuildMessage(
                                        node,
                                        &outMsg,
                                        MAC_LAYER,
                                        MAC_PROTOCOL_CELLULAR,
                                        MSG_MAC_CELLULAR_FromNetwork,
                                        packetData,
                                        packetSize);

    //send to mac using wireless interface
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        outMsg,
        protocolDiscriminator,
        messageType,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0, //TODO: channel id should be instanced
           //when channel index option is enabled
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        recvId);

    if (DEBUG_GENERAL)
    {
        printf(
            "node %d: msg with type %d is forwarded to %d",
            node->nodeId,
            messageType,
            recvId);
        fflush(stdout);
    }
}

//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsCallAdmissionControl
// LAYER      :: Layer3
// PURPOSE    :: Call admission control at BS.
// PARAMETERS ::
// + node             : Node*     : Pointer to node.
// + sectorId         : int       : Sector Id.
// + numChannelRequired: int      : Number of channel needed
// + bandwidthAllocated: double   : Bandwidth allocated
// + estCause         : CellularEstCause : Connection establishment cause
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
BOOL CellularAbstractBsCallAdmissionControl(
        Node *node,
        int sectorId,
        int numChannelRequired,
        double bandwidthRequired,
        CellularEstCause estCause)
{
    BOOL CACDecision = TRUE;
    CellularAbstractSectorInfo *sectorInfo;
    short numSectorInCell;
    short sectorIndex;
    double bandwidthAssignedToSector;
    double availableBandwidth;
    int assignmentIndex;
    BOOL foundAssign = FALSE;
    int assignUsed = 0;
    BOOL foundTrans = FALSE;
    int transUsed = 0;
    int i;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;
    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    //note: emergency call never blocked TODO
    // To see if system has free space to accomadatet the new request
    for (assignmentIndex = 0;
        assignmentIndex < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS;
        assignmentIndex ++)
    {
        if (nwCellularAbstractBsInfo->
            bsChannelAssignmentInfo[assignmentIndex].inUse == FALSE)
        {
            foundAssign = TRUE;
        }
        else
        {
            assignUsed ++;
        }
    }
    //to see if system has space to hold the transaction
    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS; i ++)
    {
        if (nwCellularAbstractBsInfo->bsAppInfo[i].inUse == FALSE)
        {
            foundTrans = TRUE;
        }
        else
        {
            transUsed ++;
        }
    }
    if (foundAssign == FALSE ||
        foundTrans ==  FALSE ||
        (assignUsed + transUsed) >=
        CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS)
    {
        // if no free cpace for assignment or transaction or for possible
        // future overuse assignUsed + transUsed,
        // then reject it.
        CACDecision = FALSE;

        if (DEBUG_CAC || DEBUG_RR)
        {
            printf(
                "at %015" TYPES_64BITFMT "d BS node %d: RR CAC decison is Reject ChReq "
                "not enough space foundAssign %d,foundTrans %d\n",
                node->getNodeTime(), node->nodeId,
                foundAssign, foundTrans);
            fflush(stdout);
        }

        return CACDecision;
    }

    sectorInfo = nwCellularAbstractBsInfo->bsSectorInfo;
    numSectorInCell = nwCellularAbstractBsInfo->numSectorInCell;
    ERROR_Assert(
        sectorId <= numSectorInCell,
        "The sector Id does not match (bigger than) the BS configuration");

    for (sectorIndex = 0; sectorIndex < numSectorInCell; sectorIndex ++)
    {
        //looking for the sector
        if (DEBUG_RR)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d visit the sector info,"
                "the sector id is %d\n",
                node->getNodeTime(), node->nodeId,
                (sectorInfo + sectorIndex)->sectorId);
            fflush(stdout);
        }
        if ((sectorInfo + sectorIndex)->sectorId == sectorId)
        {
            break;
        }
    }
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d found the sector %d in my BSSECTOR INFO\n",
            node->getNodeTime(), node->nodeId,
            sectorInfo[sectorIndex].sectorId);
        fflush(stdout);
    }

    //get the bandwidth assigned to this sector
    bandwidthAssignedToSector =
        sectorInfo[sectorIndex].sectorBandwidthAllocated;

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d found the sector %d in "
            "my BSSECOT INFO with %f bandwidth\n",
            node->getNodeTime(),
            node->nodeId,
            (sectorInfo + sectorIndex)->sectorId,
            bandwidthAssignedToSector);
        fflush(stdout);
    }

    availableBandwidth =
        bandwidthAssignedToSector - sectorInfo[sectorIndex].bandwidthInUse;

    if (bandwidthRequired > availableBandwidth)
    {
        CACDecision = FALSE;
        if (DEBUG_CAC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d: not enough "
                "resource and reject the call\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }
    //do the call admission control
    else
    {
        if (nwCellularAbstractBsInfo->callAdmissionPolicy ==
            CELLULAR_ABSTRACT_CALL_ADMISSION_CONTROL_THRESHOLD_BASED)
        {
            // customized code is needed here
            CACDecision = TRUE;

            if (DEBUG_CAC && CACDecision)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d BS node %d: CC CAC "
                    "decison is accept the call\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
            if (DEBUG_CAC&&!CACDecision)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d BS node %d: CC CAC "
                    "decison is Reject the call\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }
        else if (nwCellularAbstractBsInfo->callAdmissionPolicy ==
                    CELLULAR_ABSTRACT_CALL_ADMISSION_CONTROL_NONE)
        {
            CACDecision = TRUE;
        }
        else
        {
            CACDecision = TRUE;
        }

    }
    return CACDecision;
}

///*************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsBuildImmediateAssignmentMsg
// LAYER      :: Layer3
// PURPOSE    :: BS build immediate assignment msg.
// PARAMETERS ::
// + node             : Node*        : Pointer to node.
// + msg              : Message **   : Assignment message
// + msNodeId         : NodeAddress  : Ms's nde id
// + msNodeAddress    : NodeAddress  : Ms's node address
// + sectorId         : int          : Sector Id.
// + estCause         : CellularEstCause : Connection establishment cause
// + channelRequestType: CellularAbstractChannelRequestType:
//                                       Type of channel requested
// + numChannelRequired: int         : Number of channel needed
// + transactionId    : int          : Transaction Id
// + channelAllocated : int *        : Pointer to the allocated channel Id
// + bandwidthAllocated: double      : Bandwidth allocated
// + assignementId    :  int         : Assignment Id
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractBsBuildImmediateAssignmentMsg(
        Node *node,
        Message **msg,
        NodeAddress msNodeId,
        NodeAddress msNodeAddr,
        int sectorId,
        CellularEstCause estCause,
        CellularAbstractChannelRequestType channelRequestType,
        int numChannelRequired,
        int transactionId,
        int *channelAllocated,
        double bandwidthAllocated,
        int assignmentId)
{
    CellularAbstractImmediateAssignmentPkt *assignmentPkt;
    int i;

    *msg = MESSAGE_Alloc(
                        node,
                        MAC_LAYER,
                        MAC_PROTOCOL_CELLULAR,
                        MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        *msg,
        sizeof(CellularAbstractImmediateAssignmentPkt),
        TRACE_CELLULAR);

    assignmentPkt =
        (CellularAbstractImmediateAssignmentPkt *)
        MESSAGE_ReturnPacket ((*msg));

    assignmentPkt->msNodeId = msNodeId;
    assignmentPkt->msNodeAddr = msNodeAddr;
    assignmentPkt->bsNodeId = node->nodeId;
    assignmentPkt->sectorId = sectorId;
    assignmentPkt->estCause = estCause;
    assignmentPkt->channelRequestType = channelRequestType;
    assignmentPkt->numChannelRequired = numChannelRequired;
    assignmentPkt->transactionId = transactionId;


    for (i = 0; i < CELLULAR_ABSTRACT_MAX_CHANNEL_ALLOWED_PER_APP; i ++)
    {
        assignmentPkt->channelAllocated[i] = channelAllocated[i];
    }

    assignmentPkt->bandwidthAllocated = bandwidthAllocated;
    assignmentPkt->assignmentId = assignmentId;

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW-RR: finish building the assign,"
            "emt msg with cause %d and #channel%d in sector %d "
            "with bandwidth %f with assimentId %d\n",
            node->getNodeTime(),
            node->nodeId,
            assignmentPkt->estCause,
            assignmentPkt->numChannelRequired,
            assignmentPkt->sectorId,
            assignmentPkt->bandwidthAllocated,
            assignmentPkt->assignmentId);
        fflush(stdout);
    }
}
///***********************************************************************
// /**
// FUNCTION   :: CellularAbstractBsBuildImmediateAssignmentRejectMsg
// LAYER      :: Layer3
// PURPOSE    :: BS build immediate assignment msg.
// PARAMETERS ::
// + node             : Node*       : Pointer to node.
// + msg              : Message **  : Assignment reject message
// + msNodeId         : NodeAddress : Ms's nde id
// + msNodeAddress    : NodeAddress : Ms's node address
// + sectorId         : int         : Sector Id.
// + estCause         : CellularEstCause : Connection establishment cause
// + channelRequestType: CellularAbstractChannelRequestType: Type of ch req
// + numChannelRequired: int        : Number of channel needed
// + transactionId    : int         : Transaction Id
// + channelAllocated : int *       : Pointer to the allocated channel Id
// + bandwidthAllocated: double     : Bandwidth allocated
// + rejectCause  : CellularAbstractCallRejectCauseType : Rejection cause
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractBsBuildImmediateAssignmentRejectMsg(
        Node *node,
        Message **msg,
        NodeAddress msNodeId,
        NodeAddress msNodeAddr,
        int sectorId,
        CellularEstCause estCause,
        CellularAbstractChannelRequestType channelRequestType,
        int numChannelRequired,
        int transactionId,
        int *channelAllocated,
        double bandwidthAllocated,
        CellularAbstractCallRejectCauseType rejectCause)
{

    CellularAbstractImmediateAssignmentRejectPkt *assignmentRejectPkt;
    int i;

    *msg = MESSAGE_Alloc(node,
              MAC_LAYER,
              MAC_PROTOCOL_CELLULAR,
              MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc
        (node,
        *msg,
        sizeof(CellularAbstractImmediateAssignmentRejectPkt),
        TRACE_CELLULAR);

    assignmentRejectPkt =
        (CellularAbstractImmediateAssignmentRejectPkt *)
        MESSAGE_ReturnPacket ((*msg));

    assignmentRejectPkt->msNodeId = msNodeId;
    assignmentRejectPkt->msNodeAddr = msNodeAddr;
    assignmentRejectPkt->bsNodeId = node->nodeId;
    assignmentRejectPkt->sectorId = sectorId;
    assignmentRejectPkt->estCause = estCause;
    assignmentRejectPkt->channelRequestType = channelRequestType;
    assignmentRejectPkt->numChannelRequired = numChannelRequired;
    assignmentRejectPkt->transactionId = transactionId;

    for (i = 0; i < CELLULAR_ABSTRACT_MAX_CHANNEL_ALLOWED_PER_APP; i ++)
    {
        assignmentRejectPkt->channelAllocated[i] = channelAllocated[i];
    }

    assignmentRejectPkt->bandwidthAllocated = bandwidthAllocated;
    assignmentRejectPkt->rejectCause = rejectCause;

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW-RR: finish building the ASSIGN REJ Msg"
            "with cause %d and #channel%d in sector %d with bandwidth %f\n",
            node->getNodeTime(),
            node->nodeId,
            assignmentRejectPkt->estCause,
            assignmentRejectPkt->numChannelRequired,
            assignmentRejectPkt->sectorId,
            assignmentRejectPkt->bandwidthAllocated);
        fflush(stdout);
    }
}

//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractBsBuildChannelReleaseMsg
// LAYER      :: Layer3
// PURPOSE    :: BS Build channel release msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + channelReleaseMsg: Message **        : Assignment message
// + msNodeId         : NodeAddress       : Ms's nde id
// + msNodeAddress    : NodeAddress       : Ms's node address
// + transactionId    : int               : Transaction Id
// + rrCause          : CellularAbstractRRCause : Release cause
// RETURN     :: void : NULL
// **/
///************************************************************************
static
void CellularAbstractBsBuildChannelReleaseMsg(
        Node *node,
        Message **channelReleaseMsg,
        NodeAddress msNodeId,
        NodeAddress msNodeAddr,
        int transactionId,
        CellularAbstractRRCause rrCause)
{
    CellularAbstractChannelReleasePkt *channelReleasePkt;

    *channelReleaseMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        *channelReleaseMsg,
        sizeof(CellularAbstractChannelReleasePkt),
        TRACE_CELLULAR);

    channelReleasePkt =
        (CellularAbstractChannelReleasePkt *)
        MESSAGE_ReturnPacket ((*channelReleaseMsg));

    channelReleasePkt->msNodeId = msNodeId;
    channelReleasePkt->msNodeAddr = msNodeAddr;
    channelReleasePkt->transactionId = transactionId;
    channelReleasePkt->rrCause = rrCause;
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW-RR: finish build"
            "the channel release msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}

//***************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsSendCMServiceRejectMsg
// LAYER      :: Layer3
// PURPOSE    :: BS send CM service reject msg to MS.
// PARAMETERS ::
// + node             : Node*                           : Pointer to node.
// + msNodeId         : NodeAddress                     : MS's node id
// + msNodeAddr       : NodeAddress                     : MS's node address
// + transactionId    : int                             : transaction id
// + cmServiceType    : CellularAbstractCMServiceType   : CM service Type
// + rejectCause      : CellularAbstractCallRejectCauseType : reject cause
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractBsSendCMServiceRejectMsg(
        Node* node,
        NodeAddress msNodeId,
        NodeAddress msNodeAddr,
        int transactionId,
        CellularAbstractCMServiceType cmServiceType,
        CellularAbstractCallRejectCauseType rejectCause)
{
    Message *cmServiceRejectMsg;
    CellularAbstractCMServiceRejectPkt *cmServiceRejectPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    cmServiceRejectMsg =
        MESSAGE_Alloc(node,
                      MAC_LAYER,
                      MAC_PROTOCOL_CELLULAR,
                      MSG_MAC_CELLULAR_FromNetwork);

     MESSAGE_PacketAlloc(
        node,
        cmServiceRejectMsg,
        sizeof(CellularAbstractCMServiceRejectPkt),
        TRACE_CELLULAR);

    cmServiceRejectPkt =
        (CellularAbstractCMServiceRejectPkt *)
        MESSAGE_ReturnPacket(cmServiceRejectMsg);

    cmServiceRejectPkt->msNodeId = msNodeId;
    cmServiceRejectPkt->msNodeAddr = msNodeAddr;
    cmServiceRejectPkt->transactionId = transactionId;
    cmServiceRejectPkt->cmServiceType = cmServiceType;
    cmServiceRejectPkt->rejectCause = rejectCause;

    //send to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        cmServiceRejectMsg,
        CELLULAR_PD_MM,//protocl discritptor
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_CM_SERVICE_REJECT,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        nwCellularAbstractBsInfo->controlDLChannelIndex,
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        msNodeId);

    if (DEBUG_MM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d MM: send MS a CM service reject msg \n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsSendPageRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: BS send page request msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + appId            : int               : Application Id
// + appType          : CellularAbstractApplicationType : Type of application
// + appSrcNodeId     : NodeAddress       : Source's node id
// + appDestNodeId    : NodeAddress       : Destination's node id
// + bandwidthRequired: double            : Bandwidth reuirement
// + numChannelRequired: int              : Number of channel needed
// + appDuration      : clockType         : application's duration
// + callSrcDestType  : CellularAbstractCallSrcDestType : Type of src & dest
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractBsSendPageRequestMsg(
        Node *node,
        int appId,
        CellularAbstractApplicationType appType,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        double bandwidthRequired,
        int numChannelRequired,
        clocktype appDuration,
        CellularAbstractCallSrcDestType callSrcDestType)
{
    Message *pageRequestMsg;
    CellularAbstractPageRequestPkt *pageRequestPkt;
    int pageIndex;
    BOOL found;
    CellularAbstractBsTimer3113Info timerInfo;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    pageRequestMsg =
        MESSAGE_Alloc(node,
                      MAC_LAYER,
                      MAC_PROTOCOL_CELLULAR,
                      MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        pageRequestMsg,
        sizeof(CellularAbstractPageRequestPkt),
        TRACE_CELLULAR);

    pageRequestPkt =
        (CellularAbstractPageRequestPkt *)
        MESSAGE_ReturnPacket(pageRequestMsg);

    pageRequestPkt->appId = appId;
    pageRequestPkt->appType = appType;
    pageRequestPkt->appSrcNodeId = appSrcNodeId;
    pageRequestPkt->appDestNodeId = appDestNodeId;
    pageRequestPkt->numChannelRequired = numChannelRequired;
    pageRequestPkt->bandwidthRequired = bandwidthRequired;
    pageRequestPkt->callSrcDestType = callSrcDestType;
    pageRequestPkt->appDuration = appDuration;
    nwCellularAbstractBsInfo->pageRequestId ++;

    pageRequestPkt->pageRequestId =
        nwCellularAbstractBsInfo->pageRequestId;

    pageRequestPkt->bsNodeId = node->nodeId;

    //to save some information for future use
    found = FALSE;

    for (pageIndex = 0;
        pageIndex < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS; pageIndex ++)
    {
        if (nwCellularAbstractBsInfo->bsPageRequestInfo[pageIndex].inUse ==
            FALSE)
        {
            found = TRUE;
            break;
        }
    }

    ERROR_Assert(
        found == TRUE,
        "too many active applications are paging, "
        "increase CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS\n");

    nwCellularAbstractBsInfo->bsPageRequestInfo[pageIndex].inUse = TRUE;
    nwCellularAbstractBsInfo->bsPageRequestInfo[pageIndex].numPage = 0;

    nwCellularAbstractBsInfo->bsPageRequestInfo[pageIndex].pageRequestId =
        nwCellularAbstractBsInfo->pageRequestId;

    //send a copy to to mac to ms
    nwCellularAbstractBsInfo->
        bsPageRequestInfo[pageIndex].pageRequestMsg =
        MESSAGE_Duplicate(node, pageRequestMsg);

    timerInfo.timerType = MSG_NETWORK_CELLULAR_T3113Timer;
    timerInfo.pageRequestId = nwCellularAbstractBsInfo->pageRequestId;

    //start 3113
    nwCellularAbstractBsInfo->
        bsPageRequestInfo[pageIndex].pageRequestTimer3113 =
        CellularAbstractLayer3StartTimer(
            node,
            DefaultCellularAbstractPageRequest_T3113Time,
            &timerInfo,sizeof(CellularAbstractBsTimer3113Info));

    //send to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        pageRequestMsg,
        CELLULAR_PD_RR,//protocl discritptor
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_PAGING_REQUEST_TYPE1,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        nwCellularAbstractBsInfo->controlDLChannelIndex,
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_PAGCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        appDestNodeId);

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR: sent the page request with"
            "pageId %d and start timer 3113, "
            "item is stored in index  %d inuse %d\n",
            node->getNodeTime(),
            node->nodeId,
            pageRequestPkt->pageRequestId,
            pageIndex,
            nwCellularAbstractBsInfo->bsPageRequestInfo[pageIndex].inUse);
        fflush(stdout);
    }
}

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsSendMTCallRejectIndication
// LAYER      :: Layer3
// PURPOSE    :: BS send MT call rejection indication.
// PARAMETERS ::
// + node             : Node*                           : Pointer to node.
// + pageId           : int                             : Page request id
// + rejectCause      : CellularAbstractCallRejectCauseType : Reject cause
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractBsSendMTCallRejectIndication(
        Node *node,
        int pageReqId,
        CellularAbstractCallRejectCauseType rejectCause)
{

    int pageIndex;
    BOOL found;
    CellularAbstractMTCallRejectIndication *mtCallRejectPkt;
    CellularAbstractPageRequestPkt *pageRequestPkt;
    Message *mtCallRejectMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    found = FALSE;
    for (pageIndex = 0;
        pageIndex < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS; pageIndex ++)
    {
        if (nwCellularAbstractBsInfo->
            bsPageRequestInfo[pageIndex].inUse == TRUE
            && nwCellularAbstractBsInfo->
                bsPageRequestInfo[pageIndex].pageRequestId == pageReqId)
        {
            found = TRUE;
            break;
        }
    }

    ERROR_Assert(found == TRUE, "pageid not found\n");

    //buidle the rejejct msg and send to sc
    mtCallRejectPkt =
        (CellularAbstractMTCallRejectIndication *)
        MEM_malloc(sizeof(CellularAbstractMTCallRejectIndication));

    pageRequestPkt =
        (CellularAbstractPageRequestPkt *)
        MESSAGE_ReturnPacket(nwCellularAbstractBsInfo->
            bsPageRequestInfo[pageIndex].pageRequestMsg);

    mtCallRejectPkt->appId = pageRequestPkt->appId;
    mtCallRejectPkt->appType = pageRequestPkt->appType;
    mtCallRejectPkt->appSrcNodeId = pageRequestPkt->appSrcNodeId;
    mtCallRejectPkt->appDestNodeId = pageRequestPkt->appDestNodeId;
    mtCallRejectPkt->callSrcDestType = pageRequestPkt->callSrcDestType;
    mtCallRejectPkt->rejectCause = rejectCause;

    CellularAbstractLayer3BuildMessage(
        node,
        &mtCallRejectMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        mtCallRejectPkt,
        sizeof(CellularAbstractMTCallRejectIndication));

    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &mtCallRejectMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//no meaning
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,//wired
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractBsInfo->associatedScNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        mtCallRejectMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_CALL_REJECT_INDICATION);

    MEM_free(mtCallRejectPkt);

    //cancel the timer and the infomation stored
    //in the bsPageRequestInfo[pageIndex]
    nwCellularAbstractBsInfo->bsPageRequestInfo[pageIndex].inUse = FALSE;

    if (nwCellularAbstractBsInfo->
        bsPageRequestInfo[pageIndex].pageRequestTimer3113 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractBsInfo->
                bsPageRequestInfo[pageIndex].pageRequestTimer3113);

        nwCellularAbstractBsInfo->
            bsPageRequestInfo[pageIndex].pageRequestTimer3113 = NULL;
        if (DEBUG_CAC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d MM: cancel the T3113 for "
                "pageid %d since I reject the call\n",
                node->getNodeTime(), node->nodeId, pageReqId);
            fflush(stdout);
        }
    }

    if (nwCellularAbstractBsInfo->
        bsPageRequestInfo[pageIndex].pageRequestMsg != NULL)
    {
        MESSAGE_Free(
            node,
            nwCellularAbstractBsInfo->
                bsPageRequestInfo[pageIndex].pageRequestMsg);

        nwCellularAbstractBsInfo->
            bsPageRequestInfo[pageIndex].pageRequestMsg = NULL;
    }
    if (DEBUG_CAC )
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d: CC send mt call reject msg"
            "to sc due to various cause\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleChannelRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle channel request msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractBsHandleChannelRequestMsg(Node *node, Message *msg)
{
    CellularAbstractChannelRequestPkt *chReqPkt;
    int sectorId;
    CellularEstCause estCause;
    CellularAbstractChannelRequestType channelRequestType;
    int numChannelRequired;
    double bandwidthRequired;
    int transactionId;
    int channelAllocated[CELLULAR_ABSTRACT_MAX_CHANNEL_ALLOWED_PER_APP];
    double retBandwidth;
    int numChFound;
    int i;
    BOOL cacDecision;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    //update stats
    nwCellularAbstractBsInfo->stats.numChannelRequestRcvd ++;

    chReqPkt =
        (CellularAbstractChannelRequestPkt *)MESSAGE_ReturnPacket(msg);

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR:process Channel Request"
            "from node %d in BS %d"
            "sector %d with tranId %d req %d CHs bandwidth %f\n",
            node->getNodeTime(),
            node->nodeId,
            chReqPkt->msNodeId,
            chReqPkt->bsNodeId,
            chReqPkt->sectorId,
            chReqPkt->transactionId,
            chReqPkt->numChannelRequired,
            chReqPkt->bandwidthRequired);
        fflush(stdout);
    }

    if (chReqPkt->bsNodeId != node->nodeId)
    {
        if (DEBUG_RR)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d RR:The channel request is not for me\n",
                node->getNodeTime(),
                node->nodeId);
        }
        return;
    }


    sectorId = chReqPkt->sectorId;
    numChannelRequired = chReqPkt->numChannelRequired;
    bandwidthRequired = chReqPkt->bandwidthRequired;
    estCause = chReqPkt->estCause;
    channelRequestType = chReqPkt->channelRequestType;
    transactionId = chReqPkt->transactionId;
    numChFound = 0;

    //otherwise contine
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d numChannelRequired "
            "is %d bandwidth required is  %f\n",
            node->getNodeTime(),
            node->nodeId,
            numChannelRequired,
            bandwidthRequired);
        fflush(stdout);
    }

    ERROR_Assert(numChannelRequired <=
        CELLULAR_ABSTRACT_MAX_CHANNEL_ALLOWED_PER_APP,
        "Number of channel requested for the APP is greater than"
        "CELLULAR_ABSTRACT_MAX_CHANNEL_ALLOWED_PER_APP");

    //initialize the channel allocation array
    for (i = 0; i < CELLULAR_ABSTRACT_MAX_CHANNEL_ALLOWED_PER_APP; i ++)
    {
        channelAllocated[i] = CELLULAR_ABSTRACT_INVALID_CHANNEL_ID;
    }

    if (estCause == CELLULAR_EST_CAUSE_NORMAL_CALL ||
       estCause == CELLULAR_EST_CAUSE_LOCATION_UPDATING)
    {
        if (estCause == CELLULAR_EST_CAUSE_NORMAL_CALL)
        {
            // only normal call counted CAC statistics
            nwCellularAbstractBsInfo->numAdmissionRequest ++;
        }
        cacDecision =
            CellularAbstractBsCallAdmissionControl(
                node,
                sectorId,
                numChannelRequired,
                bandwidthRequired,
                estCause);

        if (cacDecision == FALSE)
        {
            //build negtive answer
            Message *ImmediateAssignmentRejectMsg;
            retBandwidth = 0;

            CellularAbstractBsBuildImmediateAssignmentRejectMsg(
                node,
                &ImmediateAssignmentRejectMsg,
                chReqPkt->msNodeId,
                chReqPkt->msNodeAddr,
                sectorId,
                estCause,
                channelRequestType,
                numChannelRequired,
                transactionId,
                channelAllocated,
                retBandwidth,
                CELLULAR_ABSTRACT_CALL_REJECT_CAUSE_SYSTEM_BUSY);

            //assignment msg is  sent on PAGCH
            CellularAbstractLayer3SendProtocolMsgToMac(
                node,
                ImmediateAssignmentRejectMsg,
                CELLULAR_PD_RR,//protocl discritptor
            CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_IMMEDIATE_ASSIGNMENT_REJECT,
                CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
                nwCellularAbstractBsInfo->controlDLChannelIndex,
                CELLULAR_ABSTRACT_CONTROL_CHANNEL_PAGCH,
                CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only ms
                chReqPkt->msNodeId);

            //update the stats
            nwCellularAbstractBsInfo->
                stats.numImmediateAssignmentRejectSent ++;

            if (DEBUG_CAC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d channel req is "
                    "rejected by the src MS 's BS\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
            return;
        }
    }
    else if (estCause == CELLULAR_EST_CAUSE_ANSWER_TO_PAGING_TCH_CHANNEL)
    {
        int pageReqId;
        int pageIndex;
        BOOL found;

        pageReqId = chReqPkt->pageReqId;
        found = FALSE;

        for (pageIndex = 0;
            pageIndex < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS; pageIndex ++)
        {
            if (nwCellularAbstractBsInfo->
                bsPageRequestInfo[pageIndex].inUse == TRUE
                && nwCellularAbstractBsInfo->
                 bsPageRequestInfo[pageIndex].pageRequestId == pageReqId)
           {
                found = TRUE;
                break;
           }
        }
        if (found == FALSE)
        {
            if (DEBUG_RR)
            {
               printf("at %015" TYPES_64BITFMT "d Node %d: handle Ch Req for page rsp Id %d,"
                      " pageRec has been deleted, do nothing\n",
                      node->getNodeTime(), node->nodeId, pageReqId);
            }
            return;
        }
        nwCellularAbstractBsInfo->numAdmissionRequest ++;
        cacDecision = CellularAbstractBsCallAdmissionControl(
                        node,
                        sectorId,
                        numChannelRequired,
                        bandwidthRequired,
                        estCause);

        if (cacDecision == FALSE)
        {
            //build negtive answer
            Message *ImmediateAssignmentRejectMsg;
            retBandwidth = 0;
            CellularAbstractBsBuildImmediateAssignmentRejectMsg(
                node,
                &ImmediateAssignmentRejectMsg,
                chReqPkt->msNodeId,
                chReqPkt->msNodeAddr,
                sectorId,
                estCause,
                channelRequestType,
                numChannelRequired,
                transactionId,
                channelAllocated,
                retBandwidth,
                CELLULAR_ABSTRACT_CALL_REJECT_CAUSE_SYSTEM_BUSY);

            //assignment msg is  sent on PAGCH
            CellularAbstractLayer3SendProtocolMsgToMac(
                node,ImmediateAssignmentRejectMsg,
                CELLULAR_PD_RR,//protocl discritptor
            CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_IMMEDIATE_ASSIGNMENT_REJECT,
                CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
                nwCellularAbstractBsInfo->controlDLChannelIndex,
                CELLULAR_ABSTRACT_CONTROL_CHANNEL_PAGCH,
                CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only ms
                chReqPkt->msNodeId);

            //update the stats
            nwCellularAbstractBsInfo->
                stats.numImmediateAssignmentRejectSent ++;

            //TODO change the channel status back to idle

            //build and send reject indication to SC
            CellularAbstractBsSendMTCallRejectIndication(
                node,
                chReqPkt->pageReqId,
                CELLULAR_ABSTRACT_CALL_REJECT_CAUSE_SYSTEM_BUSY);

            if (DEBUG_CAC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d: channel req is rejected"
                    "by the dest MS 's BS\n",
                    node->getNodeTime(),
                    node->nodeId);
                fflush(stdout);
            }
            return;
        }
    }

    //The following commented part is used to
    //find #channel case not for bandwidth case
    #ifdef CHANNEL_ALLOCATION
    //look for numChRequired free channel in the
    //sector's allocated channel bank
    for (i = 0; i < numChannelRequired; i ++)
    {
        if (CellularAbstractFindOneIdleChannelFromChannelBank(
            node,
            sectorId,
            estCause,
            channelRequestType,
            &retChannelIndex) == TRUE)
        {

            channelAllocated[numChFound] = retChannelIndex;
            if (DEBUG_RR)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d: returned channel id is %d \n",
                    node->getNodeTime(),
                    node->nodeId,
                    channelAllocated[numChFound]);
                fflush(stdout);
            }
            numChFound ++;
        }
        else
        {
            break;
        }
    }
    #endif /* CHANNEL_ALLOCATION */

    //used when only bandwidth option is used
    numChFound = numChannelRequired;

    //Currently channel index is not used, and all the
    //application only needs one channel
    //thus index 0 is used as the the only channel
    channelAllocated[0] = 0;
    //index 0 is used

    CellularAbstractBandwidthAllocation(
        node,
        sectorId,
        estCause,
        channelRequestType,
        bandwidthRequired,
        &retBandwidth);

    //uncommented when channel index option is used. TODO
    //if (numChFound==numChannelRequired)

    //when bandwidth option is used
    if (retBandwidth >= bandwidthRequired)
    {
        //build positive assimentgnment answer
        Message *ImmediateAssignmentMsg;
        BOOL found;
        int assignmentIndex;

        nwCellularAbstractBsInfo->assignmentId ++;

        CellularAbstractBsBuildImmediateAssignmentMsg(
            node,
            &ImmediateAssignmentMsg,
            chReqPkt->msNodeId,
            chReqPkt->msNodeAddr,
            sectorId,
            estCause,
            channelRequestType,
            numChannelRequired,
            transactionId,
            channelAllocated,
            retBandwidth,
            nwCellularAbstractBsInfo->assignmentId);

        //assignment msg is  sent on PAGCH
        CellularAbstractLayer3SendProtocolMsgToMac(
            node,
            ImmediateAssignmentMsg,
            CELLULAR_PD_RR,//protocl discritptor
            CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_IMMEDIATE_ASSIGNMENT,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,//interlayer info type
            nwCellularAbstractBsInfo->controlDLChannelIndex,
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_PAGCH,//PAGCH for assignment
            CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only ms
            chReqPkt->msNodeId);

        //update the stats
        nwCellularAbstractBsInfo->stats.numImmediateAssignmentSent ++;

        //to save some information for future use
        //keep the assignment in the
        found = FALSE;
        for (assignmentIndex = 0;
            assignmentIndex < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS;
            assignmentIndex ++)
        {
            if (nwCellularAbstractBsInfo->
                bsChannelAssignmentInfo[assignmentIndex].inUse == FALSE)
            {
                found = TRUE;
                break;
            }
        }

        ERROR_Assert(
            found==TRUE,
            "too many active applications are paging,"
            "increase CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS\n");

        nwCellularAbstractBsInfo->
            bsChannelAssignmentInfo[assignmentIndex].inUse = TRUE;

        nwCellularAbstractBsInfo->
            bsChannelAssignmentInfo[assignmentIndex].assignmentId =
                nwCellularAbstractBsInfo->assignmentId;

        //start timer T3101 to waiting for ms to access
        //the channel(by sending Initial message)
        CellularAbstractBsImmediateAssignmentTimerInfo assignmentTimerInfo;

        for (i = 0; i < CELLULAR_ABSTRACT_MAX_CHANNEL_ALLOWED_PER_APP; i ++)
        {
            assignmentTimerInfo.channelAllocated[i] = channelAllocated[i];
        }
        assignmentTimerInfo.channelRequestType = channelRequestType;
        assignmentTimerInfo.estCause = estCause;
        assignmentTimerInfo.numChannelRequired = numChannelRequired;
        assignmentTimerInfo.bandwidthAllocated = retBandwidth;
        assignmentTimerInfo.sectorId = sectorId;

        assignmentTimerInfo.timerType =
            MSG_NETWORK_CELLULAR_ImmediateAssignmentTimer_T3101;

        assignmentTimerInfo.transactionId = transactionId;
        assignmentTimerInfo.srcNodeId = chReqPkt->msNodeId;

        assignmentTimerInfo.assignmentId =
            nwCellularAbstractBsInfo->assignmentId;

        nwCellularAbstractBsInfo->
            bsChannelAssignmentInfo[assignmentIndex].
            assignmentAccessTimer_T3101 =
                CellularAbstractLayer3StartTimer(
                    node,
                DefaultCellularAbstractImmediateAssignmentTimer_T3101Time,
                    &assignmentTimerInfo,
                    sizeof(CellularAbstractBsImmediateAssignmentTimerInfo));

        if (DEBUG_GENERAL)
        {
            printf("at %015" TYPES_64BITFMT "d node %d: allocated BW %f "
                "waiting for initial meesage and start T3101\n",
                node->getNodeTime(),
                node->nodeId,
                retBandwidth);
            fflush(stdout);
        }
    }
    else
    {
        //build negtive answer
        Message *ImmediateAssignmentRejectMsg;
        CellularAbstractBsBuildImmediateAssignmentRejectMsg(
            node,
            &ImmediateAssignmentRejectMsg,
            chReqPkt->msNodeId,
            chReqPkt->msNodeAddr,
            sectorId,
            estCause,
            channelRequestType,
            numChannelRequired,
            transactionId,
            channelAllocated,
            retBandwidth,
            CELLULAR_ABSTRACT_CALL_REJECT_CAUSE_SYSTEM_BUSY);

        //assignment msg is  sent on PAGCH
        CellularAbstractLayer3SendProtocolMsgToMac(
            node,
            ImmediateAssignmentRejectMsg,
            CELLULAR_PD_RR,//protocl discritptor
            CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_IMMEDIATE_ASSIGNMENT_REJECT,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,//interlayer info type
            nwCellularAbstractBsInfo->controlDLChannelIndex,
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_PAGCH,//PAGCH for assignment
            CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only ms
            chReqPkt->msNodeId);

        //update the stats
        nwCellularAbstractBsInfo->stats.numImmediateAssignmentRejectSent ++;
        //TODO: change the channel status back to
        //IDLE if the state is chnage to RESERVED
    }
}

//******************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleLocationUpdateRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle location update msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//******************************************************************
static
void CellularAbstractBsHandleLocationUpdateRequestMsg(Node *node,
                                                      Message *msg)
{
    int bsNumChannelAssigned;
    CellularAbstractChannelDescription *bsChannelBank;
    int assignedChannelIndex;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    CellularAbstractNetowrkToMacMsgInfo *inMsgInfo;
    Message *outMsg;
    CellularAbstractLocationUpdateRequestPkt *inLocUpdatePkt;

    int itemIndex;
    BOOL found;
    int assignmentIndex;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d MM: receive a locatio update request"
            "and ready to forward to MSC/VLR  %d\n",
            node->getNodeTime(), node->nodeId,
            nwCellularAbstractBsInfo->associatedScNodeId);
        fflush(stdout);
    }


    inMsgInfo =
        (CellularAbstractNetowrkToMacMsgInfo *)MESSAGE_ReturnInfo(msg);

    inLocUpdatePkt =
        (CellularAbstractLocationUpdateRequestPkt *)
        MESSAGE_ReturnPacket(msg);

    //updatet the channel status to in use
    assignedChannelIndex = inMsgInfo->channelIndex;
    bsChannelBank = nwCellularAbstractBsInfo->bsChannelBank;
    bsNumChannelAssigned = nwCellularAbstractBsInfo->numChannelAssigned;

    //Look for the assignment Info
    found = FALSE;
    for (assignmentIndex = 0;
        assignmentIndex < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS;
        assignmentIndex ++)
    {
        if (nwCellularAbstractBsInfo->
                bsChannelAssignmentInfo[assignmentIndex].inUse == TRUE &&
            nwCellularAbstractBsInfo->
                bsChannelAssignmentInfo[assignmentIndex].assignmentId ==
            inLocUpdatePkt->assignmentId)
        {
            found=TRUE;
            break;
        }
    }

    ERROR_Assert(
        found==TRUE,
        "the assignmentIs with the loc update req"
        "is not found in the record");

    //create a AppInfo for this transaction first
    CellularAbstractBsImmediateAssignmentTimerInfo *timerInfo;

    ERROR_Assert(
        nwCellularAbstractBsInfo->
            bsChannelAssignmentInfo[assignmentIndex].
            assignmentAccessTimer_T3101 != NULL,

        "assignInfo is inUse but T3101 oes not exist");

    timerInfo =
        (CellularAbstractBsImmediateAssignmentTimerInfo *)
        MESSAGE_ReturnInfo(
        (nwCellularAbstractBsInfo->bsChannelAssignmentInfo[assignmentIndex].
            assignmentAccessTimer_T3101));

    CellularAbstractBsCreateAppInfoItem(
        node,
        0,
        timerInfo->srcNodeId,
        timerInfo->sectorId,
        timerInfo->bandwidthAllocated,
        &itemIndex);

    //find the assocate 3101 timer in the transation info and cancel it.
    if (nwCellularAbstractBsInfo->
        bsChannelAssignmentInfo[assignmentIndex].
            assignmentAccessTimer_T3101 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,

            nwCellularAbstractBsInfo->
                bsChannelAssignmentInfo[assignmentIndex].
                assignmentAccessTimer_T3101);

        nwCellularAbstractBsInfo->
            bsChannelAssignmentInfo[assignmentIndex].
            assignmentAccessTimer_T3101 = NULL;

        if (DEBUG_GENERAL)
        {
            printf(
                "BS Node %d MM: cancel the T3101 since receive the inital"
                "message loc update req for assignId %d\n",
                node->nodeId,

                nwCellularAbstractBsInfo->
                    bsChannelAssignmentInfo[assignmentIndex].assignmentId);
            fflush(stdout);
        }
    }

    //reset the assignmentInfo
    nwCellularAbstractBsInfo->
        bsChannelAssignmentInfo[assignmentIndex].inUse = FALSE;

    //the following commented one id for channel id case
    #ifdef CHANNEL_ALLOCATION
    //look for the channel in the channel bank
    for (j = 0; j < bsNumChannelAssigned;j ++)
    {
        if ((bsChannelBank+j)->channelIndex == assignedChannelIndex)
        {
            break;
        }
    }

    if ((bsChannelBank + j)->channelStatus ==
        CELLULAR_ABSTRACT_CHANNEL_STATUS_TENTATIVE)
    {
        (bsChannelBank + j)->channelStatus =
            CELLULAR_ABSTRACT_CHANNEL_STATUS_INUSE_GENERAL;

        (bsChannelBank +j)->isChannelInUse= TRUE;
        //update the statistics to reflect the resource usage

    }

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR: change the channel %d "
            "from TENTATIVE to IDLE\n",
            node->getNodeTime(),
            node->nodeId,
            (bsChannelBank+j)->channelIndex);
        fflush(stdout);
    }
    #endif//CHANNEL ALLOCATION

    //statistics
    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d MM: receive a locatio update request"
            "from %d on channel %d and ready to forward to MSC/VLR\n",
            node->getNodeTime(),
            node->nodeId,
            inLocUpdatePkt->msNodeId,
            inMsgInfo->channelIndex);
        fflush(stdout);
    }

    //forward the msg to sc
    CellularAbstractLayer3BuildMessage(
        node,
        &outMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        inLocUpdatePkt,
        sizeof(CellularAbstractLocationUpdateRequestPkt));

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &outMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0, //sccp id?
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractBsInfo->associatedScNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        outMsg,
        CELLULAR_PD_MM,
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_LOCATION_UPDATE_REQUEST);
}//CellularAbstractBsHandleLocationUpdateRequestMsg

//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleClearCommandMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle clear command msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractBsHandleClearCommandMsg(Node *node, Message *msg)
{
    CellularAbstractGenericTimerInfo timerInfo;
    CellularAbstractClearCommandPkt *clearCmdPkt;
    Message *channelReleaseMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR: Handle the clear command\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //TODO: start 3109

    //update stats
    nwCellularAbstractBsInfo->stats.numClearCommandRcvd ++;

    clearCmdPkt = (CellularAbstractClearCommandPkt *)
                    MESSAGE_ReturnPacket(msg);

    //build and send Channel Release to MS
    CellularAbstractBsBuildChannelReleaseMsg(
        node,
        &channelReleaseMsg,
        clearCmdPkt->msNodeId,
        clearCmdPkt->msNodeAddr,
        clearCmdPkt->transactionId,
        clearCmdPkt->rrCause);

    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        channelReleaseMsg,
        CELLULAR_PD_RR,//protocl discritptor
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_CHANNEL_RELEASE,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,//interlayer info type
        0,//used for implementation purpose, representing all the TCH
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,//TCH
        CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only ms
        clearCmdPkt->msNodeId);

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR: Handle the clear command to MS %d\n",
            node->getNodeTime(),
            node->nodeId,
            clearCmdPkt->msNodeId);
        fflush(stdout);
    }

    //update stats
    nwCellularAbstractBsInfo->stats.numChannelReleaseSent ++;

    //start 3111
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T3111Timer;
    timerInfo.transactionId = clearCmdPkt->transactionId;
    timerInfo.srcNodeId = clearCmdPkt->msNodeId;
    CellularAbstractLayer3StartTimer(
        node,
        DefaultCellularAbstractBsChannelReleaseTimer_T3111Time,
        &timerInfo,
        sizeof(CellularAbstractGenericTimerInfo));
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandlePagingMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle paging msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractBsHandlePagingMsg(Node *node, Message *msg)
{
    CellularAbstractPagingPkt *pagingPkt;
    int                             appId;
    CellularAbstractApplicationType appType;
    NodeAddress                     appSrcNodeId;
    NodeAddress                     appDestNodeId;
    double                          bandwidthRequired;
    int                             numChannelRequired;
    clocktype                       appDuration;
    CellularAbstractCallSrcDestType callSrcDestType;
    BOOL serviceSupported;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR: rcvd a paging from SC\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    pagingPkt = (CellularAbstractPagingPkt *)MESSAGE_ReturnPacket(msg);

    appId = pagingPkt->appId;
    appType = pagingPkt->appType;
    appSrcNodeId = pagingPkt->appSrcNodeId;
    appDestNodeId = pagingPkt->appDestNodeId;
    numChannelRequired = pagingPkt->numChannelRequired;
    bandwidthRequired = pagingPkt->bandwidthRequired;
    callSrcDestType = pagingPkt->callSrcDestType;
    appDuration = pagingPkt->appDuration;

    //update the stas
    nwCellularAbstractBsInfo->stats.numPagingRcvd ++;

    serviceSupported = FALSE;
    if ((appType == CELLULAR_ABSTRACT_VOICE_PHONE) &&
        (nwCellularAbstractBsInfo->
            bsServiceSupport[CELLULAR_ABSTRACT_VOICE] == TRUE))
    {
        serviceSupported = TRUE;
    }
    else if (((appType == CELLULAR_ABSTRACT_VIDEO_PHONE) ||
            (appType == CELLULAR_ABSTRACT_TEXT_MAIL) ||
            (appType == CELLULAR_ABSTRACT_PICTURE_MAIL) ||
            (appType == CELLULAR_ABSTRACT_ANIMATION_MAIL) ||
            (appType == CELLULAR_ABSTRACT_WEB)) &&
            (nwCellularAbstractBsInfo->
            bsServiceSupport[CELLULAR_ABSTRACT_DATA] == TRUE))
    {
        serviceSupported = TRUE;
    }

    if (serviceSupported == TRUE)
    {
        if (DEBUG_RR || DEBUG_PROGRESS)
        {
            char clockStr[MAX_STRING_LENGTH];
            ctoa(node->getNodeTime(), clockStr);
            printf(
                "at %015" TYPES_64BITFMT "d BS node %d RR: rcvd a paging from SC"
                "and ready to build and send page request to %d\n",
                node->getNodeTime(),
                node->nodeId,
                appDestNodeId);
            fflush(stdout);
        }

        //build and send a page request to the MS dest in this cell.
        CellularAbstractBsSendPageRequestMsg(
            node,
            appId,
            appType,
            appSrcNodeId,
            appDestNodeId,
            bandwidthRequired,
            numChannelRequired,
            appDuration,
            callSrcDestType);

        //update stats
        nwCellularAbstractBsInfo->stats.numPageRequestSent ++;

    }
    else
    {
        //send MTCallRejectMsg to SC due to cause unsupported service
        Message *mtCallRejectMsg;
        CellularAbstractMTCallRejectIndication *mtCallRejectPkt;

        mtCallRejectPkt =
            (CellularAbstractMTCallRejectIndication *)
            MEM_malloc(sizeof(CellularAbstractMTCallRejectIndication));

        mtCallRejectPkt->appId = appId;
        mtCallRejectPkt->appType = appType;
        mtCallRejectPkt->appSrcNodeId = appSrcNodeId;
        mtCallRejectPkt->appDestNodeId = appDestNodeId;
        mtCallRejectPkt->callSrcDestType = callSrcDestType;

        mtCallRejectPkt->rejectCause =
            CELLULAR_ABSTRACT_CALL_REJECT_CAUSE_UNSUPPORTED_SERVICE;

        CellularAbstractLayer3BuildMessage(
            node,
            &mtCallRejectMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            mtCallRejectPkt,
            sizeof(CellularAbstractMTCallRejectIndication));

        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &mtCallRejectMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//no meaning
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,//wired
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractBsInfo->associatedScNodeId);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            mtCallRejectMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_CALL_REJECT_INDICATION);

        MEM_free(mtCallRejectPkt);
        if (DEBUG_MM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d BS node %d RR: rcvd a paging from SC and "
                "reply with MTreject due to unsupported service to %d\n",
                node->getNodeTime(),
                node->nodeId,
                nwCellularAbstractBsInfo->associatedScNodeId);
            fflush(stdout);
        }
    }
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleCMServiceRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle CM serivce msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractBsHandleCMServiceRequestMsg(Node *node, Message *msg)
{
    CellularAbstractCMServiceRequestPkt *cmServiceReqPkt;
    NodeAddress msNodeId;
    NodeAddress msNodeAddr;
    int transactionId;
    CellularAbstractCMServiceType cmServiceType;
    int itemIndex;
    Message *outMsg;
    int assignmentIndex;
    BOOL found;
    BOOL cmServiceAccepted;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    if (DEBUG_MM||DEBUG_PROGRESS)
    {
        printf("at %015" TYPES_64BITFMT "d node %d MM: Handle CM Service Req\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //update stats
    nwCellularAbstractBsInfo->stats.numCmServiceRequestRcvd ++;

    cmServiceReqPkt =
        (CellularAbstractCMServiceRequestPkt *)MESSAGE_ReturnPacket(msg);

    msNodeId = cmServiceReqPkt->msNodeId;
    msNodeAddr = cmServiceReqPkt->msNodeAddr;
    transactionId = cmServiceReqPkt->transactionId;
    cmServiceType = cmServiceReqPkt->cmServiceType;

    //Look for the assignment Info
    found = FALSE;
    for (assignmentIndex = 0;
        assignmentIndex < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS;
        assignmentIndex ++)
    {
        if (nwCellularAbstractBsInfo->
                bsChannelAssignmentInfo[assignmentIndex].inUse == TRUE &&
            nwCellularAbstractBsInfo->
                bsChannelAssignmentInfo[assignmentIndex].assignmentId ==
                    cmServiceReqPkt->assignmentId)
        {
            found = TRUE;
            break;
        }
    }

    ERROR_Assert(
        found==TRUE,
        "the assignmentIs with the CM service request"
        "is not found in the record");

    //create a AppInfo for this transaction first
    CellularAbstractBsImmediateAssignmentTimerInfo *timerInfo;

    ERROR_Assert(
        nwCellularAbstractBsInfo->
            bsChannelAssignmentInfo[assignmentIndex].
            assignmentAccessTimer_T3101 != NULL,
        "assignInfo is inUse but T3101 oes not exist");

    timerInfo =
        (CellularAbstractBsImmediateAssignmentTimerInfo *)
        MESSAGE_ReturnInfo((nwCellularAbstractBsInfo->
            bsChannelAssignmentInfo[assignmentIndex].
                assignmentAccessTimer_T3101));

    CellularAbstractBsCreateAppInfoItem(
        node,
        cmServiceReqPkt->transactionId,
        timerInfo->srcNodeId,
        timerInfo->sectorId,
        timerInfo->bandwidthAllocated,
        &itemIndex);

    //find the assocate 3101 timer in the transation info and cancel it.
    if (nwCellularAbstractBsInfo->
        bsChannelAssignmentInfo[assignmentIndex].
        assignmentAccessTimer_T3101 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractBsInfo->
                bsChannelAssignmentInfo[assignmentIndex].
                    assignmentAccessTimer_T3101);

        nwCellularAbstractBsInfo->
            bsChannelAssignmentInfo[assignmentIndex].
                assignmentAccessTimer_T3101 = NULL;

        if (DEBUG_MM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d MM: cancel the T3101 since "
                "I receive the initial CM message for assignId %d\n",
                node->getNodeTime(),
                node->nodeId,
                nwCellularAbstractBsInfo->
                    bsChannelAssignmentInfo[assignmentIndex].
                    assignmentId);
            fflush(stdout);
        }
    }

    //reset the assignmentInfo
    nwCellularAbstractBsInfo->
        bsChannelAssignmentInfo[assignmentIndex].inUse = FALSE;

    cmServiceAccepted=FALSE;
    if ((cmServiceType ==
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL_ESTABLISHMENT) &&
        (nwCellularAbstractBsInfo->
            bsServiceSupport[CELLULAR_ABSTRACT_VOICE] == TRUE))
    {
        cmServiceAccepted = TRUE;
    }
    else if ((cmServiceType ==
                CELLULAR_ABSTRACT_PACKET_MODE_CONNECTION_ESTABLISHMENT) &&
             (nwCellularAbstractBsInfo->
                bsServiceSupport[CELLULAR_ABSTRACT_DATA] == TRUE))
    {
        cmServiceAccepted = TRUE;
    }

    if (cmServiceAccepted == TRUE )
    {
        //forward the msg to sc
        CellularAbstractLayer3BuildMessage(
            node,
            &outMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            cmServiceReqPkt,
            sizeof(CellularAbstractCMServiceRequestPkt));

        //add wired info
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &outMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractBsInfo->associatedScNodeId);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            outMsg,
            CELLULAR_PD_MM,
            CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_CM_SERVICE_REQUEST);

        nwCellularAbstractBsInfo->stats.numCmServiceRequestFwd ++;
    }
    else //the Cm service is not supported by this BS
    {
        Message *channelReleaseMsg;
        CellularAbstractGenericTimerInfo timerInfo;

        // send ms a CM service reject msg and send ms channel release
        CellularAbstractBsSendCMServiceRejectMsg(
            node,
            msNodeId,
            msNodeAddr,
            transactionId,
            cmServiceType,
            CELLULAR_ABSTRACT_CALL_REJECT_CAUSE_UNSUPPORTED_SERVICE);

        //update stats
        nwCellularAbstractBsInfo->stats.numCmServiceRejectByBsSent ++;

        //build and send Channel Release to MS
        CellularAbstractBsBuildChannelReleaseMsg(
            node,
            &channelReleaseMsg,
            msNodeId,
            msNodeAddr,
            transactionId,
            CELLULAR_ABSTRACT_NORMAL_EVENT);

        CellularAbstractLayer3SendProtocolMsgToMac(
            node,
            channelReleaseMsg,
            CELLULAR_PD_RR,//protocl discritptor
            CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_CHANNEL_RELEASE,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,//interlayer info type
            0,//used for implementation purpose, representing all the TCH
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,//TCH
            CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only ms
            msNodeId);

        if (DEBUG_RR)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d RR: send channel release msg to MS %d"
                "since cm service is rejected by BS \n",
                node->getNodeTime(),
                node->nodeId,
                msNodeId);
            fflush(stdout);
        }

        //update stats
        nwCellularAbstractBsInfo->stats.numChannelReleaseSent ++;

        //start 3111
        timerInfo.timerType = MSG_NETWORK_CELLULAR_T3111Timer;
        timerInfo.transactionId = transactionId;
        timerInfo.srcNodeId = msNodeId;
        CellularAbstractLayer3StartTimer(
            node,
            DefaultCellularAbstractBsChannelReleaseTimer_T3111Time,
            &timerInfo,
            sizeof(CellularAbstractGenericTimerInfo));
    }
}
//********************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleCallSetupMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Call Setup msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractBsHandleCallSetupMsg(Node *node, Message *msg)
{
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d RR process CallSetup msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    int itemIndex;
    Message *outMsg;
    CellularAbstractCallSetupPkt *callSetupPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    callSetupPkt =
        (CellularAbstractCallSetupPkt *)MESSAGE_ReturnPacket(msg);

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR process CallSetup msg for call"
            "src %d dest %d srcdestType %d\n",
            node->getNodeTime(),
            node->nodeId,
            callSetupPkt->appSrcNodeId,
            callSetupPkt->appDestNodeId,
            callSetupPkt->callSrcDestType);
        fflush(stdout);
    }
    if (callSetupPkt->callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)//MO Call
    {
        //update the stats
        nwCellularAbstractBsInfo->stats.numMOCallSetupRcvd ++;

        //look for the item in the appInfo
        ERROR_Assert(
            CellularAbstractBsLookForAppInfoItem(
                node,
                callSetupPkt->transactionId,
                callSetupPkt->appSrcNodeId,
                &itemIndex) == TRUE,
            "cannot find the appInfo for this call setup msg");

        // the appInfo was created on behalf the src

        //updade the appInfo at BS with the call related information
        nwCellularAbstractBsInfo->bsAppInfo[itemIndex].appId =
            callSetupPkt->appId;

        nwCellularAbstractBsInfo->bsAppInfo[itemIndex].applicationType =
            callSetupPkt->appType;

        nwCellularAbstractBsInfo->bsAppInfo[itemIndex].callSrcDestType =
            callSetupPkt->callSrcDestType;

        nwCellularAbstractBsInfo->bsAppInfo[itemIndex].destMsNodeId =
            callSetupPkt->appDestNodeId;

        nwCellularAbstractBsInfo->bsAppInfo[itemIndex].srcMsNodeId =
            callSetupPkt->appSrcNodeId;

        //forward to SC
        CellularAbstractLayer3BuildMessage(
            node,
            &outMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            callSetupPkt,
            sizeof(CellularAbstractCallSetupPkt));

        //add wired info
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &outMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractBsInfo->associatedScNodeId);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            outMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_SETUP);

        //update stats
        nwCellularAbstractBsInfo->stats.numMOCallSetupFwd ++;
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC: MO forward call setup to SC %d\n",
                node->getNodeTime(), node->nodeId,
                nwCellularAbstractBsInfo->associatedScNodeId);
            fflush(stdout);
        }
    }
    else if (callSetupPkt->callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)//MT call
    {
        //look for the item in the appInfo
        ERROR_Assert(
            CellularAbstractBsLookForAppInfoItem(
                node,
                callSetupPkt->transactionId,
                callSetupPkt->appDestNodeId,
                &itemIndex) == TRUE,
            "cannot find the appInfo for this call setup msg");

        //the item was create on behalf  the dest

        //updade the appInfo at BS with the call related information
        nwCellularAbstractBsInfo->bsAppInfo[itemIndex].appId =
            callSetupPkt->appId;

        nwCellularAbstractBsInfo->bsAppInfo[itemIndex].applicationType =
            callSetupPkt->appType;

        nwCellularAbstractBsInfo->bsAppInfo[itemIndex].callSrcDestType =
            callSetupPkt->callSrcDestType;

        nwCellularAbstractBsInfo->bsAppInfo[itemIndex].destMsNodeId =
            callSetupPkt->appDestNodeId;

        nwCellularAbstractBsInfo->bsAppInfo[itemIndex].srcMsNodeId =
            callSetupPkt->appSrcNodeId;

        //forward msg to AppDest over wireless link
        CellularAbstractBsForwardMsgToMs(
            node,
            msg,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_SETUP);

        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC: MT call "
                "forward call setup to dest %d\n",
                node->getNodeTime(),
                node->nodeId,
                callSetupPkt->appDestNodeId);
            fflush(stdout);
        }
    }
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleActivatePDPContextRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Activate PDP Context Request.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractBsHandleActivatePDPContextRequestMsg(Node *node,
                                                          Message *msg)
{
    if (DEBUG_SM || DEBUG_PROGRESS)
    {
        char clockStr[MAX_STRING_LENGTH];
        ctoa(node->getNodeTime(), clockStr);
        printf(
            "at %015" TYPES_64BITFMT "d node %d SM process ActivatePDPContextRequest msg\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

    int itemIndex = 0;
    Message *outMsg;
    CellularAbstractActivatePDPContextRequestPkt *APCReqPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    APCReqPkt =
        (CellularAbstractActivatePDPContextRequestPkt *)
        MESSAGE_ReturnPacket(msg);

    //TODO update the stats
    //rcvd stat

    //look for the item in the appInfo
    if (APCReqPkt->callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        ERROR_Assert(
            CellularAbstractBsLookForAppInfoItem(
                node,
                APCReqPkt->transactionId,
                APCReqPkt->appSrcNodeId,
                &itemIndex) == TRUE,
            "canot find the appInfo for this activate PDP request msg");
    }
    else if (APCReqPkt->callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        ERROR_Assert(
            CellularAbstractBsLookForAppInfoItem(
                node,
                APCReqPkt->transactionId,
                APCReqPkt->appDestNodeId,
                &itemIndex) == TRUE,
            "cannot find the appInfo for this activate PDP request msg");
    }

    //updade the appInfo at BS with the call related information
    nwCellularAbstractBsInfo->bsAppInfo[itemIndex].appId =
        APCReqPkt->appId;

    nwCellularAbstractBsInfo->bsAppInfo[itemIndex].applicationType =
        APCReqPkt->appType;

    nwCellularAbstractBsInfo->bsAppInfo[itemIndex].callSrcDestType =
        APCReqPkt->callSrcDestType;

    nwCellularAbstractBsInfo->bsAppInfo[itemIndex].destMsNodeId =
        APCReqPkt->appDestNodeId;

    nwCellularAbstractBsInfo->bsAppInfo[itemIndex].srcMsNodeId =
        APCReqPkt->appSrcNodeId;

    //forward to SC
    //forward the msg to sc
    CellularAbstractLayer3BuildMessage(
        node,
        &outMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        APCReqPkt,
        sizeof(CellularAbstractActivatePDPContextRequestPkt));

    //add info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &outMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractBsInfo->associatedScNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        outMsg,
        CELLULAR_PD_SM,
        CELLULAR_ABSTRACT_SM_ACTIVATE_PDP_CONTEXT_REQUEST);
    //update stats
    //fwd stat
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandlePageResponseMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle page response msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractBsHandlePageResponseMsg(Node *node, Message *msg)
{
    CellularAbstractPageResponsePkt *pageResPkt;
    Message *outMsg;
    int itemIndex;
    int pageIndex;
    BOOL found;
    int assignmentIndex;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;
    pageResPkt =
        (CellularAbstractPageResponsePkt *)MESSAGE_ReturnPacket(msg);
    if (DEBUG_RR || DEBUG_CC || DEBUG_SM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d rcvd page response with "
        "pageId %d for call src %d to dest %d\n",
            node->getNodeTime(),
            node->nodeId,
            pageResPkt->pageRequestId,
            pageResPkt->appSrcNodeId,
            pageResPkt->appDestNodeId);
        fflush(stdout);
    }
    //Look for the assignment Info
    found = FALSE;
    for (assignmentIndex = 0;
        assignmentIndex < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS;
        assignmentIndex ++)
    {
        if (nwCellularAbstractBsInfo->
                bsChannelAssignmentInfo[assignmentIndex].inUse == TRUE &&
            nwCellularAbstractBsInfo->
                bsChannelAssignmentInfo[assignmentIndex].assignmentId ==
            pageResPkt->assignmentId)
        {
            found = TRUE;
            break;
        }
    }
    ERROR_Assert(
        found == TRUE,
        "the assignmentId with the page response request"
        "is not found in the record");

    CellularAbstractBsImmediateAssignmentTimerInfo *timerInfo;
    ERROR_Assert(
        nwCellularAbstractBsInfo->
            bsChannelAssignmentInfo[assignmentIndex].
            assignmentAccessTimer_T3101 != NULL,

        "assignInfo is inUse but T3101 does not exist");

    timerInfo =
        (CellularAbstractBsImmediateAssignmentTimerInfo *)
        MESSAGE_ReturnInfo((nwCellularAbstractBsInfo->
            bsChannelAssignmentInfo[assignmentIndex].
                assignmentAccessTimer_T3101));

    //create a AppInfo for this transaction first
    CellularAbstractBsCreateAppInfoItem(
        node,
        pageResPkt->transactionId,
        timerInfo->srcNodeId,
        timerInfo->sectorId,
        timerInfo->bandwidthAllocated,
        &itemIndex);

    //find the assocate 3101 timer in the transation info and cancel it.
    if (nwCellularAbstractBsInfo->
        bsChannelAssignmentInfo[assignmentIndex].
        assignmentAccessTimer_T3101 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractBsInfo->
                bsChannelAssignmentInfo[assignmentIndex].
                    assignmentAccessTimer_T3101);

        nwCellularAbstractBsInfo->
            bsChannelAssignmentInfo[assignmentIndex].
                assignmentAccessTimer_T3101 = NULL;
        if (DEBUG_MM  )
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d MM: cancel the T3101 since I"
                "receive the initial page response for assignId %d\n",
                node->getNodeTime(),
                node->nodeId,
                nwCellularAbstractBsInfo->
                    bsChannelAssignmentInfo[assignmentIndex].assignmentId);
            fflush(stdout);
        }
    }

    //reset the assignmentInfo
    nwCellularAbstractBsInfo->
        bsChannelAssignmentInfo[assignmentIndex].inUse = FALSE;

    //find the page Info
    found = FALSE;
    for (pageIndex = 0;
        pageIndex < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS; pageIndex ++)
    {
        if (nwCellularAbstractBsInfo->
            bsPageRequestInfo[pageIndex].inUse == TRUE
            && nwCellularAbstractBsInfo->
                bsPageRequestInfo[pageIndex].pageRequestId ==
                pageResPkt->pageRequestId)
        {
            found = TRUE;
            break;
        }
    }

    if (found == FALSE)
    {
        CellularAbstractGenericTimerInfo timerInfo;
        Message *channelReleaseMsg;

        //build and send Channel Release to MS
        CellularAbstractBsBuildChannelReleaseMsg(
            node,
            &channelReleaseMsg,
            pageResPkt->appDestNodeId,
            pageResPkt->appDestNodeId, //TODO:need to give the right value
            pageResPkt->transactionId,
            CELLULAR_ABSTRACT_ABNORMAL_RELEASE);

        CellularAbstractLayer3SendProtocolMsgToMac(
            node,
            channelReleaseMsg,
            CELLULAR_PD_RR,//protocl discritptor
            CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_CHANNEL_RELEASE,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,//interlayer info type
            0,//used for implementation purpose, representing all the TCH
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,//TCH
            CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only ms
            pageResPkt->appDestNodeId);

        //update stats
        nwCellularAbstractBsInfo->stats.numChannelReleaseSent ++;

        //start 3111
        timerInfo.timerType = MSG_NETWORK_CELLULAR_T3111Timer;
        timerInfo.transactionId = pageResPkt->transactionId;
        timerInfo.srcNodeId = pageResPkt->appDestNodeId;
        CellularAbstractLayer3StartTimer(
            node,
            DefaultCellularAbstractBsChannelReleaseTimer_T3111Time,
            &timerInfo,
            sizeof(CellularAbstractGenericTimerInfo));
        return;
    }

    nwCellularAbstractBsInfo->bsPageRequestInfo[pageIndex].inUse = FALSE;
    if (nwCellularAbstractBsInfo->
        bsPageRequestInfo[pageIndex].pageRequestTimer3113 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractBsInfo->
                bsPageRequestInfo[pageIndex].pageRequestTimer3113);

        nwCellularAbstractBsInfo->
            bsPageRequestInfo[pageIndex].pageRequestTimer3113 = NULL;

        if (DEBUG_MM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d MM: cancel the T3113 "
                "for Msnode %d transaction"
                "id %d since I receive the initial page response\n",
                node->getNodeTime(),
                node->nodeId,
                pageResPkt->appDestNodeId,
                pageResPkt->transactionId);
            fflush(stdout);
        }
    }

    if (nwCellularAbstractBsInfo->
        bsPageRequestInfo[pageIndex].pageRequestMsg != NULL)
    {
        MESSAGE_Free(
            node,
            nwCellularAbstractBsInfo->
                bsPageRequestInfo[pageIndex].pageRequestMsg);

        nwCellularAbstractBsInfo->
            bsPageRequestInfo[pageIndex].pageRequestMsg = NULL;
    }
    //update stats
    nwCellularAbstractBsInfo->stats.numPageResponseRcvd ++;

    //forward to SC
    //build msg
    CellularAbstractLayer3BuildMessage(
        node,
        &outMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        pageResPkt,
        sizeof(CellularAbstractPageResponsePkt));

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &outMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractBsInfo->associatedScNodeId);

    CellularAbstractSendMsgOverNonCellularLink(
        node,
        outMsg,
        CELLULAR_PD_MM,
        CELLULAR_ABSTRACT_PAGING_RESPONSE);

    //update stats
    nwCellularAbstractBsInfo->stats.numPageResponseFwd ++;
}
//*******************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleCallConfirmMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle call confirm msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//******************************************************************
static
void CellularAbstractBsHandleCallConfirmMsg(Node *node, Message *msg)
{
    Message *outMsg;
    CellularAbstractCallConfirmPkt *callConfirmPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    callConfirmPkt =
        (CellularAbstractCallConfirmPkt *)
        MESSAGE_ReturnPacket (msg);

    //build msg
    CellularAbstractLayer3BuildMessage(
        node,
        &outMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        callConfirmPkt,
        sizeof(CellularAbstractCallConfirmPkt));

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &outMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractBsInfo->associatedScNodeId);

    CellularAbstractSendMsgOverNonCellularLink(
        node,
        outMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CALL_CONFIRMED);

    //update stats
    nwCellularAbstractBsInfo->stats.numMTCallConfirmRcvd ++;
    nwCellularAbstractBsInfo->stats.numMTCallConfirmFwd ++;
    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d CC:forward MT Call Confimr to SC\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleCallAlertingMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle call alerting msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractBsHandleCallAlertingMsg(Node *node,Message *msg)
{
    CellularAbstractCallAlertingPkt *callAlertingPkt;
    CellularAbstractCallSrcDestType callSrcDestType;

    Message *outMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;
    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d Node %d CC:RCVD a CALL ALERTING\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    callAlertingPkt =
        (CellularAbstractCallAlertingPkt *)MESSAGE_ReturnPacket(msg);

    callSrcDestType = callAlertingPkt->callSrcDestType;
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        //forward to sc
        //build msg
        CellularAbstractLayer3BuildMessage(
            node,
            &outMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            callAlertingPkt,
            sizeof(CellularAbstractCallAlertingPkt));

        //add wired info
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &outMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractBsInfo->associatedScNodeId);

        //send  to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            outMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_ALERTING);

        //update stats
        nwCellularAbstractBsInfo->stats.numMTCallAlertingRcvd ++;
        nwCellularAbstractBsInfo->stats.numMTCallAlertingFwd ++;

        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC:forward MT Call Alerting to SC\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }
    else if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        //update stats
        nwCellularAbstractBsInfo->stats.numMOCallAlertingRcvd ++;
        CellularAbstractBsForwardMsgToMs(
            node,
            msg,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_ALERTING);
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC:ready to forward "
                "MO Call Alerting to MS\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }

}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleCallConnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle call connect msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractBsHandleCallConnectMsg(Node *node,Message *msg)
{
    CellularAbstractCallConnectPkt *callConnectPkt;
    CellularAbstractCallSrcDestType callSrcDestType;
    Message *outMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;
    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d CC:RCVD a CALL CONNECT\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

    callConnectPkt =
        (CellularAbstractCallConnectPkt *)MESSAGE_ReturnPacket(msg);
    callSrcDestType =
        callConnectPkt->callSrcDestType;

    if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        //forward to sc
        //build msg
        CellularAbstractLayer3BuildMessage(
            node,
            &outMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            callConnectPkt,
            sizeof(CellularAbstractCallConnectPkt));

        //add wired info
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &outMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractBsInfo->associatedScNodeId);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            outMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT);

        //update stats
        nwCellularAbstractBsInfo->stats.numMTCallConnectRcvd ++;
        nwCellularAbstractBsInfo->stats.numMTCallConnectFwd ++;
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC:forward MT Call Connect to SC\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }
    else if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        //forward to ms
        //update stats
        nwCellularAbstractBsInfo->stats.numMOCallConnectAckRcvd ++;
        CellularAbstractBsForwardMsgToMs(
            node,
            msg,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT);
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC:ready to forward "
                "MO Call Connect to MS\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }

}
//******************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleCallConnectAckMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle call connect ack msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*******************************************************************
static
void CellularAbstractBsHandleCallConnectAckMsg(Node *node, Message *msg)
{
    CellularAbstractCallConnectAckPkt *callConnectAckPkt;
    CellularAbstractCallSrcDestType callSrcDestType;
    Message *outMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData=
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;
    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;
    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d CC:RCVD a CALL CONNECT ACK\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

    callConnectAckPkt =
        (CellularAbstractCallConnectAckPkt *)MESSAGE_ReturnPacket(msg);
    callSrcDestType =
        callConnectAckPkt->callSrcDestType;
    if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        //update stats
        nwCellularAbstractBsInfo->stats.numMTCallConnectAckRcvd ++;
        //forward to ms
        CellularAbstractBsForwardMsgToMs(
            node,
            msg,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT_ACKNOWLEDGE);
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC:ready to forward "
                "MT Call Connect ack to MS\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }
    else if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        //build msg
        CellularAbstractLayer3BuildMessage(
            node,
            &outMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            callConnectAckPkt,
            sizeof(CellularAbstractCallConnectAckPkt));

        //add wired info
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &outMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractBsInfo->associatedScNodeId);

        //forward to sc
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            outMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT_ACKNOWLEDGE);

        //update stats
        nwCellularAbstractBsInfo->stats.numMOCallConnectAckRcvd ++;
        nwCellularAbstractBsInfo->stats.numMOCallConnectAckFwd ++;
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC:forward MO Call Connect ACK to SC\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }

}
//******************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleDeactivatePDPContextRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Deactivate PDP Context Request msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//********************************************************************
static
void CellularAbstractBsHandleDeactivatePDPContextRequestMsg(Node *node,
                                                            Message *msg)
{
    CellularAbstractDeactivatePDPContextRequestPkt *deactivatePDPReqPkt;
    CellularAbstractCallSrcDestType callSrcDestType;
    Message *outMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;
    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d BS Node %d SM:RCVD a DeactivatePDPContextRequest\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

    deactivatePDPReqPkt =
        (CellularAbstractDeactivatePDPContextRequestPkt *)
        MESSAGE_ReturnPacket(msg);

    callSrcDestType = deactivatePDPReqPkt->callSrcDestType;

    if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        //forward to sc
        //build msg
        CellularAbstractLayer3BuildMessage(
            node,
            &outMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            deactivatePDPReqPkt,
            sizeof(CellularAbstractDeactivatePDPContextRequestPkt));

        //add wired info
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &outMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractBsInfo->associatedScNodeId);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            outMsg,
            CELLULAR_PD_SM,
            CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_REQUEST);

        //update stats TODO
        if (DEBUG_SM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d BS node %d SM:forward MO "
                "DeactivatePDPContextRequest"
                "BY MS to SC\n",
                node->getNodeTime(),
                node->nodeId);
            fflush(stdout);
        }

    }
    else if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        Message *fwdMsg;
        NodeAddress recvId;
        CellularAbstractLayer3BuildMessage(
            node,
            &fwdMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            (void *)deactivatePDPReqPkt,
            sizeof(CellularAbstractDeactivatePDPContextRequestPkt));

        recvId = deactivatePDPReqPkt->appDestNodeId;

        CellularAbstractLayer3SendProtocolMsgToMac(
            node,
            fwdMsg,
            CELLULAR_PD_SM,
            CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_REQUEST,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0, //channel id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            recvId);

        if (DEBUG_SM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d BS node %d SM:forward MT "
                "DeactivatePDPContextRequest"
                "BY NETWORK to MS\n",
                node->getNodeTime(),
                node->nodeId);
            fflush(stdout);
        }
    }
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleDeactivatePDPContextAcceptMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Deactivate PDP  Context Accept msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractBsHandleDeactivatePDPContextAcceptMsg(Node *node,
                                                           Message *msg)
{
    CellularAbstractDeactivatePDPContextAcceptPkt *deactivatePDPAcceptPkt;
    CellularAbstractCallSrcDestType callSrcDestType;
    int itemIndex;
    Message *outMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;
    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;
    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d BS Node %d SM:RCVD a DeactivatePDPContextAccept\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

    deactivatePDPAcceptPkt =
        (CellularAbstractDeactivatePDPContextAcceptPkt *)
        MESSAGE_ReturnPacket(msg);

    callSrcDestType =
        deactivatePDPAcceptPkt->callSrcDestType;

    if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        //forward to sc
        //build msg
        CellularAbstractLayer3BuildMessage(
            node,
            &outMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            deactivatePDPAcceptPkt,
            sizeof(CellularAbstractDeactivatePDPContextAcceptPkt));

        //add wired info
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &outMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractBsInfo->associatedScNodeId);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            outMsg,
            CELLULAR_PD_SM,
            CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_ACCEPT);

        //update stats TODO

        if (DEBUG_SM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d BS node %d SM:forward MT "
                "DeactivatePDPContextaccept"
                "BY ms to SC\n",
                node->getNodeTime(),
                node->nodeId);
            fflush(stdout);
        }

    }
    else if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {

        Message *fwdMsg;
        NodeAddress recvId;

        CellularAbstractLayer3BuildMessage(
            node,
            &fwdMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            (void *)deactivatePDPAcceptPkt,
            sizeof(CellularAbstractDeactivatePDPContextAcceptPkt));

        recvId =
            deactivatePDPAcceptPkt->appSrcNodeId;

        ERROR_Assert(
            CellularAbstractBsLookForAppInfoItem(
                node,
                deactivatePDPAcceptPkt->transactionId,
                deactivatePDPAcceptPkt->appSrcNodeId,
                &itemIndex) == TRUE,
            "cannot find the appInfo for this deactivate PDP accept msg");

        CellularAbstractLayer3SendProtocolMsgToMac(
            node,
            fwdMsg,
            CELLULAR_PD_SM,
            CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_ACCEPT,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            nwCellularAbstractBsInfo->
                bsAppInfo[itemIndex].assignedDLChannelIndex[0],//channel id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            recvId);

        if (DEBUG_SM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d BS node %d SM:forward MO "
                "DeactivatePDPContextACCPET"
                "BY NETWORK to MS\n",
                node->getNodeTime(),
                node->nodeId);
            fflush(stdout);
        }
    }
}

//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleCallDisconnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Call Disconnect msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractBsHandleCallDisconnectMsg(Node *node, Message *msg)
{
    CellularAbstractCallDisconnectPkt *callDisconnectPkt;
    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractCallDisconnectType callDisconnectType;
    Message *outMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;
    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d BS Node %d CC:RCVD a CALL DISCONNECT\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    callDisconnectPkt =
        (CellularAbstractCallDisconnectPkt *)
        MESSAGE_ReturnPacket(msg);

    callSrcDestType =
        callDisconnectPkt->callSrcDestType;
    callDisconnectType =
        callDisconnectPkt->callDisconnectType;
    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d: disconnect %d call type %d by %d\n ",
            node->getNodeTime(),
            node->nodeId,
            callSrcDestType,
            callDisconnectType,
            callDisconnectPkt->callDisconnectType);
        fflush(stdout);

    }

    if (callDisconnectType ==
        CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_MS)
    {
        ////initiate call clear and disconnect by MS forward to sc
        //build msg
        CellularAbstractLayer3BuildMessage(
            node,
            &outMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            callDisconnectPkt,
            sizeof(CellularAbstractCallDisconnectPkt));

        //add wired info
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &outMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractBsInfo->associatedScNodeId);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            outMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_DISCONNECT);

        //update stats
        if (callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)//towward to MSC
        {
            nwCellularAbstractBsInfo->stats.numMTCallDisconnectByMsRcvd ++;
            nwCellularAbstractBsInfo->stats.numMTCallDisconnectByMsFwd ++;

            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d CC:forward MT Call DisConnect"
                    "BY MS to SC\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }
        else if (callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            nwCellularAbstractBsInfo->stats.numMOCallDisconnectByMsRcvd ++;
            nwCellularAbstractBsInfo->stats.numMOCallDisconnectByMsFwd ++;

            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d CC:forward MO Call DisConnect"
                    "BY MS to SC\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }
    }
    else if (callDisconnectType ==
        CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_NETWORK)
    {
        ////ifor call clear and disconnect by netowrk side  to ms
        Message *fwdMsg = NULL;
        NodeAddress recvId = 0;

        CellularAbstractLayer3BuildMessage(
            node,
            &fwdMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            (void *)callDisconnectPkt,
            sizeof(CellularAbstractCallDisconnectPkt));

        if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {
            recvId = callDisconnectPkt->appDestNodeId;
            nwCellularAbstractBsInfo->stats.numMTCallDisconnectByNwRcvd ++;
            nwCellularAbstractBsInfo->stats.numMTCallDisconnectByNwFwd ++;

            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d  node %d CC:forward MT Call"
                    "DisConnect BY NETWORK to MS\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }
        else if (callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            recvId = callDisconnectPkt->appSrcNodeId;
            nwCellularAbstractBsInfo->stats.numMOCallDisconnectByNwRcvd ++;
            nwCellularAbstractBsInfo->stats.numMOCallDisconnectByNwFwd ++;

            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d CC:forward MO Call"
                    "DisConnect BY NETWORK to MS\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }

        ERROR_Assert(fwdMsg != NULL, "Forward Msg is NULL");

        //send to mac
        CellularAbstractLayer3SendProtocolMsgToMac(
            node,
            fwdMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_DISCONNECT,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//channel id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            recvId);
    }
}

//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleCallReleaseMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Call Release msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractBsHandleCallReleaseMsg(Node *node, Message *msg)
{
    CellularAbstractCallReleasePkt *callReleasePkt;
    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractCallReleaseType callReleaseType;
    Message *outMsg;


    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;
    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;
    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d BS Node %d CC:RCVD a CALL RELEASE\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    callReleasePkt =
        (CellularAbstractCallReleasePkt *)MESSAGE_ReturnPacket(msg);
    callSrcDestType = callReleasePkt->callSrcDestType;
    callReleaseType = callReleasePkt->callReleaseType;
    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d call type %d,release type %d\n",
            node->getNodeTime(), node->nodeId,
            callSrcDestType,callReleaseType);
        fflush(stdout);
    }
    if (callReleaseType ==
        CELLULAR_ABSTRACT_CALL_RELEASE_BY_NETWORK)
    {

        Message *fwdMsg = NULL;
        NodeAddress recvId = 0;

        CellularAbstractLayer3BuildMessage(
            node,
            &fwdMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            (void *)callReleasePkt,
            sizeof(CellularAbstractCallReleasePkt));

        if (callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {
            recvId = callReleasePkt->appDestNodeId;

            //update stats
            nwCellularAbstractBsInfo->stats.numMTCallReleaseByNwRcvd ++;
            nwCellularAbstractBsInfo->stats.numMTCallReleaseByNwFwd ++;
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d CC:ready to forward MT"
                    "Call RELEASE by NETWORK to MS\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }
        else if (callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            recvId = callReleasePkt->appSrcNodeId;
            //update stats
            nwCellularAbstractBsInfo->stats.numMOCallReleaseByNwRcvd ++;
            nwCellularAbstractBsInfo->stats.numMOCallReleaseByNwFwd ++;
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d  node %d CC:ready to forward "
                    "MO Call RELEASE by NETWORK to MS\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }

        ERROR_Assert(fwdMsg != NULL, "forward NULL Call release msg to MS");

        //send toward  the MS
        CellularAbstractLayer3SendProtocolMsgToMac(
            node,
            fwdMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_RELEASE,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//channel id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            recvId);

    }
    else if (callReleaseType == CELLULAR_ABSTRACT_CALL_RELEASE_BY_MS)
    {
        //forward to sc
        //build msg
        CellularAbstractLayer3BuildMessage(
            node,
            &outMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            callReleasePkt,
            sizeof(CellularAbstractCallReleasePkt));

        //add wired info
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &outMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractBsInfo->associatedScNodeId);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            outMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_RELEASE);
        //update stats
        if (callSrcDestType==CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {
            nwCellularAbstractBsInfo->stats.numMTCallReleaseByMsRcvd ++;
            nwCellularAbstractBsInfo->stats.numMTCallReleaseByMsFwd ++;

            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d CC:ready to forward MT"
                    "Call RELEASE by MS to SC\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }
        else if (callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            nwCellularAbstractBsInfo->stats.numMOCallReleaseByMsRcvd ++;
            nwCellularAbstractBsInfo->stats.numMOCallReleaseByMsFwd ++;

            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d CC:ready to forward MO "
                    "Call RELEASE by MS to SC\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }
    }
}
//***************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleCallReleaseCompleteMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Call Release Complete msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***************************************************************************
static
void CellularAbstractBsHandleCallReleaseCompleteMsg(Node *node,Message *msg)
{
    CellularAbstractCallReleaseCompletePkt *callReleaseCompletePkt;
    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractCallReleaseCompleteType callReleaseCompleteType;
    Message *outMsg;


    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;
    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;
    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d BS Node %d CC:RCVD a CALL RELEASE Complete\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

    callReleaseCompletePkt =
        (CellularAbstractCallReleaseCompletePkt *)MESSAGE_ReturnPacket(msg);
    callSrcDestType = callReleaseCompletePkt->callSrcDestType;

    callReleaseCompleteType =
        callReleaseCompletePkt->callReleaseCompleteType;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d call type %d,release Complete type %d\n",
            node->getNodeTime(),
            callSrcDestType,
            callReleaseCompleteType);
        fflush(stdout);
    }
    if (callReleaseCompleteType ==
        CELLULAR_ABSTRACT_CALL_RELEASE_COMPLETE_BY_NETWORK)
    {

        Message *fwdMsg = NULL;
        NodeAddress recvId = 0;

        CellularAbstractLayer3BuildMessage(
            node,
            &fwdMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            (void *)callReleaseCompletePkt,
            sizeof(CellularAbstractCallReleaseCompletePkt));

        if (callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {
            recvId = callReleaseCompletePkt->appDestNodeId;

            //update stats TODO
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d BS node %d CC:ready to forward MT Call"
                    "RELEASE Complete by NETWORK to MS\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }
        else if (callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            recvId = callReleaseCompletePkt->appSrcNodeId;

            //update stats TODO

            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d BS node %d CC:ready to "
                    "forward MO Call RELEASE "
                    "Complete by NETWORK to MS\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }

        ERROR_Assert(fwdMsg != NULL, "Forward a NULL MO callRlease Msg");

        //send toward  the MS
        CellularAbstractLayer3SendProtocolMsgToMac(
            node,
            fwdMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_RELEASE_COMPLETE,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//channel id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            recvId);
    }
    else if (callReleaseCompleteType ==
        CELLULAR_ABSTRACT_CALL_RELEASE_COMPLETE_BY_MS)
    {
        //forward to sc
        //build msg
        CellularAbstractLayer3BuildMessage(
            node,
            &outMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            (void *)callReleaseCompletePkt,
            sizeof(CellularAbstractCallReleaseCompletePkt));

        //add wired info
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &outMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractBsInfo->associatedScNodeId);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            outMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_RELEASE_COMPLETE);

        //TODO update stats

        if (callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {

            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d BS node %d CC:ready to forward MT Call"
                    "RELEASE Complete by MS to SC\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }
        else if (callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d BS node %d CC:ready to forward "
                    "MO Call RELEASE Complete by MS to SC\n",
                    node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }
    }
}
//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleHandoverRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Handover Request msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractBsHandleHandoverRequestMsg(Node *node, Message *msg)
{
    int i;
    int itemIndex;
    int numAppHandoverSuccess;
    CellularAbstractHandoverType handoverType;
    CellularAbstractHandoverRequestPkt *hoRequestPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HO: processing handover request\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
    //update stats
    nwCellularAbstractBsInfo->stats.numHandoverRequestRcvd ++;

    hoRequestPkt =
        (CellularAbstractHandoverRequestPkt *)MESSAGE_ReturnPacket(msg);

    numAppHandoverSuccess = 0;
    for (i = 0; i < hoRequestPkt->numApplication; i ++)
    {
        int channelAllocated[CELLULAR_ABSTRACT_MAX_CHANNEL_ALLOWED_PER_APP];
        double retBandwidth = 0.0;
        int j;
        BOOL foundTrans = FALSE;
        for (j = 0; j < CELLULAR_ABSTRACT_MAX_CHANNEL_ALLOWED_PER_APP; j ++)
        {
            channelAllocated[j] = CELLULAR_ABSTRACT_INVALID_CHANNEL_ID;
        }

        //when bandwidth is used, only first index is used
        //TODO when channel id option is used
        channelAllocated[0] = 0;

        //call admission control goes to here if needed
        handoverType = hoRequestPkt->handoverType;

        //to see if system has space to hold the transaction
        if (handoverType != CELLULAR_ABSTRACT_HANDOVER_TYPE_INTRA_CELL)
        {
            for (j = 0; j < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS; j ++)
            {
                if (nwCellularAbstractBsInfo->bsAppInfo[j].inUse == FALSE)
                {
                    foundTrans = TRUE;
                    break;
                }
            }
        }
        else
        {
            // use the original one so does not need find
            foundTrans = TRUE;
        }
        if (foundTrans == TRUE)
        {
            CellularAbstractBandwidthAllocation(
                node,
                hoRequestPkt->targetSectorId,
                CELLULAR_EST_CAUSE_NORMAL_CALL,
                CELLULAR_ABSTRACT_CHANNEL_REQUEST_GENERAL,
                hoRequestPkt->handoverAppInfo[i].bandwidthRequired,
                &retBandwidth);
        }

        if (retBandwidth >= hoRequestPkt->
            handoverAppInfo[i].bandwidthRequired && foundTrans)
        {
            int k;
            numAppHandoverSuccess ++;
            hoRequestPkt->
                handoverAppInfo[i].bandwidthAllocated=retBandwidth;


            for (k = 0;
                k < CELLULAR_ABSTRACT_MAX_CHANNEL_ALLOWED_PER_APP;
                k ++)
            {
                hoRequestPkt->handoverAppInfo[i].channelAllocated[k] =
                    channelAllocated[k];
            }

            hoRequestPkt->handoverAppInfo[i].isHandoverAllowed = TRUE;

            //store these temporary information
            if (handoverType ==
                CELLULAR_ABSTRACT_HANDOVER_TYPE_INTRA_CELL)
            {
                ERROR_Assert(
                    CellularAbstractBsLookForAppInfoItem(
                        node,
                        hoRequestPkt->handoverAppInfo[i].transactionId,
                        hoRequestPkt->msNodeId,
                        &itemIndex) == TRUE,
                    "cannot find the appInfo for this ho request msg");

                nwCellularAbstractBsInfo->bsAppInfo[itemIndex].hoSectorId =
                    hoRequestPkt->targetSectorId;

                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].hoBandwidthAllocated = retBandwidth;

                //need to modify if channel option is used
                for (k = 0;
                    k < CELLULAR_ABSTRACT_MAX_CHANNEL_ALLOWED_PER_APP;
                    k ++)
                {
                    nwCellularAbstractBsInfo->
                        bsAppInfo[itemIndex].hoAssignedDLChannelIndex[k] =
                            channelAllocated[k];

                    nwCellularAbstractBsInfo->
                        bsAppInfo[itemIndex].hoAssignedULChannelIndex[k] =
                            channelAllocated[k];
                }

                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].isHandoverInProgress = TRUE;
            }
            else
            {
                //crerate a AppInfo for this app
                // and store the newly allocated info
                CellularAbstractBsCreateAppInfoItem(
                    node,
                    hoRequestPkt->handoverAppInfo[i].transactionId,
                    hoRequestPkt->msNodeId,
                    hoRequestPkt->targetSectorId,
                    retBandwidth,
                    &itemIndex);

                nwCellularAbstractBsInfo->bsAppInfo[itemIndex].appId =
                    hoRequestPkt->handoverAppInfo[i].appId;

                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].applicationType =
                    hoRequestPkt->handoverAppInfo[i].appType;

                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].callSrcDestType =
                    hoRequestPkt->handoverAppInfo[i].callSrcDestType;

                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].srcMsNodeId =
                    hoRequestPkt->handoverAppInfo[i].appSrcNodeId;

                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].destMsNodeId =
                    hoRequestPkt->handoverAppInfo[i].appDestNodeId;

                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].isHandoverInProgress = TRUE;
            }

        }
        else
        {
            hoRequestPkt->handoverAppInfo[i].isHandoverAllowed = FALSE;

        }
    }

    //some apps are handovered successfully
    if (numAppHandoverSuccess > 0)
    {
        Message *hoRequestAckMsg;

        //build msg
        CellularAbstractLayer3BuildMessage(
            node,
            &hoRequestAckMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            hoRequestPkt,
            sizeof(CellularAbstractHandoverRequestAckPkt));

        //add wired info
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &hoRequestAckMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractBsInfo->associatedScNodeId);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            hoRequestAckMsg,
            CELLULAR_PD_RR,
            CELLULAR_ABSTRACT_HANDOVER_REQUEST_ACK);

        //update stats
        nwCellularAbstractBsInfo->stats.numHandoverRequestAckSent ++;

        if (DEBUG_HANDOVER)
        {
            printf("at %015" TYPES_64BITFMT "d node %d HO: "
                "build and send intra-SC (intracell or"
                "inter call) handover request ACK for node %d to SC %d\n",
                node->getNodeTime(),
                node->nodeId,
                hoRequestPkt->msNodeId,
                nwCellularAbstractBsInfo->associatedScNodeId);
            fflush(stdout);
        }
    }
    else // all the apps are handovered failed
    {
        //CELLULAR_ABSTRACT_HANDOVER_FAILURE
        Message *hoFailureMsg;

        //build msg
        CellularAbstractLayer3BuildMessage(
            node,
            &hoFailureMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            hoRequestPkt,
            sizeof(CellularAbstractHandoverFailurePkt));

        //add wired info
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &hoFailureMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractBsInfo->associatedScNodeId);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            hoFailureMsg,
            CELLULAR_PD_RR,
            CELLULAR_ABSTRACT_HANDOVER_FAILURE);

        //update stats
        nwCellularAbstractBsInfo->stats.numHandoverFailureSent ++;
        if (DEBUG_HANDOVER)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d HO: MS %d's "
                "handover requrest was rejected"
                "and handover fialure is sent to %d\n",
                node->getNodeTime(),
                node->nodeId,
                hoRequestPkt->msNodeId,
                nwCellularAbstractBsInfo->associatedScNodeId);
            fflush(stdout);
        }
    }
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleHandoverRequiredMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Handover Required msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractBsHandleHandoverRequiredMsg(Node *node, Message *msg)
{
    CellularAbstractHandoverRequiredPkt *hoRequiredPkt;
    Message *hoRequiredMsg;
    int i;
    int itemIndex;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;
    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HANDOVER:rcvd and ready to "
            "handle HANDOVER REQUIRED msg\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
    hoRequiredPkt = (CellularAbstractHandoverRequiredPkt *)
                    MESSAGE_ReturnPacket(msg);

    for (i = 0; i < hoRequiredPkt->numApplication; i++)
    {
        ERROR_Assert(
            CellularAbstractBsLookForAppInfoItem(
                node,
                hoRequiredPkt->handoverAppInfo[i].transactionId,
                hoRequiredPkt->msNodeId,
                &itemIndex) == TRUE,
            "cannot find the appInfo for this ho required msg");

        nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].isHandoverInProgress = TRUE;

    }
    //forward HO required msg to sc
    //build msg
    CellularAbstractLayer3BuildMessage(
        node,
        &hoRequiredMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        hoRequiredPkt,
        sizeof(CellularAbstractHandoverRequiredPkt));

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &hoRequiredMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractBsInfo->associatedScNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        hoRequiredMsg,
        CELLULAR_PD_RR,
        CELLULAR_ABSTRACT_HANDOVER_REQUIRED);

    //update statas
    nwCellularAbstractBsInfo->stats.numMSInitHandoverRequiredRcvd ++;
    nwCellularAbstractBsInfo->stats.numMSInitHandoverRequiredFwd ++;

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HANDOVER: send "
            "HANDOVER REQUIRED msg to SC %d\n",
            node->getNodeTime(),
            node->nodeId,
            nwCellularAbstractBsInfo->associatedScNodeId);
        fflush(stdout);
    }
}
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleHandoverRequiredRejectedMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Handover Required reject msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractBsHandleHandoverRequiredRejectedMsg(Node *node,
                                                         Message *msg)
{
    Message *hoRequiredRejectMsg;
    CellularAbstractHandoverRequiredRejectPkt *hoRequiredRejectPkt;
    int i;
    int itemIndex;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HANDOVER:rcvd and ready to "
            "handle HANDOVER required reject msg\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

    hoRequiredRejectPkt =
        (CellularAbstractHandoverRequiredRejectPkt *)
        MESSAGE_ReturnPacket(msg);

    //update stats
    nwCellularAbstractBsInfo->stats.numMSInitHandoverRequiredRejectRcvd ++;

    //updatethe handover status
    for (i = 0; i < hoRequiredRejectPkt->numApplication; i++)
    {
        ERROR_Assert(
            CellularAbstractBsLookForAppInfoItem(
                node,
                hoRequiredRejectPkt->handoverAppInfo[i].transactionId,
                hoRequiredRejectPkt->msNodeId,
                &itemIndex) == TRUE,
            "cannot find the appInfo for this ho required reject msg");

        nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].isHandoverInProgress = TRUE;

    }

    //TODO support NW initiated Handover

    //forward the reject msg to MS
    CellularAbstractLayer3BuildMessage(
        node,
        &hoRequiredRejectMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        hoRequiredRejectPkt,
        sizeof(CellularAbstractHandoverRequiredRejectPkt));

    //send the setup msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        hoRequiredRejectMsg,
        CELLULAR_PD_RR,//protocl discritptor
        CELLULAR_ABSTRACT_HANDOVER_REQUIRED_REJECT,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//temporary use
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only assocatiated BS
        hoRequiredRejectPkt->msNodeId);

    //update stats
    nwCellularAbstractBsInfo->stats.numMSInitHandoverRequiredRejectFwd ++;

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HANDOVER:send handover "
            "required reject msg to ms %d\n",
            node->getNodeTime(),
            node->nodeId,
            hoRequiredRejectPkt->msNodeId);
        fflush(stdout);
    }
}

//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleHandoverCommandMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Handover Command msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractBsHandleHandoverCommandMsg(Node *node, Message *msg)
{

    Message *hoRICommandMsg;
    CellularAbstractHandoverCommandPkt *hoCommandPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    if (DEBUG_HANDOVER)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d HANDOVER:rcvd and ready to "
                "handle HANDOVER COMMAND msg\n",
                node->getNodeTime(),
                node->nodeId);
            fflush(stdout);
        }
    //update stats
    nwCellularAbstractBsInfo->stats.numHandoverCommandRcvd ++;

    hoCommandPkt =
        (CellularAbstractHandoverCommandPkt *)MESSAGE_ReturnPacket(msg);

    CellularAbstractLayer3BuildMessage(
        node,
        &hoRICommandMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        hoCommandPkt,
        sizeof(CellularAbstractHandoverCommandPkt));

    //send the setup msg to mac
    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        hoRICommandMsg,
        CELLULAR_PD_RR,//protocl discritptor
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_RI_HANDOVER_COMMAND,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//temporary use
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only assocatiated BS
        hoCommandPkt->msNodeId);

    //update stats
    nwCellularAbstractBsInfo->stats.numRIHandoverCommandSent ++;

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HANDOVER:send "
            "RI HANDOVER COMMAND msg to ms %d\n",
            node->getNodeTime(),
            node->nodeId,
            hoCommandPkt->msNodeId);
        fflush(stdout);
    }
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleIntraCellRIHandoverCompleteMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Handover IntraCell RI Handover Complete msg.
// PARAMETERS ::
// + node             : Node*               : Pointer to node.
// + hoCompletePkt: CellularAbstractHandoverCompletePkt* : Packet.
// RETURN     :: void : NULL
// **/
//*****************************************************************
static
void CellularAbstractBsHandleIntraCellRIHandoverCompleteMsg(
        Node *node,
        CellularAbstractHandoverCompletePkt *hoCompletePkt)
{
    int i;
    int itemIndex;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    for (i = 0; i < hoCompletePkt->numApplication; i ++)
    {
        if (hoCompletePkt->handoverAppInfo[i].isHandoverAllowed == TRUE)
        {
            //dealocation the old resource
            int oldSectorId;
            int newSectorId;
            if (DEBUG_HANDOVER)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d app allowd to handvoer to new BS\n",
                    node->getNodeTime(),
                    node->nodeId);
                fflush(stdout);
            }
            ERROR_Assert(
                CellularAbstractBsLookForAppInfoItem(
                    node,
                    hoCompletePkt->handoverAppInfo[i].transactionId,
                    hoCompletePkt->msNodeId,
                    &itemIndex) == TRUE,
                "cannot find the appInfo for this ho completer msg");

            oldSectorId =
                nwCellularAbstractBsInfo->bsAppInfo[itemIndex].sectorId;
            newSectorId =
                nwCellularAbstractBsInfo->bsAppInfo[itemIndex].hoSectorId;

            if (DEBUG_HANDOVER)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d before the HO Complete, "
                    "the BW in use in current sector %d is %f "
                    "target sector %d BW IN USE is %f and the "
                    "BW IN USE in this BS is %f\n",
                    node->getNodeTime(),
                    node->nodeId,
                    oldSectorId,
                    nwCellularAbstractBsInfo->
                        bsSectorInfo[oldSectorId-1].bandwidthInUse,

                    newSectorId,

                    nwCellularAbstractBsInfo->
                        bsSectorInfo[newSectorId-1].bandwidthInUse,

                    nwCellularAbstractBsInfo->bandwidthInUse);
                fflush(stdout);
            }

            CellularAbstractBandwidthDeallocation(
                node,
                nwCellularAbstractBsInfo->bsAppInfo[itemIndex].sectorId,
                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].bandwidthAllocated);

            if (DEBUG_HANDOVER)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d after the HO Complete, "
                    "the BW in use in old sector %d is %f "
                    "new sector BW IN USE  %d is %f and the BW "
                    "IN USE in this BS is %f, the appReq %f\n",
                    node->getNodeTime(),
                    node->nodeId,
                    oldSectorId,

                    nwCellularAbstractBsInfo->
                        bsSectorInfo[oldSectorId-1].bandwidthInUse,
                    newSectorId,

                    nwCellularAbstractBsInfo->
                        bsSectorInfo[newSectorId-1].bandwidthInUse,

                    nwCellularAbstractBsInfo->bandwidthInUse,

                    nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].bandwidthRequired);
                fflush(stdout);
            }
            //updatet he appInfo
            nwCellularAbstractBsInfo->
                bsAppInfo[itemIndex].assignedDLChannelIndex[0] =
                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].hoAssignedDLChannelIndex[0];

            nwCellularAbstractBsInfo->
                bsAppInfo[itemIndex].assignedULChannelIndex[0] =
                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].hoAssignedULChannelIndex[0];

            nwCellularAbstractBsInfo->
                bsAppInfo[itemIndex].bandwidthAllocated =
                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].hoBandwidthAllocated;

            nwCellularAbstractBsInfo->
                bsAppInfo[itemIndex].sectorId =
                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].hoSectorId;

            if (DEBUG_GENERAL)
            {
                printf(
                    "node %d: sectorId in APP is %d\n",
                    node->nodeId,
                  nwCellularAbstractBsInfo->bsAppInfo[itemIndex].sectorId);
                fflush(stdout);

            }
            nwCellularAbstractBsInfo->
                bsAppInfo[itemIndex].isHandoverInProgress = FALSE;
        }
        else
        {
            //dealocation the resource
            //dealocation the old resource
            if (DEBUG_HANDOVER)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d app allowd to handvoer to new BS\n",
                    node->getNodeTime(),
                    node->nodeId);
                fflush(stdout);
            }
            int oldSectorId;
            int newSectorId;
            ERROR_Assert(
                CellularAbstractBsLookForAppInfoItem(
                    node,
                    hoCompletePkt->handoverAppInfo[i].transactionId,
                    hoCompletePkt->msNodeId,
                    &itemIndex) == TRUE,
                "cannot find the appInfo for thie ho complate msg");

            oldSectorId =
                nwCellularAbstractBsInfo->bsAppInfo[itemIndex].sectorId;
            newSectorId =
                hoCompletePkt->targetSectorId;

            if (DEBUG_HANDOVER)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d before the HO Complete, "
                    "the BW in use in current sector %d is %f \n"
                    "target sector BW IN USE  %d is %f"
                    "and the BW IN USE in this BS is %f\n",
                    node->getNodeTime(),
                    node->nodeId,
                    oldSectorId,
                    nwCellularAbstractBsInfo->
                        bsSectorInfo[oldSectorId-1].bandwidthInUse,

                    newSectorId,
                    nwCellularAbstractBsInfo->
                        bsSectorInfo[newSectorId-1].bandwidthInUse,

                    nwCellularAbstractBsInfo->bandwidthInUse);
                fflush(stdout);
            }
            CellularAbstractBandwidthDeallocation(
                node,
                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].sectorId,

                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].bandwidthAllocated);

            CellularAbstractBsResetAppInfo(node, itemIndex);

            if (DEBUG_HANDOVER)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d after the HO Complete, "
                    "the BW in use in old sector %d is %f "
                    "new sector BW IN USE  %d is %f and the "
                    "BW IN USE in this BS is %f, the appReq %f\n",
                    node->getNodeTime(),
                    node->nodeId,
                    oldSectorId,
                    nwCellularAbstractBsInfo->
                        bsSectorInfo[oldSectorId-1].bandwidthInUse,
                    newSectorId,
                    nwCellularAbstractBsInfo->
                        bsSectorInfo[newSectorId-1].bandwidthInUse,

                    nwCellularAbstractBsInfo->bandwidthInUse,

                    nwCellularAbstractBsInfo->
                        bsAppInfo[itemIndex].bandwidthRequired);
                fflush(stdout);
            }
        }
    }

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HO: handle intra-cell RI"
            "handover complete msg\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleInterCellHandoverCompleteMs
// LAYER      :: Layer3
// PURPOSE    :: Handle Handover InterCell RI Handover Complete msg.
// PARAMETERS ::
// + node             : Node*   : Pointer to node.
// + hoCompletePkt    : CellularAbstractHandoverCompletePkt* : Packet
// RETURN     :: void : NULL

//***********************************************************************
static
void CellularAbstractBsHandleInterCellHandoverCompleteMsg(
        Node *node,
        CellularAbstractHandoverCompletePkt *hoCompletePkt)
{
    int i;
    int itemIndex;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    for (i = 0; i < hoCompletePkt->numApplication; i ++)
    {
        if (hoCompletePkt->handoverAppInfo[i].isHandoverAllowed == TRUE)
        {
            ERROR_Assert(
                CellularAbstractBsLookForAppInfoItem(
                    node,
                    hoCompletePkt->handoverAppInfo[i].transactionId,
                    hoCompletePkt->msNodeId,
                    &itemIndex) == TRUE,
                "cannot find the appInfo for this"
                "intercall handover complete msg");

            nwCellularAbstractBsInfo->
                bsAppInfo[itemIndex].isHandoverInProgress = FALSE;
        }
    }
    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HO: handle "
            "intercell RI handover complete msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleRIHandoverCompleteMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Handover Command msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractBsHandleRIHandoverCompleteMsg(Node *node, Message *msg)
{
    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HO: rcvd and ready to handle"
            "RI handover complete msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    CellularAbstractHandoverCompletePkt *hoCompletePkt;
    Message *hoCompleteMsg;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;
    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    //update statas
    nwCellularAbstractBsInfo->stats.numRIHandoverCompleteRcvd ++;

    hoCompletePkt =
        (CellularAbstractHandoverCompletePkt *)MESSAGE_ReturnPacket(msg);

    if (hoCompletePkt->handoverType ==
        CELLULAR_ABSTRACT_HANDOVER_TYPE_INTRA_CELL)
    {
        if (DEBUG_HANDOVER)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d HO: "
                "it is a intra handover complete msg\n",
                node->getNodeTime(),
                node->nodeId);
            fflush(stdout);
        }
        CellularAbstractBsHandleIntraCellRIHandoverCompleteMsg(
            node,
            hoCompletePkt);
    }
    else
    {
        if (DEBUG_HANDOVER)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d HO: "
                "it is a inter handover complete msg\n",
                node->getNodeTime(),
                node->nodeId);
            fflush(stdout);
        }
        CellularAbstractBsHandleInterCellHandoverCompleteMsg(
            node,
            hoCompletePkt);

    }

    //send Handovercomplete to SC
    //forward to sc
    //build msg
    CellularAbstractLayer3BuildMessage(
        node,
        &hoCompleteMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        hoCompletePkt,
        sizeof(CellularAbstractHandoverCompletePkt));

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &hoCompleteMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractBsInfo->associatedScNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        hoCompleteMsg,
        CELLULAR_PD_RR,
        CELLULAR_ABSTRACT_HANDOVER_COMPLETE);

    //update stats
    nwCellularAbstractBsInfo->stats.numHandoverCompleteSent ++;

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HANDOVER: "
            "send HANDOVER COMPLETE msg to SC %d\n",
            node->getNodeTime(),
            node->nodeId,
            nwCellularAbstractBsInfo->associatedScNodeId);
        fflush(stdout);
    }

}
//********************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleHandoverClearCommandMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Handover Clear Command msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractBsHandleHandoverClearCommandMsg(Node *node,
                                                     Message *msg)
{
    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HO: rcvd and ready to handle"
            "handover clear command msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    int i;
    int itemIndex;
    CellularAbstractHandoverClearCommnadPkt *hoClearCommandPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    hoClearCommandPkt =
       (CellularAbstractHandoverClearCommnadPkt *)MESSAGE_ReturnPacket(msg);
    for (i = 0; i < hoClearCommandPkt->numApplication; i ++)
    {
        ERROR_Assert(
            CellularAbstractBsLookForAppInfoItem(
                node,
                hoClearCommandPkt->handoverAppInfo[i].transactionId,
                hoClearCommandPkt->msNodeId,
                &itemIndex) == TRUE,
            "cannot find the appInfo for this ho clear command");

        //dealocation resource
        CellularAbstractBandwidthDeallocation(
            node,
            hoClearCommandPkt->currentSectorId,
         nwCellularAbstractBsInfo->bsAppInfo[itemIndex].bandwidthAllocated);

        //reset AppInfo
        CellularAbstractBsResetAppInfo(node, itemIndex);

    }
    //send clear command complete msg to SC TODO
    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HO: handle handover clear complete msg"
            "reset BS APPINFO deallocate resource\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
///****************************************************************
// /**
// FUNCTION   :: CellularAbstractBsProcessSystemInfoTimer
// LAYER      :: Layer3
// PURPOSE    :: BS  handle system broadcast timer
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*******************************************************************
static void CellularAbstractBsProcessSystemInfoTimer(Node *node,
                                                     Message *msg)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;
    Message *sysInfoMsg;
    Message *sysInfoTimer;
    CellularAbstractBsSystemTimerInfo *timerInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    if (DEBUG_GENERAL)
    {

        printf(
            "node %d: Cellular Abstract Layer3: process SystemInfoTimer\n",
            node->nodeId);
        fflush(stdout);
    }
    //send a copy of system info message to MAC

    sysInfoMsg =
        MESSAGE_Duplicate(
            node,
            nwCellularAbstractBsInfo->systemInfoType2);

    CellularAbstractLayer3SendProtocolMsgToMac(
        node,
        sysInfoMsg,
        CELLULAR_PD_RR,
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_SYSTEM_INFORMATION_TYPE2,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        nwCellularAbstractBsInfo->controlDLChannelIndex,
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_BCCH,
        CELLULAR_ABSTRACT_RECEIVER_ALL_MS,
        (unsigned int)(-1));

    //update stats
    nwCellularAbstractBsInfo->stats.numSysInfoSent ++;

    //scedule next system info timer
    //optimization
    if (nwCellularAbstractData->optLevel ==
            CELLULAR_ABSTRACT_OPTIMIZATION_LOW)
    {
        sysInfoTimer =
            MESSAGE_Alloc(
                node,
                NETWORK_LAYER,
                NETWORK_PROTOCOL_CELLULAR,
                MSG_NETWORK_CELLULAR_TimerExpired);

        MESSAGE_InfoAlloc(
            node,
            sysInfoTimer,
            sizeof(CellularAbstractBsSystemTimerInfo));

        timerInfo =
            (CellularAbstractBsSystemTimerInfo *)
            MESSAGE_ReturnInfo(sysInfoTimer);

        timerInfo->timerType = MSG_NETWORK_CELLULAR_SystemInfoTimer;
        timerInfo->transactionId = 0;
        MESSAGE_Send(
            node,
            sysInfoTimer,
            nwCellularAbstractBsInfo->systemInfoBroadcastInterval);
        if (DEBUG_GENERAL)
        {
            printf(
                "node %d:after send out the system info,"
                "schedule a system info timer\n",
                node->nodeId);
            fflush(stdout);
        }
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractBsProcessImmediateAssignmentTimer
// LAYER      :: Layer3
// PURPOSE    :: BS  handle Immediate Assignment Timer (T3101)
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractBsProcessImmediateAssignmentTimer(Node *node,
                                                       Message *msg)
{
    CellularAbstractBsImmediateAssignmentTimerInfo *timerInfo;
    int numChannelRequired;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;
    int bsNumChannelAssigned;
    double bandwidthAllocated;
    int assignmentIndex;
    BOOL found;

    if (DEBUG_GENERAL)
    {
        printf(
            "node %d: Cellular Abstract Layer3:"
            "ImmediateAssignmentTimer\n",
            node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    timerInfo =
        (CellularAbstractBsImmediateAssignmentTimerInfo *)
        MESSAGE_ReturnInfo(msg);

    numChannelRequired = timerInfo->numChannelRequired;
    bandwidthAllocated = timerInfo->bandwidthAllocated;
    bsNumChannelAssigned = nwCellularAbstractBsInfo->numChannelAssigned;

    found = FALSE;
    for (assignmentIndex = 0;
        assignmentIndex < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS;
        assignmentIndex ++)
    {
        if (nwCellularAbstractBsInfo->
                bsChannelAssignmentInfo[assignmentIndex].inUse == TRUE &&
            nwCellularAbstractBsInfo->
            bsChannelAssignmentInfo[assignmentIndex].assignmentId ==
                timerInfo->assignmentId)
        {
            found = TRUE;
            break;
        }
    }

    ERROR_Assert(
        found == TRUE,
        "the assignmentIs with the 3101 timer is not found in the record");

    nwCellularAbstractBsInfo->
        bsChannelAssignmentInfo[assignmentIndex].inUse = FALSE;

    //reset  the timer pointer
    nwCellularAbstractBsInfo->
        bsChannelAssignmentInfo[assignmentIndex].
        assignmentAccessTimer_T3101 = NULL;

    //the following commented part only used for channel
    //index case rather than bandwidth
    #ifdef CHANNEL_ALLOCATION
    for (i = 0;i < numChannelRequired;i ++)
    {

        //look for the channel in the channel bank
        for (j = 0; j < bsNumChannelAssigned; j ++)
        {
            if (nwCellularAbstractBsInfo->bsChannelBank[j].channelIndex ==
                timerInfo->channelAllocated[i])
            {
                break;
            }
        }
        if (nwCellularAbstractBsInfo->bsChannelBank[j].channelStatus ==
            CELLULAR_ABSTRACT_CHANNEL_STATUS_TENTATIVE)
        {
            nwCellularAbstractBsInfo->bsChannelBank[j].channelStatus =
                CELLULAR_ABSTRACT_CHANNEL_STATUS_IDLE;
        //enable others to use it
        //at this point only the channel status
        //has been changed to TENTATIVE
            if (DEBUG_RR)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d RR: change the channel %d"
                    "from TENTATIVE to IDLE\n",
                    node->getNodeTime(),
                    node->nodeId,
                    nwCellularAbstractBsInfo->bsChannelBank[j].channelIndex);
                fflush(stdout);
            }
        }   //if the channel status is not tentative,
            //it means the MS has access the channelby send the intital msg,
            //either location update request, or respnse to paging,
            //or cm service message
    }
    #endif //CHANNEL_ALLOCATION

    //the bandwidth should be freed
    //find the transaction id and MS in the reansaction info
    //free the resource in the sector
    CellularAbstractBandwidthDeallocation(
        node,
        timerInfo->sectorId,
        bandwidthAllocated);
}
//***************************************************************
// /**
// FUNCTION   :: CellularAbstractBsProcessT3111Timer
// LAYER      :: Layer3
// PURPOSE    :: BS  Process T3111 Timer
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//****************************************************************
static
void CellularAbstractBsProcessT3111Timer(Node *node, Message *msg)
{
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR: process T3111 and"
            "release the  resource \n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    CellularAbstractGenericTimerInfo *msgInfo;
    int itemIndex;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo =
       (CellularAbstractLayer3BsInfo *)nwCellularAbstractData->bsLayer3Info;

    msgInfo =
        (CellularAbstractGenericTimerInfo *)MESSAGE_ReturnInfo(msg);


    //the bandwidth should be freed
    //find the transaction id and MS in the reansaction info

    ERROR_Assert(
        CellularAbstractBsLookForAppInfoItem(
            node,
            msgInfo->transactionId,
            msgInfo->srcNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this T3111");

    if (DEBUG_GENERAL)
    {
        printf("node %d: APP ms%d sectorId %d\n",
                node->nodeId,
                msgInfo->srcNodeId,
                nwCellularAbstractBsInfo->
                    bsAppInfo[itemIndex].sectorId);
        fflush(stdout);
    }

    //free the resource in the sector
    CellularAbstractBandwidthDeallocation(
        node,
        nwCellularAbstractBsInfo->bsAppInfo[itemIndex].sectorId,
        nwCellularAbstractBsInfo->bsAppInfo[itemIndex].bandwidthAllocated);

    //updatet the AppInfo
    CellularAbstractBsResetAppInfo(node, itemIndex);
}
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractBsProcessT3113Timer
// LAYER      :: Layer3
// PURPOSE    :: BS  Process T3113 Timer
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractBsProcessT3113Timer(Node *node, Message *msg)
{
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d BS node %d CC: process T3113 since "
            "did not get the page response\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    CellularAbstractBsTimer3113Info *msgInfo;
    int pageRequestId;
    int pageIndex;
    BOOL found;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData = (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    msgInfo = (CellularAbstractBsTimer3113Info *)MESSAGE_ReturnInfo(msg);

    pageRequestId = msgInfo->pageRequestId;
    found = FALSE;
    for (pageIndex = 0;
        pageIndex < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS;pageIndex ++)
    {
        if (nwCellularAbstractBsInfo->
            bsPageRequestInfo[pageIndex].inUse == TRUE
            &&nwCellularAbstractBsInfo->
                bsPageRequestInfo[pageIndex].pageRequestId == pageRequestId)
        {
            found = TRUE;
            break;
        }
    }

    ERROR_Assert(
        found == TRUE,
        "pageid not found\n");

    nwCellularAbstractBsInfo->bsPageRequestInfo[pageIndex].numPage ++;

    if (nwCellularAbstractBsInfo->bsPageRequestInfo[pageIndex].numPage
        < CELLULAR_ABSTRACT_MAX_PAGE_REQUEST_ATTEMPT)
    {
        CellularAbstractBsTimer3113Info timerInfo;
        CellularAbstractPageRequestPkt *pageReqPkt;
        timerInfo.timerType = MSG_NETWORK_CELLULAR_T3113Timer;
        Message *newPageRequestMsg;
        timerInfo.pageRequestId = pageRequestId;

        //start 3113
        nwCellularAbstractBsInfo->
            bsPageRequestInfo[pageIndex].pageRequestTimer3113 =
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractPageRequest_T3113Time,
                &timerInfo,
                sizeof(CellularAbstractBsTimer3113Info));

        pageReqPkt =
            (CellularAbstractPageRequestPkt *)
            MESSAGE_ReturnPacket(
            nwCellularAbstractBsInfo->
            bsPageRequestInfo[pageIndex].pageRequestMsg);

        newPageRequestMsg =
            MESSAGE_Duplicate(
                node,
                nwCellularAbstractBsInfo->
                    bsPageRequestInfo[pageIndex].pageRequestMsg);

        //send a new request to mac
        CellularAbstractLayer3SendProtocolMsgToMac(
            node,
            newPageRequestMsg,
            CELLULAR_PD_RR,//protocl discritptor
            CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_PAGING_REQUEST_TYPE1,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            nwCellularAbstractBsInfo->controlDLChannelIndex,
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_PAGCH,//PAGCH for assignment
            CELLULAR_ABSTRACT_RECEIVER_SINGLE, //only ms
            pageReqPkt->appDestNodeId);
        if (DEBUG_CC )
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC: handle T3113 and"
                "send to Ms %d, again for pageId %d\n",
                node->getNodeTime(), node->nodeId,
                pageReqPkt->appDestNodeId,
                pageReqPkt->pageRequestId);
            fflush(stdout);
        }
    }
    else
    {
        CellularAbstractPageRequestPkt *pageReqPkt;
        pageReqPkt =
            (CellularAbstractPageRequestPkt *)
            MESSAGE_ReturnPacket(
            nwCellularAbstractBsInfo->
            bsPageRequestInfo[pageIndex].pageRequestMsg);

        //TODO: send a calling party a meesage reject
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC: handle T3113 and"
                "send MT reject indication to SC for src %d dest %d\n",
                node->getNodeTime(), node->nodeId,
                pageReqPkt->appSrcNodeId,
                pageReqPkt->appDestNodeId);
            fflush(stdout);
        }

     CellularAbstractBsSendMTCallRejectIndication(
            node,
            pageRequestId,
            CELLULAR_ABSTRACT_CALL_REJECT_CAUSE_USER_BUSY);

        //free the content
        /*if (nwCellularAbstractBsInfo->
            bsPageRequestInfo[pageIndex].pageRequestTimer3113 != NULL)
        {
            nwCellularAbstractBsInfo->
                bsPageRequestInfo[pageIndex].pageRequestTimer3113 = NULL;

            nwCellularAbstractBsInfo->
                bsPageRequestInfo[pageIndex].inUse = FALSE;
        }*/
     // reset the timer pointer
        nwCellularAbstractBsInfo->
                bsPageRequestInfo[pageIndex].pageRequestTimer3113 = NULL;
        nwCellularAbstractBsInfo->
                bsPageRequestInfo[pageIndex].inUse = FALSE;
        if (nwCellularAbstractBsInfo->
            bsPageRequestInfo[pageIndex].pageRequestMsg != NULL)
        {
            MESSAGE_Free(
                node,
                nwCellularAbstractBsInfo->
                bsPageRequestInfo[pageIndex].pageRequestMsg);

            nwCellularAbstractBsInfo->
                bsPageRequestInfo[pageIndex].pageRequestMsg = NULL;
        }
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC: handle T3113 and"
                "send reject indication to SC\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
        if (DEBUG_CC )
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC: handle T3113 and"
                "item for  for pageId %d is reset\n",
                node->getNodeTime(), node->nodeId, pageRequestId);
            fflush(stdout);
        }
    }
}
////////////////////////////////////////////////////////////////////////
//SC part
/////////////////////////////////////////////////////////////////////
//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractScUpdateVLR
// LAYER      :: Layer3
// PURPOSE    :: Sc Update VLR
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + lac              : short             : location area code.
// + msNodeId         : NodeAddress       : MS's node Id
// + msNodeAddress    : NodeAddress       : MS's node address
// + newMs            : BOOL              : Is is a new MS to this VLR
// RETURN     :: BOOL : TRUE/FALSE, update  success or not
// **/
//*************************************************************************
static
BOOL CellularAbstractScUpdateVLR(Node *node,
                                 int lac,
                                 NodeAddress msNodeId,
                                 NodeAddress msNodeAddr,
                                 BOOL *newMs)
{
    BOOL found;
    int i;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo =
        nwCellularAbstractData->scLayer3Info;

    // first to check if any recorder is too old
    for (i = 0; i < CELLULAR_ABSTRACT_MAX_MS_PER_SC;i ++)
    {
        if (nwCellularAbstractScInfo->scVlr[i].inUse == TRUE &&
            nwCellularAbstractScInfo->scVlr[i].lastUpdated
            + CELLULAR_ABSTRACT_VLR_LIFETIME < node->getNodeTime())

        {
            nwCellularAbstractScInfo->scVlr[i].inUse = FALSE;
        }
    }
    found = FALSE;

    for (i = 0;i < CELLULAR_ABSTRACT_MAX_MS_PER_SC;i ++)
    {
        if (nwCellularAbstractScInfo->scVlr[i].inUse == TRUE&&
            nwCellularAbstractScInfo->scVlr[i].msNodeId == msNodeId)

        {
            found = TRUE;
            break;
        }
    }
    if (found == TRUE)
    {
        if (nwCellularAbstractScInfo->scVlr[i].lac != lac)
        {
            nwCellularAbstractScInfo->scVlr[i].lac = lac;
        }

        nwCellularAbstractScInfo->scVlr[i].lastUpdated =
            node->getNodeTime();

        *newMs = FALSE;
        if (DEBUG_MM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d MM: "
                "VLR update the record MS %d lac is %d\n",
                node->getNodeTime(),
                node->nodeId,
                msNodeId,
                nwCellularAbstractScInfo->scVlr[i].lac);
            fflush(stdout);
        }

    }
    else
    {
        for (i = 0;i < CELLULAR_ABSTRACT_MAX_MS_PER_SC;i ++)
        {
            if (nwCellularAbstractScInfo->scVlr[i].inUse == FALSE)
            {
                break;//use the first un use one
            }

        }
        if (i == CELLULAR_ABSTRACT_MAX_MS_PER_SC)
        {
            return FALSE;//capacity limit is reached
        }
        else
        {
            nwCellularAbstractScInfo->scVlr[i].inUse = TRUE;
            nwCellularAbstractScInfo->scVlr[i].lac = lac;
            nwCellularAbstractScInfo->scVlr[i].lastUpdated =
                node->getNodeTime();

            nwCellularAbstractScInfo->scVlr[i].msNodeId = msNodeId;
            nwCellularAbstractScInfo->scVlr[i].msNodeAddress = msNodeAddr;
            *newMs = TRUE;
            if (DEBUG_MM)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d MM: VLR add a new record"
                    "for node %d lac is %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    nwCellularAbstractScInfo->scVlr[i].msNodeId,
                    nwCellularAbstractScInfo->scVlr[i].lac);
                fflush(stdout);
            }
        }
    }
    return TRUE;
}
//****************************************************************
// /**
// FUNCTION   :: CellularAbstractScUpdateVLR
// LAYER      :: Layer3
// PURPOSE    :: Sc Update VLR
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msNodeId         : NodeAddress       : MS's node Id
// + lac              : int*            : Point to thelocation area code.
// RETURN     :: BOOL : TRUE/FALSE, look up is  successful or not
// **/
//*******************************************************************
static
BOOL CellularAbstractScLookUpMsLocation(Node *node,
                                        NodeAddress msNodeId,
                                        int *lac)
{
    BOOL found;
    int i;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;
    found = FALSE;
    for (i = 0;i < CELLULAR_ABSTRACT_MAX_MS_PER_SC;i ++)
    {
        if (nwCellularAbstractScInfo->scVlr[i].inUse == TRUE&&
            nwCellularAbstractScInfo->scVlr[i].msNodeId == msNodeId)

        {
            found = TRUE;
            *lac = nwCellularAbstractScInfo->scVlr[i].lac;
            break;
        }
    }
    return found;
}

//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractScStopCallControlTimer
// LAYER      :: Layer3
// PURPOSE    :: Stop the call control timer for a application
// PARAMETERS ::
// + node             : Node*            : Pointer to node.
// + itemIndex        : int              : The index of the application
// RETURN     :: void : NULL
// **/
//*****************************************************************
static
void CellularAbstractScStopCallControlTimer(Node *node, int itemIndex)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT301 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT301);
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT301 = NULL;
    }
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT303 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT303);
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT303 = NULL;
    }
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT305 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT305);
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT305 = NULL;
    }
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT306 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT306);
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT306 = NULL;
    }
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT308 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT308);
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT308 = NULL;
    }
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT310 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT310);
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT310 = NULL;
    }
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT313 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT313);
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT313 = NULL;
    }
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT323 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT323);
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT323 = NULL;
    }
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT331 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT331);
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT331 = NULL;
    }
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT333 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT333);
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT333 = NULL;
    }
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT334 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT334);
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT334 = NULL;
    }
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT338 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT338);
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT338 = NULL;
    }
}

//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractScCreateAppInfoItem
// LAYER      :: Layer3
// PURPOSE    :: Create a application information record
// PARAMETERS ::
// + node             : Node*  : Pointer to node.
// + transactionId    : int    : Thansaction Id of this applicaiton.
// + appId            : int    : Application Id
// + applicationType  : CellularAbstractApplicationType : application type
// + srcNodeId     : NodeAddress : Application's src address
// + destNodeId    : NodeAddress : Application's dest address
// + callSrcDestType  : CellularAbstractCallSrcDestType : Type of src&dest
// + numChannelRequire: int : Number of the channel required
// + bandwidthRequired: double : Resource requirement for the application
// + itemIndex        : int*   : Point to the index of the application
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractScCreateAppInfoItem(
        Node *node,
        int transactionId,
        int appId,
        CellularAbstractApplicationType applicationType,
        NodeAddress srcNodeId,
        NodeAddress destNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        int numChannelRequired,
        double bandwidthRequired,
        int *itemIndex)
{
    int i;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;
    BOOL found=FALSE;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    //look for the first un used item
    for (i = 0;i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_SC;i ++)
    {
        if (nwCellularAbstractScInfo->scAppInfo[i].inUse == FALSE)
        {
            found = TRUE;
            break;
        }
    }

    //make sure there is enough room to keep these information
    ERROR_Assert(
        found == TRUE,
        "TOO MANY CONCURRENT TRANSACIONS!INCREASE THE "
        "value of CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_SC!");

    //update the item
    nwCellularAbstractScInfo->scAppInfo[i].inUse = TRUE;
    nwCellularAbstractScInfo->scAppInfo[i].appId = appId;
    nwCellularAbstractScInfo->scAppInfo[i].transactionId = transactionId;

    nwCellularAbstractScInfo->
        scAppInfo[i].applicationType = applicationType;

    nwCellularAbstractScInfo->scAppInfo[i].srcMsNodeId = srcNodeId;
    nwCellularAbstractScInfo->scAppInfo[i].destMsNodeId = destNodeId;

    nwCellularAbstractScInfo->
        scAppInfo[i].callSrcDestType = callSrcDestType;

    nwCellularAbstractScInfo->
        scAppInfo[i].numChannelRequired = numChannelRequired;

    nwCellularAbstractScInfo->
        scAppInfo[i].bandwidthRequired = bandwidthRequired;

    nwCellularAbstractScInfo->
        scAppInfo[i].nwCcState = CELLULAR_ABSTRACT_NW_CC_STATE_NULL;

    nwCellularAbstractScInfo->scAppInfo[i].isHandoverInProgress = FALSE;
    nwCellularAbstractScInfo->scAppInfo[i].timerT301 = NULL;
    nwCellularAbstractScInfo->scAppInfo[i].timerT303 = NULL;
    nwCellularAbstractScInfo->scAppInfo[i].timerT305 = NULL;
    nwCellularAbstractScInfo->scAppInfo[i].timerT306 = NULL;//never used
    nwCellularAbstractScInfo->scAppInfo[i].timerT308 = NULL;
    nwCellularAbstractScInfo->scAppInfo[i].timerT310 = NULL;
    nwCellularAbstractScInfo->scAppInfo[i].timerT313 = NULL;
    nwCellularAbstractScInfo->scAppInfo[i].timerT323 = NULL;//never used
    nwCellularAbstractScInfo->scAppInfo[i].timerT331 = NULL;
    nwCellularAbstractScInfo->scAppInfo[i].timerT333 = NULL;
    nwCellularAbstractScInfo->scAppInfo[i].timerT334 = NULL;
    nwCellularAbstractScInfo->scAppInfo[i].timerT338 = NULL;
    nwCellularAbstractScInfo->scAppInfo[i].deactivatePDPTimer = NULL;

    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        nwCellularAbstractScInfo->scAppInfo[i].msNodeId = srcNodeId;
        if (DEBUG_GENERAL)
        {
            printf(
                "node %d: create a appInfo on behalf SRC the"
                "AppId %d transId %d  appSrc %d appdest %d bandwidth %f\n",
                node->nodeId,
                appId,
                transactionId,
                srcNodeId,
                destNodeId,
                bandwidthRequired);
            fflush(stdout);
        }
    }
    else if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        nwCellularAbstractScInfo->scAppInfo[i].msNodeId = destNodeId;
        if (DEBUG_GENERAL)
        {
            printf(
                "node %d: create a appInfo on behalf DEST the"
                "AppId %d transId %d appSrc %d appdest %d bandwidth %f\n",
                node->nodeId,
                appId,
                transactionId,
                srcNodeId,
                destNodeId,
                bandwidthRequired);
            fflush(stdout);
        }
    }
    *itemIndex = i;
}
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractScLookForAppInfoItem
// LAYER      :: Layer3
// PURPOSE    :: Look for a application information record
// PARAMETERS ::
// + node             : Node*  : Pointer to node.
// + transactionId    : int    : Thansaction Id of this applicaiton.
// + srcNodeId     : NodeAddress : Application's src address
// + itemIndex        : int*     : Point to the index of the application
// RETURN     :: BOOL : found or not
// **/
//**********************************************************************
static
BOOL CellularAbstractScLookForAppInfoItem(Node *node,
                                          int transactionId,
                                          NodeAddress srcNodeId,
                                          int *itemIndex)
{
    int i;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;
    BOOL found = FALSE;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    //look for the first un used item
    for (i =0;i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_SC; i ++)
    {
        if (nwCellularAbstractScInfo->scAppInfo[i].inUse == TRUE &&
            nwCellularAbstractScInfo->scAppInfo[i].msNodeId == srcNodeId &&
            nwCellularAbstractScInfo->
                scAppInfo[i].transactionId == transactionId)
        {
            found = TRUE;
            if (DEBUG_RR)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d: RR found src %d transactionid"
                    "%d type %d with bandwdith %f\n",
                    node->getNodeTime(),
                    node->nodeId,
                    nwCellularAbstractScInfo->scAppInfo[i].msNodeId,
                    transactionId,
                    nwCellularAbstractScInfo->scAppInfo[i].applicationType,
                    nwCellularAbstractScInfo->
                        scAppInfo[i].bandwidthRequired);
                fflush(stdout);
            }
            break;
        }
    }
    *itemIndex = i;
    return found;
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractScLookForAppItemByAppId
// LAYER      :: Layer3
// PURPOSE    :: Look for a application information record
// PARAMETERS ::
// + node             : Node* : Pointer to node.
// + appId            : int   : Application Id
// + srcNodeId     : NodeAddress : Application's src address
// + destNodeId    : NodeAddress : Application's dest address
// + callSrcDestType  : CellularAbstractCallSrcDestType:Type of the src&dest
// + itemIndex        : int*     : Point to the index of the application
// + transactionId    : int *    : Pointer to the transaction Id
// RETURN     :: BOOL : found or not
// **/
//*************************************************************************
static
BOOL CellularAbstractScLookForAppItemByAppId(
         Node *node,
         int appId,
         NodeAddress srcNodeId,
         NodeAddress destNodeId,
         CellularAbstractCallSrcDestType callSrcDestType,
         int *itemIndex,
         int *transactionId)
{

    int i = -1;
    BOOL found;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data  *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    //look for the first unused item
    found = FALSE;
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        for (i = 0;i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_SC;i ++)
            if (nwCellularAbstractScInfo->scAppInfo[i].inUse ==TRUE &&
                nwCellularAbstractScInfo->scAppInfo[i].appId == appId &&
                nwCellularAbstractScInfo->
                    scAppInfo[i].srcMsNodeId == srcNodeId &&
                nwCellularAbstractScInfo->
                    scAppInfo[i].destMsNodeId == destNodeId &&
                nwCellularAbstractScInfo->
                    scAppInfo[i].msNodeId == destNodeId)
            {

                found = TRUE;
                if (DEBUG_RR || DEBUG_GENERAL)
                {
                    printf(
                        "at %015" TYPES_64BITFMT "d node %d MT: RR found msnode %d"
                        "type %d with bandwdith %f\n",
                        node->getNodeTime(),
                        node->nodeId,
                        nwCellularAbstractScInfo->scAppInfo[i].msNodeId,
                        nwCellularAbstractScInfo->
                            scAppInfo[i].applicationType,
                        nwCellularAbstractScInfo->
                            scAppInfo[i].bandwidthRequired);
                   fflush(stdout);
                }
                break;
            }
    }
    else if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        for (i = 0;i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_SC;i ++)
            if (nwCellularAbstractScInfo->scAppInfo[i].inUse == TRUE &&
                nwCellularAbstractScInfo->scAppInfo[i].appId == appId &&
                nwCellularAbstractScInfo->
                    scAppInfo[i].srcMsNodeId == srcNodeId &&
                nwCellularAbstractScInfo->
                    scAppInfo[i].destMsNodeId == destNodeId &&
               nwCellularAbstractScInfo->scAppInfo[i].msNodeId == srcNodeId)
            {

                found = TRUE;
                if (DEBUG_RR || DEBUG_GENERAL)
                {
                    printf(
                        "at %015" TYPES_64BITFMT "d node %d MO: RR found msnode  %d "
                        "type %d with bandwidth %f\n",
                        node->getNodeTime(),
                        node->nodeId,
                        nwCellularAbstractScInfo->scAppInfo[i].msNodeId,
                        nwCellularAbstractScInfo->
                            scAppInfo[i].applicationType,
                        nwCellularAbstractScInfo->
                            scAppInfo[i].bandwidthRequired);
                    fflush(stdout);
                }
                break;
            }
    }


    *itemIndex = i;
    *transactionId = nwCellularAbstractScInfo->scAppInfo[i].transactionId;

    if (DEBUG_RR && found)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d: RR found msnode  %d "
            "transactionId %d for AppID %d\n",
            node->getNodeTime(),
            node->nodeId,
            nwCellularAbstractScInfo->scAppInfo[i].msNodeId,
            nwCellularAbstractScInfo->scAppInfo[i].transactionId,
            nwCellularAbstractScInfo->scAppInfo[i].appId);
        fflush(stdout);
    }
    return found;
}

//***************************************************************************
// /**
// FUNCTION   :: CellularAbstractScResetAppInfo
// LAYER      :: Layer3
// PURPOSE    :: Reset for a application information record
// PARAMETERS ::
// + node             : Node*   : Pointer to node.
// + itemIndex        : int*    : Point to the index of the application
// RETURN     :: void : NULL
// **/
//****************************************************************************
static
void CellularAbstractScResetAppInfo(Node *node, int itemIndex)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;
    //second hierachy
    nwCellularAbstractData = (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;
    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    nwCellularAbstractScInfo->scAppInfo[itemIndex].inUse = FALSE;

    CellularAbstractScStopCallControlTimer(node, itemIndex);

    /*if (nwCellularAbstractScInfo->
        scAppInfo[itemIndex].deactivatePDPTimer != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractScInfo->
                scAppInfo[itemIndex].deactivatePDPTimer);
        nwCellularAbstractScInfo->
            scAppInfo[itemIndex].deactivatePDPTimer = NULL;
    }*/
    //TODO:reset other values
}

///**********************************************************************
// /**
// FUNCTION   :: CellularAbstractScBuildLocationUpdateAcceptMsg
// LAYER      :: Layer3
// PURPOSE    :: Build the location update accpet msg
// PARAMETERS ::
// + node                      : Node*        : Pointer to node.
// + msg                       : Message ** : Pointer to Location update msg
// + locUpdateingType          : CellularAbstractLocationUpdatingType :
//                               location Updating Type
// + lac                       : int        : Location area code
// + msNodeId                  : NodeAddress  : MS node id
// + msNodeAddress             : NodeAddress  : MS node address
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractScBuildLocationUpdateAcceptMsg(
        Node *node,
        Message **msg,
        CellularAbstractLocationUpdatingType locUpdatingType,
        int lac,
        NodeAddress msNodeId,
        NodeAddress msNodeAddr)
{
    CellularAbstractLocationUpdateAcceptPkt *locUpdateAcceptPkt;
    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d MM: build a location"
            "update accept for MS %d\n",
            node->getNodeTime(), node->nodeId, msNodeId);
        fflush(stdout);
    }

    *msg = MESSAGE_Alloc( node,
                          MAC_LAYER,
                          MAC_PROTOCOL_CELLULAR,
                          MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        *msg,
                        sizeof(CellularAbstractLocationUpdateAcceptPkt),
                        TRACE_CELLULAR);

    locUpdateAcceptPkt =
        (CellularAbstractLocationUpdateAcceptPkt *)
        MESSAGE_ReturnPacket ((*msg));
    locUpdateAcceptPkt->lac = lac;
    locUpdateAcceptPkt->locationUpdatingType = locUpdatingType;
    locUpdateAcceptPkt->msNodeAddr = msNodeAddr;
    locUpdateAcceptPkt->msNodeId = msNodeId;
}
///******************************************************************
// /**
// FUNCTION   :: CellularAbstractScBuildLocationUpdateRejectMsg
// LAYER      :: Layer3
// PURPOSE    :: Build the location update Reject msg
// PARAMETERS ::
// + node                      : Node*       : Pointer to node.
// + msg                       : Message **  : Pointer to Loc update msg
// + locUpdatingType           : CellularAbstractLocationUpdatingType
//                                           : Type of loation update
// + lac                       : short       : Location area code
// + msNodeId                  : NodeAddress : MS node id
// + msNodeAddress             : NodeAddress : MS node address
// RETURN     :: void : NULL
// **/
//******************************************************************
static
void CellularAbstractScBuildLocationUpdateRejectMsg(
        Node *node,
        Message **msg,
        CellularAbstractLocationUpdatingType locUpdatingType,
        int lac,
        NodeAddress msNodeId,
        NodeAddress msNodeAddr)
{
    CellularAbstractLocationUpdateRejectPkt *locUpdateRejectPkt;
    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d MM: build a locatio update accept for MS %d\n",
            node->getNodeTime(), node->nodeId, msNodeId);
        fflush(stdout);
    }
    *msg = MESSAGE_Alloc(node,
                        MAC_LAYER,
                        MAC_PROTOCOL_CELLULAR,
                        MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        *msg,
                        sizeof(CellularAbstractLocationUpdateRejectPkt),
                        TRACE_CELLULAR);
    locUpdateRejectPkt =
        (CellularAbstractLocationUpdateRejectPkt *)
        MESSAGE_ReturnPacket ((*msg));
    locUpdateRejectPkt->lac = lac;
    locUpdateRejectPkt->locationUpdatingType = locUpdatingType;
    locUpdateRejectPkt->msNodeAddr = msNodeAddr;
    locUpdateRejectPkt->msNodeId = msNodeId;
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractSendHLRUpdateLocationMsg
// LAYER      :: Layer3
// PURPOSE    :: Send HLR  the MAPD update location msg
// PARAMETERS ::
// + node                      : Node*       : Pointer to node.
// + msNodeId                  : NodeAddress : MS node id
// + lac                       : short       : Location area code
// + locUpdateType             : CellularAbstractLocationUpdatingType
//                                           : location update type
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractSendHLRUpdateLocationMsg(
        Node *node,
        NodeAddress msNodeId,
        int lac,
        CellularAbstractLocationUpdatingType locUpdateType)
{
    CellularAbstractMapdUpdateLocationPkt *hlrUpdateLocationPkt;
    Message *hlrUpdateLocationMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData=(CellularAbstractLayer3Data *)
    node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d MM: build a location "
            "HLR update location for MS %d\n",
            node->getNodeTime(), node->nodeId, msNodeId);
        fflush(stdout);
    }
    hlrUpdateLocationMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        hlrUpdateLocationMsg,
                        sizeof(CellularAbstractMapdUpdateLocationPkt),
                        TRACE_CELLULAR);

    hlrUpdateLocationPkt =
        (CellularAbstractMapdUpdateLocationPkt *)
        MESSAGE_ReturnPacket (hlrUpdateLocationMsg);

    hlrUpdateLocationPkt->lac = lac;
    hlrUpdateLocationPkt->scNodeId = node->nodeId;
    hlrUpdateLocationPkt->msNodeId = msNodeId;
    hlrUpdateLocationPkt->locationUpdatingType = locUpdateType;


    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &hlrUpdateLocationMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractScInfo->associatedHLRNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        hlrUpdateLocationMsg,
        CELLULAR_PD_MM,
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_MAPD_UPDATE_LOCATION);

}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractScBuildClearCommandMsg
// LAYER      :: Layer3
// PURPOSE    :: Build clear command msg
// PARAMETERS ::
// + node                      : Node*        : Pointer to node.
// + msg                       : Message **   : Message to handle
// + msNodeId                  : NodeAddress  : MS node id
// + msNodeAddress             : NodeAddress  : MS node address
// + transactionId             : int          : Transaction Id
// + rrCause                   : CellularAbstractRRCause
//                                            : Cause for the clear command
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractScBuildClearCommandMsg(
        Node *node,
        Message **msg,
        NodeAddress srcNodeId,
        NodeAddress srcNodeAddr,
        int transactionId,
        CellularAbstractRRCause rrCause)
{
    CellularAbstractClearCommandPkt *clearCommandPkt;
    if (DEBUG_RR)
    {
        printf("at %015" TYPES_64BITFMT "d node %d RR: build a clear command \n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    *msg = MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        *msg,
                        sizeof(CellularAbstractClearCommandPkt),
                        TRACE_CELLULAR);

    clearCommandPkt =
        (CellularAbstractClearCommandPkt *) MESSAGE_ReturnPacket ((*msg));

    clearCommandPkt->transactionId = transactionId;
    clearCommandPkt->msNodeId = srcNodeId;
    clearCommandPkt->msNodeAddr = srcNodeAddr;
    clearCommandPkt->rrCause = rrCause;
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractScSendCMServiceAccpet
// LAYER      :: Layer3
// PURPOSE    :: Send CM accpet service accept msg
// PARAMETERS ::
// + node                      : Node*       : Pointer to node.
// + msg                       : Message **  : Message to handle
// + transactionId             : int         : Transaction Id
// + srcNodeId                 : NodeAddress : MS node id
// + cmServiceType             : CellularAbstractCMServiceType
//                                           : Type of CM service
// + bsNodeId                  : NodeAddress : MS'bs node Id
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractScSendCMServiceAccpet(
        Node *node,
        Message *msg,
        int transactionId,
        NodeAddress srcNodeId,
        CellularAbstractCMServiceType cmServiceType,
        NodeAddress bsNodeId)
{
    CellularAbstractCMServiceAcceptPkt *cmServiceAcceptPkt;
    Message *cmServiceAcceptMsg;
    CellularAbstractNetowrkToMacMsgInfo *cmServiceReqMsgInfo;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    cmServiceReqMsgInfo =
        (CellularAbstractNetowrkToMacMsgInfo *)MESSAGE_ReturnInfo(msg);
    if (DEBUG_MM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW MM: in building"
            "Cm service accept message\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    cmServiceAcceptMsg =
        MESSAGE_Alloc(node,
                      MAC_LAYER,
                      MAC_PROTOCOL_CELLULAR,
                      MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        cmServiceAcceptMsg,
        sizeof(CellularAbstractCMServiceAcceptPkt),
        TRACE_CELLULAR);

    cmServiceAcceptPkt =
        (CellularAbstractCMServiceAcceptPkt *)
        MESSAGE_ReturnPacket(cmServiceAcceptMsg);

    cmServiceAcceptPkt->msNodeId = srcNodeId;
    cmServiceAcceptPkt->transactionId = transactionId;
    cmServiceAcceptPkt->cmServiceType = cmServiceType;

    //update stats
    nwCellularAbstractScInfo->stats.numCMServiceAcceptSent ++;

    //send the cm service req to mac
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &cmServiceAcceptMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0, //sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        bsNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        cmServiceAcceptMsg,
        CELLULAR_PD_MM,
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_CM_SERVICE_ACCEPT);

    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW MM: built and sent a"
            "Cm service accept message\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//****************************************************************************
// /**
// FUNCTION   :: CellularAbstractScCreatePagingItem
// LAYER      :: Layer3
// PURPOSE    :: Create paging item
// PARAMETERS ::
// + node                      : Node*       : Pointer to node.
// + appId                     : int         : Application Id
// + appSrcNodeId              : NodeAddress : Application's src node Id
// + appDestNodeId             : NodeAddress : Application' dest node id
// + appType                   : CellularAbstractApplicationType : App type
// + numBsPaged                : int         : Number of BS paged
// RETURN     :: void : NULL
// **/
//****************************************************************************
static
void CellularAbstractScCreatePagingItem(
        Node *node,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractApplicationType appType,
        int numBsPaged)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;
    CellularAbstractPagingTimerInfo pagingTimerInfo;
    int i;
    BOOL found;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)nwCellularData->
        cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    //start a paging timer at this SC
    found = FALSE;

    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_SC; i ++)
    {
        if (nwCellularAbstractScInfo->scpagingInfo[i].inUse == FALSE)
        {
            found = TRUE;
            break;
        }
    }

    ERROR_Assert(
        found == TRUE,
        "too many active apps in ths SC,"
        "increase CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_SC");

    pagingTimerInfo.timerType = MSG_NETWORK_CELLULAR_PAGING_Timer;
    pagingTimerInfo.appId = appId;
    pagingTimerInfo.appSrcNodeId = appSrcNodeId;
    pagingTimerInfo.appDestNodeId = appDestNodeId;
    pagingTimerInfo.appType = appType;
    nwCellularAbstractScInfo->scpagingInfo[i].inUse = TRUE;
    nwCellularAbstractScInfo->scpagingInfo[i].appId = appId;

    nwCellularAbstractScInfo->scpagingInfo[i].appSrcNodeId = appSrcNodeId;
    nwCellularAbstractScInfo->scpagingInfo[i].appDestNodeId = appDestNodeId;

    nwCellularAbstractScInfo->scpagingInfo[i].appType = appType;
    nwCellularAbstractScInfo->scpagingInfo[i].msResponsed = FALSE;
    nwCellularAbstractScInfo->scpagingInfo[i].numPagingAttempt = 0;
    nwCellularAbstractScInfo->scpagingInfo[i].numBsPaged = numBsPaged;
    nwCellularAbstractScInfo->scpagingInfo[i].numBsResponsed = 0;
    nwCellularAbstractScInfo->scpagingInfo[i].pagingTimer =
        CellularAbstractLayer3StartTimer(
            node,
            CELLULAR_ABSTRACT_PAGING_TIME,
            &pagingTimerInfo,
            sizeof(CellularAbstractPagingTimerInfo));
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractScSendPagingMsg
// LAYER      :: Layer3
// PURPOSE    :: Send paging msg
// PARAMETERS ::
// + node                      : Node*        : Pointer to node.
// + appId                     : int          : Application Id
// + appSrcNodeId              : NodeAddress  : Application's src node Id
// + appDestNodeId             : NodeAddress  : Application' dest node id
// + appType                   : CellularAbstractApplicationType : App type
// + numCHannelRequired        : int          : Number of channel required
// + bandwidthRequired         : double       : Bandwidth requirement
// + appDuration               : clocktype    : Duration of the application
// + callSrcDestType           : CellularAbstractCallSrcDestType
//                                            : Type of Call src and dest
// + bsNodeId                  : NodeAddress  : BS's bode id
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractScSendPagingMsg(
        Node *node,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractApplicationType appType,
        int numChannelRequired,
        double bandwidthRequired,
        clocktype appDuration,
        CellularAbstractCallSrcDestType callSrcDestType,
        NodeAddress bsNodeId)
{
    CellularAbstractPagingPkt *pagingPkt;
    Message *pagingMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo= nwCellularAbstractData->scLayer3Info;

    if (DEBUG_RR || DEBUG_PROGRESS)
    {
        char clockStr[MAX_STRING_LENGTH];
        ctoa(node->getNodeTime(), clockStr);
        printf(
            "at %015" TYPES_64BITFMT "d node %d SC node NW RR: "
            "in buidd RR connection to MS %d for paging\n",
            node->getNodeTime(), node->nodeId, appDestNodeId);
        fflush(stdout);
    }
    pagingMsg = MESSAGE_Alloc(node,
                              MAC_LAYER,
                              MAC_PROTOCOL_CELLULAR,
                              MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        pagingMsg,
                        sizeof(CellularAbstractPagingPkt),
                        TRACE_CELLULAR);

    pagingPkt =(CellularAbstractPagingPkt *)MESSAGE_ReturnPacket(pagingMsg);
    pagingPkt->appId = appId;
    pagingPkt->appSrcNodeId = appSrcNodeId;
    pagingPkt->appDestNodeId = appDestNodeId;
    pagingPkt->appType = appType;
    pagingPkt->numChannelRequired = numChannelRequired;
    pagingPkt->bandwidthRequired = bandwidthRequired;
    pagingPkt->appDuration = appDuration;
    pagingPkt->callSrcDestType = callSrcDestType;

    //update stats
    nwCellularAbstractScInfo->stats.numPagingSent ++;

    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &pagingMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//it is  a wired link!
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,//it is wired link
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        bsNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        pagingMsg,
        CELLULAR_PD_RR,
        CELLULAR_ABSTRACT_PAGING);

    if (DEBUG_RR )
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW RR: build and send a paging msg"
            "to BS %d and start a paging timer\n",
            node->getNodeTime(), node->nodeId, bsNodeId);
        fflush(stdout);
    }
}
//**************************************************************************
/// /**
// FUNCTION   :: CellularAbstractScSendActivatePDPContextAcceptMsg
// LAYER      :: Layer3
// PURPOSE    :: Send Activate PDP Context Accept Msg
// PARAMETERS ::
// + node                      : Node*         : Pointer to node.
// + msg                       : Message*      : Message to be handled
// + transactionId             : int           : Transaction Id
// + appId                     : int           : Application Id
// + appSrcNodeId              : NodeAddress   : Application's src node Id
// + appDestNodeId             : NodeAddress   : Application' dest node id
// + callSrcDestType           : CellularAbstractCallSrcDestType
//                                             : Type of Call src and dest
// + bsNodeId                  : NodeAddress   : BS's bode id
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractScSendActivatePDPContextAcceptMsg(
        Node *node,
        Message *msg,
        int transactionId,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        NodeAddress bsNodeId)
{
    CellularAbstractActivatePDPContextAcceptPkt *APCAcceptPkt;
    Message *APCAcceptMsg;
    CellularAbstractNetowrkToMacMsgInfo *APCReqMsgInfo;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;
    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    APCReqMsgInfo =
        (CellularAbstractNetowrkToMacMsgInfo *)MESSAGE_ReturnInfo(msg);

    APCAcceptMsg =
        MESSAGE_Alloc(node,
                      MAC_LAYER,
                      MAC_PROTOCOL_CELLULAR,
                      MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        APCAcceptMsg,
                        sizeof(CellularAbstractActivatePDPContextAcceptPkt),
                        TRACE_CELLULAR);

    APCAcceptPkt =
        (CellularAbstractActivatePDPContextAcceptPkt *)
        MESSAGE_ReturnPacket(APCAcceptMsg);

    APCAcceptPkt->appSrcNodeId = appSrcNodeId;
    APCAcceptPkt->appDestNodeId = appDestNodeId;
    APCAcceptPkt->appId = appId;
    APCAcceptPkt->transactionId = transactionId;
    APCAcceptPkt->callSrcDestType = callSrcDestType;
    //update stats
    //TODO

    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &APCAcceptMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0, //sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        bsNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        APCAcceptMsg,
        CELLULAR_PD_SM,
        CELLULAR_ABSTRACT_SM_ACTIVATE_PDP_CONTEXT_ACCEPT);

    if (DEBUG_SM && callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW SM: builtd and sent activate PDP context"
            "accept for MS %d  to BS %d message\n",
            node->getNodeTime(),
            node->nodeId,
            appSrcNodeId,
            bsNodeId);
        fflush(stdout);
    }
    if (DEBUG_SM &&
        callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW SM: builtd and sent activate PDP context"
            "accept for MS %d  to BS %d message\n",
            node->getNodeTime(), node->nodeId, appDestNodeId, bsNodeId);
        fflush(stdout);
    }

}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractScSendDeactivatePDPContextAcceptMsg
// LAYER      :: Layer3
// PURPOSE    :: Send Deactivate PDP Context Accept Msg
// PARAMETERS ::
// + node                      : Node*        : Pointer to node.
// + msg                       : Message*     : Message to be handled
// + transactionId             : int          : Transaction Id
// + appId                     : int          : Application Id
// + appSrcNodeId              : NodeAddress  : Application's src node Id
// + appDestNodeId             : NodeAddress  : Application' dest node id
// + callSrcDestType           : CellularAbstractCallSrcDestType

//                                            : Type of Call src and dest
// + bsNodeId                  : NodeAddress  : BS's bode id
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractScSendDeactivatePDPContextAcceptMsg(
         Node *node,
         Message *msg,
         int transactionId,
         int appId,
         NodeAddress appSrcNodeId,
         NodeAddress appDestNodeId,
         CellularAbstractCallSrcDestType callSrcDestType,
         NodeAddress bsNodeId)

{
    CellularAbstractDeactivatePDPContextAcceptPkt *DPCAcceptPkt;
    Message *DPCAcceptMsg;
    CellularAbstractNetowrkToMacMsgInfo *DPCReqMsgInfo;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;
    DPCReqMsgInfo =
        (CellularAbstractNetowrkToMacMsgInfo *)MESSAGE_ReturnInfo(msg);
    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW SM: in buidling deactivate PDP context"
            "accept message to appsrc %d\n",
            node->getNodeTime(),
            node->nodeId,
            appSrcNodeId);
        fflush(stdout);
    }
    DPCAcceptMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        DPCAcceptMsg,
        sizeof(CellularAbstractDeactivatePDPContextAcceptPkt),
        TRACE_CELLULAR);

    DPCAcceptPkt =
        (CellularAbstractDeactivatePDPContextAcceptPkt *)
        MESSAGE_ReturnPacket(DPCAcceptMsg);

    DPCAcceptPkt->appSrcNodeId = appSrcNodeId;
    DPCAcceptPkt->appDestNodeId = appDestNodeId;
    DPCAcceptPkt->appId = appId;
    DPCAcceptPkt->transactionId = transactionId;
    DPCAcceptPkt->callSrcDestType = callSrcDestType;

    //update stats TODO

    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &DPCAcceptMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0, //sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        bsNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        DPCAcceptMsg,
        CELLULAR_PD_SM,
        CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_ACCEPT);

    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW SM: builtd and sent a deactivate PDP"
            "context accept for MS %d to BS %d message\n",
            node->getNodeTime(),
            node->nodeId,
            appSrcNodeId,
            bsNodeId);
        fflush(stdout);
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractSCSendRequestPDPContextActivationMsg
// LAYER      :: Layer3
// PURPOSE    :: Send request PDP Context activation Msg
// PARAMETERS ::
// + node                      : Node*       : Pointer to node.
// + msg                       : Message*    : Message to be handled
// + transactionId             : int         : Transaction Id
// + appId                     : int         : Application Id
// + appSrcNodeId              : NodeAddress : Application's src node Id
// + appDestNodeId             : NodeAddress : Application' dest node id
// + callSrcDestType           : CellularAbstractCallSrcDestType
//                                           : Type of Call src and dest
// + numChannleRequired        : int         : Number of channle required
// + bandwidthRequired         : double      : Bandwidth requirement
// + appDuration               : clocktype   : Application's duration
// + bsNodeId                  : NodeAddress : BS's bode id
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractSCSendRequestPDPContextActivationMsg(
          Node *node,
          int transactionId,
          int appId,
          CellularAbstractApplicationType appType,
          NodeAddress appSrcNodeId,
          NodeAddress appDestNodeId,
          CellularAbstractCallSrcDestType callSrcDestType,
          int numChannelRequired,
          double bandwidthRequired,
          clocktype appDuration,
          NodeAddress bsNodeId)

{
    CellularAbstractRequestPDPContextActivationPkt *reqPDPActivationPkt;
    Message *reqPDPActivationMsg;

    CellularLayer3Data *nwCellularData;;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;


    if (DEBUG_SM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW SM: in buidling request PDP context"
            "activation message to appdest %d\n",
             node->getNodeTime(),
             node->nodeId,
             appDestNodeId);
        fflush(stdout);

    }
    reqPDPActivationMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        reqPDPActivationMsg,
        sizeof(CellularAbstractRequestPDPContextActivationPkt),
        TRACE_CELLULAR);

    reqPDPActivationPkt =
        (CellularAbstractRequestPDPContextActivationPkt *)
        MESSAGE_ReturnPacket(reqPDPActivationMsg);

    reqPDPActivationPkt->appSrcNodeId = appSrcNodeId;
    reqPDPActivationPkt->appDestNodeId = appDestNodeId;
    reqPDPActivationPkt->appId = appId;
    reqPDPActivationPkt->appType = appType;
    reqPDPActivationPkt->transactionId = transactionId;
    reqPDPActivationPkt->callSrcDestType = callSrcDestType;
    reqPDPActivationPkt->appDuration = appDuration;
    reqPDPActivationPkt->bandwidthRequired = bandwidthRequired;
    reqPDPActivationPkt->numChannelRequired = numChannelRequired;

    //update stats
    //TODO

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &reqPDPActivationMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,//wired link
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        bsNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        reqPDPActivationMsg,
        CELLULAR_PD_SM,
        CELLULAR_ABSTRACT_SM_REQUEST_PDP_CONTEXT_ACTIVATION);

    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW SM: builtd and "
            "send request PDP context activation"
            "message for MS %d to BS %d message with transId %d\n",
            node->getNodeTime(),
            node->nodeId,
            appDestNodeId,
            bsNodeId,
            transactionId);
        fflush(stdout);
    }
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractScSendCallProceedingMsg
// LAYER      :: Layer3
// PURPOSE    :: Send call proceeding Msg
// PARAMETERS ::
// + node                      : Node*        : Pointer to node.
// + msg                       : Message*     : Message to be handled
// + transactionId             : int          : Transaction Id
// + appId                     : int          : Application Id
// + appSrcNodeId              : NodeAddress  : Application's src node Id
// + appDestNodeId             : NodeAddress  : Application' dest node id
// + bsNodeId                  : NodeAddress  : BS's bode id
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractScSendCallProceedingMsg(
        Node *node,
        Message *msg,
        int transactionId,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        NodeAddress bsNodeId)

{
    CellularAbstractCallProceedingPkt *callProcPkt;
    Message *callProcMsg;
    CellularAbstractNetowrkToMacMsgInfo *callSetupMsgInfo;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    callSetupMsgInfo =
        (CellularAbstractNetowrkToMacMsgInfo *)MESSAGE_ReturnInfo(msg);

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW CC: in buidling call proceeding"
            "message to appsrc %d\n",
            node->getNodeTime(),
            node->nodeId,
            appSrcNodeId);
        fflush(stdout);
    }
    callProcMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc (node,
                        callProcMsg,
                        sizeof(CellularAbstractCMServiceAcceptPkt),
                        TRACE_CELLULAR);

    callProcPkt =
        (CellularAbstractCallProceedingPkt *)
        MESSAGE_ReturnPacket(callProcMsg);

    callProcPkt->appSrcNodeId = appSrcNodeId;
    callProcPkt->appDestNodeId = appDestNodeId;
    callProcPkt->appId = appId;
    callProcPkt->transactionId = transactionId;

    //update stats
    nwCellularAbstractScInfo->stats.numCallProceedingSent ++;

    //send the cm service req to mac
    //the following part are only use for implementation purpose,
    //it should be change to reflect the real wired link interface
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callProcMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0, //sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        bsNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callProcMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CALL_PROCEEDING);

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW CC: builtd and sent a call"
            "proceeding for MS %d to BS %d message\n",
            node->getNodeTime(), node->nodeId, appSrcNodeId, bsNodeId);
        fflush(stdout);
    }
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractScSendCallProceedingMsg
// LAYER      :: Layer3
// PURPOSE    :: Send call proceeding Msg
// PARAMETERS ::
// + node                      : Node*       : Pointer to node.
// + transactionId             : int         : Transaction Id
// + appId                     : int         : Application Id
// + appType                   : CellularAbstractApplicationType
//                                           : Application type
// + appSrcNodeId              : NodeAddress : Application's src node Id
// + appDestNodeId             : NodeAddress : Application' dest node id
// + callSrcDestType           : CellularAbstractCallSrcDestType
//                                           : Type of Call src and dest
// + numChannleRequired        : int         : Number of channle required
// + bandwidthRequired         : double      : Bandwidth requirement
// + bsNodeId                  : NodeAddress : BS's bode id
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractScSendSetupMsg(
        Node *node,
        int transactionId,
        int appId,
        CellularAbstractApplicationType appType,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        int numChannelRequired,
        double bandwidthRequired,
        NodeAddress bsNodeId)
{
    int itemIndex;
    CellularAbstractCallSetupPkt *callSetupPkt;
    Message *callSetupMsg;
    CellularAbstractGenericTimerInfo timerInfo;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    ERROR_Assert(
        callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
        "SC only can send setup for MT call");

    //the appInfo is create on behalf the dest
    ERROR_Assert(
        CellularAbstractScLookForAppInfoItem(
            node,
            transactionId,
            appDestNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo need to send cal lsetup msg");



    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW CC: build a CAll"
            "SETUP message for MT call\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    callSetupMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        callSetupMsg,
                        sizeof(CellularAbstractCallSetupPkt),
                        TRACE_CELLULAR);

    callSetupPkt =
        (CellularAbstractCallSetupPkt *)MESSAGE_ReturnPacket(callSetupMsg);
    callSetupPkt->appId = appId;
    callSetupPkt->transactionId = transactionId;
    callSetupPkt->appType = appType;
    callSetupPkt->appSrcNodeId = appSrcNodeId;
    callSetupPkt->appDestNodeId = appDestNodeId;
    callSetupPkt->destBsNodeId = bsNodeId;
    callSetupPkt->callSrcDestType = callSrcDestType;
    callSetupPkt->numChannelRequired = numChannelRequired;
    callSetupPkt->bandwidthRequired = bandwidthRequired;

    //update stats
    nwCellularAbstractScInfo->stats.numMTCallsetupSent ++;
    //send to mac
    //the following part are only use for implementation purpose,
    //it should be change to reflect the real wired link interface
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callSetupMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0, //TODO: change to sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        bsNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callSetupMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_SETUP);

    //start timer 303
    timerInfo.srcNodeId = appDestNodeId;//dest node
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T303Timer;
    timerInfo.transactionId = transactionId;
    nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT303 =
        CellularAbstractLayer3StartTimer(
            node,
            DefaultCellularAbstractCallControl_T303Time,
            &timerInfo,
            sizeof(CellularAbstractGenericTimerInfo));

    //update the Cc state
    nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
        CELLULAR_ABSTRACT_NW_CC_STATE_CALL_PRESENT;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW CC: sending a "
            "MT CAll SETUP message to BS %d\n",
            node->getNodeTime(), node->nodeId, bsNodeId);
        fflush(stdout);
    }
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractScSendConnectAckMsg
// LAYER      :: Layer3
// PURPOSE    :: Send call connect ack Msg
// PARAMETERS ::
// + node                      : Node*        : Pointer to node.
// + transactionId             : int          : Transaction Id
// + appId                     : int          : Application Id
// + callSrcDestType           : CellularAbstractCallSrcDestType
//                                            : Type of Call src and dest
// + appSrcNodeId              : NodeAddress  : Application's src node Id
// + srcBsNodeId               : NodeAddress  : Src's bS's bode id
// + appDestNodeId             : NodeAddress  : Application' dest node id
// + destBsNodeId              : NodeAddress  : Dest's bS's bode id
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractScSendConnectAckMsg(
        Node *node,
        int transactionId,
        int appId,
        CellularAbstractCallSrcDestType callSrcDestType,
        NodeAddress appSrcNodeId,
        NodeAddress srcBsNodeId,
        NodeAddress appDestNodeId,
        NodeAddress destBsNodeId)
{
    CellularAbstractCallConnectAckPkt *callConnectAckPkt;
    Message *callConnectAckMsg;
    int itemIndex;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    ERROR_Assert(
        callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
        "SC only can send setup for MT call");

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW CC: build a CAll Connect"
            "ACk message for MT call\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
    callConnectAckMsg
        = MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        callConnectAckMsg,
        sizeof(CellularAbstractCallConnectAckPkt),
        TRACE_CELLULAR);

    callConnectAckPkt =
        (CellularAbstractCallConnectAckPkt *)
        MESSAGE_ReturnPacket(callConnectAckMsg);

    callConnectAckPkt->appId = appId;
    callConnectAckPkt->transactionId = transactionId;
    callConnectAckPkt->appSrcNodeId = appSrcNodeId;
    callConnectAckPkt->srcBsNodeId = srcBsNodeId;
    callConnectAckPkt->appDestNodeId = appDestNodeId;
    callConnectAckPkt->destBsNodeId = destBsNodeId;
    callConnectAckPkt->callSrcDestType = callSrcDestType;

    //send to mac
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callConnectAckMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp index
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        callConnectAckPkt->destBsNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callConnectAckMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT_ACKNOWLEDGE);

    //update the Cc state
    ERROR_Assert(
        CellularAbstractScLookForAppInfoItem(
            node,
            transactionId,
            appDestNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo need to send call ack msg");

    nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
        CELLULAR_ABSTRACT_NW_CC_STATE_ACTIVE;

    //update stats
    nwCellularAbstractScInfo->stats.numMTCallConnectAckSent ++;
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW CC: sending "
            "a MT CAll COONET ACK message\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractScSendCallReleaseMsg
// LAYER      :: Layer3
// PURPOSE    :: Send call release Msg
// PARAMETERS ::
// + node                      : Node*        : Pointer to node.
// + appId                     : int          : Application Id
// + appSrcNodeId              : NodeAddress  : Application's src node Id
// + appDestNodeId             : NodeAddress  : Application' dest node id
// + callSrcDestType           : CellularAbstractCallSrcDestType
//                                            : Type of Call src and dest
// + callReleaseType           : CellularAbstractCallReleaseType
//                                            : Type of call release
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractScSendCallReleaseMsg(
        Node *node,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        CellularAbstractCallReleaseType callReleaseType)
{
    CellularAbstractCallReleasePkt *callReleasePkt;
    Message *callReleaseMsg;
    int itemIndex;
    int transactionId;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    callReleaseMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);//this should be change later

    MESSAGE_PacketAlloc(node,
                        callReleaseMsg,
                        sizeof(CellularAbstractCallReleasePkt),
                        TRACE_CELLULAR);

    ERROR_Assert(
        CellularAbstractScLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            &itemIndex,
            &transactionId) == TRUE,
        "cannot find the appInfo need to send call release msg");

    callReleasePkt =
        (CellularAbstractCallReleasePkt *)
        MESSAGE_ReturnPacket(callReleaseMsg);

    callReleasePkt->appId = appId;
    callReleasePkt->transactionId = transactionId;
    callReleasePkt->appSrcNodeId = appSrcNodeId;
    callReleasePkt->appDestNodeId = appDestNodeId;
    callReleasePkt->callSrcDestType = callSrcDestType;
    callReleasePkt->callReleaseType = callReleaseType;

    //send to
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callReleaseMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0, //sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);

    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callReleaseMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_RELEASE);

    //update stats
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        nwCellularAbstractScInfo->stats.numMOCallReleaseByNwSent ++;
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d: send a call MO"
                "release by network to ms\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }
    else if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        nwCellularAbstractScInfo->stats.numMTCallReleaseByMwSent ++;
        if (DEBUG_CC)
        {
            printf("at %015" TYPES_64BITFMT "d node %d: send a "
            "MT call release by network to ms\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractScSendCallReleaseCompleteMsg
// LAYER      :: Layer3
// PURPOSE    :: Send call release complete Msg
// PARAMETERS ::
// + node                      : Node*       : Pointer to node.
// + appId                     : int         : Application Id
// + appSrcNodeId              : NodeAddress : Application's src node Id
// + appDestNodeId             : NodeAddress : Application' dest node id
// + callSrcDestType           : CellularAbstractCallSrcDestType

//                                           : Type of Call src and dest
// + callReleaseCompleteType   : CellularAbstractCallReleaseCompleteType
//                                           : Type of call release complete
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractScSendCallReleaseCompleteMsg(
        Node *node,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        CellularAbstractCallReleaseCompleteType callReleaseCompleteType)
{
    int transactionId;
    int itemIndex;
    CellularAbstractCallReleaseCompletePkt *callRelCompPkt;
    Message *callRelCompMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData = (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    callRelCompMsg = MESSAGE_Alloc(
                        node,
                        MAC_LAYER,
                        MAC_PROTOCOL_CELLULAR,
                        MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        callRelCompMsg,
                        sizeof(CellularAbstractCallReleaseCompletePkt),
                        TRACE_CELLULAR);
    callRelCompPkt =
        (CellularAbstractCallReleaseCompletePkt *)
        MESSAGE_ReturnPacket(callRelCompMsg);

    ERROR_Assert(
        CellularAbstractScLookForAppItemByAppId(node,
                                            appId,
                                            appSrcNodeId,
                                            appDestNodeId,
                                            callSrcDestType,
                                            &itemIndex,
                                            &transactionId) ==TRUE,
        "cannot find the appInfo need to send call release complete msg");

    callRelCompPkt->appId = appId;
    callRelCompPkt->appSrcNodeId = appSrcNodeId;
    callRelCompPkt->appDestNodeId = appDestNodeId;
    callRelCompPkt->callSrcDestType = callSrcDestType;
    callRelCompPkt->callReleaseCompleteType = callReleaseCompleteType;
    callRelCompPkt->transactionId = transactionId;

    //send to
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callRelCompMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0, //sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);

    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callRelCompMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_RELEASE_COMPLETE);

    //update stat
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        //update stats
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d SC send a MT call release"
                "complete by network to dest's BS %d\n",
                node->getNodeTime(),
                node->nodeId,
                nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);
            fflush(stdout);
        }
    }
    else if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        //update stats
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d SC send a MO call Release complete"
                "by network to src's BS %d\n",
                node->getNodeTime(),
                node->nodeId,
                nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);
            fflush(stdout);
        }
    }
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractScSendCallDisconnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Send call disconnect Msg
// PARAMETERS ::
// + node                      : Node*        : Pointer to node.
// + transactionId             : int          : Transaction Id
// + appId                     : int          : Application Id
// + appSrcNodeId              : NodeAddress  : Application's src node Id
// + appDestNodeId             : NodeAddress  : Application' dest node id
// + callSrcDestType           : CellularAbstractCallSrcDestType
//                                            : Type of Call src and dest
// + callDisconnectType        : CellularAbstractCallDisconnectType
//                                            : Type of call disconnect
// + callDiscCause             : CellularAbstractCallDisconectCauseType
//                                            : call disconnect cause
// + nextHopId                 : NodeAddress  : Next hop's id
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractScSendCallDisconnectMsg(
        Node *node,
        int appId,
        int transactionId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        CellularAbstractCallDisconnectType callDisconnectType,
        CellularAbstractCallDisconectCauseType callDiscCause,
        NodeAddress nextHopId)
{
    CellularAbstractCallDisconnectPkt *callDisconnectPkt;
    Message *callDisconnectMsg;
    int itemIndex;
    int callTransactionId;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData = (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    callDisconnectMsg = MESSAGE_Alloc(
                            node,
                            MAC_LAYER,
                            MAC_PROTOCOL_CELLULAR,
                            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        callDisconnectMsg,
                        sizeof(CellularAbstractCallDisconnectPkt),
                        TRACE_CELLULAR);

    callDisconnectPkt =
        (CellularAbstractCallDisconnectPkt *)
        MESSAGE_ReturnPacket(callDisconnectMsg);

    callDisconnectPkt->appId = appId;
    callDisconnectPkt->appSrcNodeId = appSrcNodeId;
    callDisconnectPkt->appDestNodeId = appDestNodeId;
    callDisconnectPkt->callSrcDestType = callSrcDestType;
    callDisconnectPkt->callDisconnectType = callDisconnectType;
    callDisconnectPkt->callDiscCause = callDiscCause;
    callDisconnectPkt->transactionId = transactionId;

    ERROR_Assert(
        CellularAbstractScLookForAppItemByAppId(node,
                                            appId,
                                            appSrcNodeId,
                                            appDestNodeId,
                                            callSrcDestType,
                                            &itemIndex,
                                            &callTransactionId) == TRUE,
        "cannot find the appInfo to send call disconnect msg");
    //send to
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callDisconnectMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0, //sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);

    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callDisconnectMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_DISCONNECT);

    nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
        CELLULAR_ABSTRACT_NW_CC_STATE_DISCONNECT_INDICATION;

    if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        //update stats
        nwCellularAbstractScInfo->stats.numMTCallDisconnectByNwSent ++;
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d SC send a MT call disconnection"
                "by network to dest's BS %d nexthop %d "
                "for call src %d dest %d\n",
                node->getNodeTime(),
                node->nodeId,
                nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId,
                nextHopId,
                appSrcNodeId,
                appDestNodeId);
            fflush(stdout);
        }
    }
    else if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        nwCellularAbstractScInfo->stats.numMOCallDisconnectByNwSent ++;
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d SC send a MO call disconnection"
                "by network to src's BS %d / nexthop %d "
                "for call src %d dest %d\n",
                node->getNodeTime(),
                node->nodeId,
                nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId,
                nextHopId,
                appSrcNodeId,
                appDestNodeId);
            fflush(stdout);
        }
    }
}
//*************************************************************************
// /**
// FUNCTION   ::
//             CellularAbstractScSendCallDisconnectionIndicationToRemoteUser
// LAYER      :: Layer3
// PURPOSE    :: Send call disconnect indication to remote user
// PARAMETERS ::
// + node                      : Node*       : Pointer to node.
// + appId                     : int         : Application Id
// + appSrcNodeId              : NodeAddress : Application's src node Id
// + appDestNodeId             : NodeAddress : Application' dest node id
// + callSrcDestType           : CellularAbstractCallSrcDestType
//                                           : Type of Call src and dest
// + callDisconnectType        : CellularAbstractCallDisconnectType
//                                           : Type of call disconnect
// + callDiscCause             : CellularAbstractCallDisconectCauseType
//                                           : disconnect cause
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractScSendCallDisconnectionIndicationToRemoteUser(
        Node *node,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        CellularAbstractCallDisconnectType callDisconnectType,
        CellularAbstractCallDisconectCauseType callDiscCause)
{
    int lac;
    CellularLayer3Data  *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d ready to send call disc "
            "to remote for src %d dest %d"
            "callsrcdesttype %d calldisType %d calldisccause %d\n",
            node->getNodeTime(),
            node->nodeId, appSrcNodeId, appDestNodeId, callSrcDestType,
            callDisconnectType, callDiscCause);
        fflush(stdout);
    }

    //ONLY MS initiated call lcear will come here
    //the disconnect is first initiatd by the MO's MS
    if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {   //ms-bs1-SC(here)-bs2(could be different from bs1)-ms
        //initizte the call clear for the other side of the call

        if (CellularAbstractScLookUpMsLocation(
            node, appDestNodeId, &lac)==TRUE)
            //MT's MS and MO's Ms in the same SC area,send to MT's BS
        {
            //get the appInfo
            int mtItemIndex;
            int mtTransactionId;

            if (CellularAbstractScLookForAppItemByAppId(
                    node, appId, appSrcNodeId, appDestNodeId,
                    CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
                    &mtItemIndex, &mtTransactionId) == FALSE)
            {
                if (DEBUG_CC)
                {
                    printf(
                        "at %015" TYPES_64BITFMT "d node %d:MT call appId %d src %d dest %d"
                        "item has been reset due to handoff/poweroff\n",
                        node->getNodeTime(),
                        node->nodeId,
                        appId,
                        appSrcNodeId,
                        appDestNodeId);
                    fflush(stdout);
                }
                return;
            }

            //if the dest's MS is in handoff,
            //the disconnect msg shuld be delayed
            if (nwCellularAbstractScInfo->
                    scAppInfo[mtItemIndex].isHandoverInProgress == TRUE)
            {
                //send the dest's MSC (though they are the same)
                //a disconnect indicaion
                Message *callDiscIndicationMsg;
                CellularAbstractCallDisconnectIndicationPkt
                    *callIndicationPkt;

                callIndicationPkt =
                    (CellularAbstractCallDisconnectIndicationPkt *)
                    MEM_malloc(
                       sizeof(CellularAbstractCallDisconnectIndicationPkt));

                callIndicationPkt->appId = appId;
                callIndicationPkt->appSrcNodeId = appSrcNodeId;
                callIndicationPkt->appDestNodeId = appDestNodeId;
                callIndicationPkt->callDisconnectType =
                    CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_NETWORK;

                callIndicationPkt->callSrcDestType =
                    CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL;

                //for the dest's side

                callIndicationPkt->callDiscCause = callDiscCause;

                CellularAbstractLayer3BuildMessage(
                    node,
                    &callDiscIndicationMsg,
                    NETWORK_LAYER,
                    NETWORK_PROTOCOL_CELLULAR,
                    MSG_NETWORK_CELLULAR_PollHandoverForCallManagement,
                    callIndicationPkt,
                    sizeof(CellularAbstractCallDisconnectIndicationPkt));

                CellularAbstractAddLayer3MsgHeader(
                    node,
                    &callDiscIndicationMsg,
                    CELLULAR_PD_CC,
                    CELLULAR_ABSTRACT_CC_CALL_DISCONNECT_INDICATION);

                MESSAGE_Send(
                    node,
                    callDiscIndicationMsg,
                    CELLULAR_ABSTRACT_HANDOVER_END_POLLING_INTERVAL);
                MEM_free(callIndicationPkt);
                if (DEBUG_HANDOVER)
                {
                    printf(
                        "at %015" TYPES_64BITFMT "d node %d dest Ms %d "
                        "HO--hanndover is ongoing,"
                        "disc an application need to wait...\n",
                        node->getNodeTime(),
                        node->nodeId,
                        appDestNodeId);
                    fflush(stdout);
                }
                return;
            }

            if (nwCellularAbstractScInfo->
                    scAppInfo[mtItemIndex].nwCcState ==
                    CELLULAR_ABSTRACT_NW_CC_STATE_NULL
                || nwCellularAbstractScInfo->
                    scAppInfo[mtItemIndex].nwCcState ==
                    CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST)
            {
                return;
            }
            else if (nwCellularAbstractScInfo->
                    scAppInfo[mtItemIndex].nwCcState ==
                    CELLULAR_ABSTRACT_NW_CC_STATE_CALL_DELIVERED
                || nwCellularAbstractScInfo->
                    scAppInfo[mtItemIndex].nwCcState ==
                    CELLULAR_ABSTRACT_NW_CC_STATE_CALL_PRESENT
                || nwCellularAbstractScInfo->
                    scAppInfo[mtItemIndex].nwCcState ==
                    CELLULAR_ABSTRACT_NW_CC_STATE_CONNECT_REQUEST
                || nwCellularAbstractScInfo->
                    scAppInfo[mtItemIndex].nwCcState ==
                    CELLULAR_ABSTRACT_NW_CC_STATE_MOBILE_TERM_CALL_CONFIRMED
                || nwCellularAbstractScInfo->
                    scAppInfo[mtItemIndex].nwCcState ==
                    CELLULAR_ABSTRACT_NW_CC_STATE_ACTIVE)
            {

                CellularAbstractGenericTimerInfo timerInfo;

                //stop all call contro ltimer
                CellularAbstractScStopCallControlTimer(node, mtItemIndex);

                //send local ms a diconnect msg
                CellularAbstractScSendCallDisconnectMsg(
                    node,
                    appId,
                    mtTransactionId,
                    appSrcNodeId,
                    appDestNodeId,
                    CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
                    CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_NETWORK,
                    callDiscCause,
                    nwCellularAbstractScInfo->
                        scAppInfo[mtItemIndex].bsNodeId);

                //start timer T305
                timerInfo.srcNodeId = appDestNodeId;
                timerInfo.timerType = MSG_NETWORK_CELLULAR_T305Timer;
                timerInfo.transactionId = mtTransactionId;

                nwCellularAbstractScInfo->scAppInfo[mtItemIndex].timerT305 =
                    CellularAbstractLayer3StartTimer(
                        node,
                        DefaultCellularAbstractCallControl_T305Time,
                        &timerInfo,
                        sizeof(CellularAbstractGenericTimerInfo));
            }

            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d SC node %d CC: MO and MT in then same SC area,"
                    "initiate a MT CALL disconnect by NETWORK to MT's bs %d\n",
                    node->getNodeTime(), node->nodeId,
                    nwCellularAbstractScInfo->scAppInfo[mtItemIndex].bsNodeId);
                fflush(stdout);
            }

        }
        else //ms-bs-SC1(here)-gateway-sc2-bs-ms or
             //ms-bs-sc(here)-gateway-aggregated
        {
            CellularAbstractCallDisconnectIndicationPkt *callIndicationPkt;
            NodeAddress nextHopId;

            callIndicationPkt =
                (CellularAbstractCallDisconnectIndicationPkt *)
                MEM_malloc(
                    sizeof(CellularAbstractCallDisconnectIndicationPkt));

            callIndicationPkt->appId = appId;
            callIndicationPkt->appSrcNodeId = appSrcNodeId;
            callIndicationPkt->appDestNodeId = appDestNodeId;
            callIndicationPkt->callDisconnectType =
                CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_NETWORK;

            callIndicationPkt->callSrcDestType =
                CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;//current type

            callIndicationPkt->callDiscCause = callDiscCause;

            nextHopId=nwCellularAbstractScInfo->gatewayNodeId;

            CellularAbstractSendCallIndication(
                node,
                (void *)callIndicationPkt,
                sizeof(CellularAbstractCallConnectIndicationPkt),
                CELLULAR_ABSTRACT_CALL_DISCONNECT_INDICATION,
                nextHopId);

            MEM_free(callIndicationPkt);
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d SC node %d CC:send MT call or aggregated FT"
                    "disconnect indication to gateway %d\n",
                    node->getNodeTime(), node->nodeId,
                    nextHopId);
                fflush(stdout);
            }
        }
    }
    else if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    //ms-bs-sc1-gateway-SC2(Here)-bs-ms or aggregated-gateway-SC(here)-bs-ms
    {
        //initizte the call clear for the other side of the call
        if (CellularAbstractScLookUpMsLocation(
            node, appSrcNodeId,&lac) == TRUE)
            //MT's MS and MO's Ms in the same SC area,send to MO's BS
        {
            //get the appInfo
            int moItemIndex;
            int moTransactionId;

            if (CellularAbstractScLookForAppItemByAppId(
                    node, appId, appSrcNodeId, appDestNodeId,
                    CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
                    &moItemIndex, &moTransactionId) == FALSE)
            {
                if (DEBUG_CC)
                {
                    printf(
                        "at %015" TYPES_64BITFMT "d node %d: MO call appId %d src%d dest %d"
                        "item has been reset due to handoff/poweroff\n",
                        node->getNodeTime(),
                        node->nodeId,
                        appId,
                        appSrcNodeId,
                        appDestNodeId);
                    fflush(stdout);
                }
                return;
            }

            //if the src's MS is in handoff,
            //the disconnect msg shuld be delayed
            if (nwCellularAbstractScInfo->
                    scAppInfo[moItemIndex].isHandoverInProgress == TRUE)
            {
                //send the src's MSC (though they are the same)
                //a disconnect indicaion
                Message *callDiscIndicationMsg;
                CellularAbstractCallDisconnectIndicationPkt
                    *callIndicationPkt;

                callIndicationPkt =
                    (CellularAbstractCallDisconnectIndicationPkt *)
                    MEM_malloc(
                        sizeof(CellularAbstractCallDisconnectIndicationPkt));

                callIndicationPkt->appId = appId;
                callIndicationPkt->appSrcNodeId = appSrcNodeId;
                callIndicationPkt->appDestNodeId = appDestNodeId;
                callIndicationPkt->callDisconnectType =
                    CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_NETWORK;

                callIndicationPkt->callSrcDestType =
                    CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;//src's side

                callIndicationPkt->callDiscCause = callDiscCause;

                CellularAbstractLayer3BuildMessage(
                    node,
                    &callDiscIndicationMsg,
                    NETWORK_LAYER,
                    NETWORK_PROTOCOL_CELLULAR,
                    MSG_NETWORK_CELLULAR_PollHandoverForCallManagement,
                    callIndicationPkt,
                    sizeof(CellularAbstractCallDisconnectIndicationPkt));

                CellularAbstractAddLayer3MsgHeader(
                    node,
                    &callDiscIndicationMsg,
                    CELLULAR_PD_CC,
                    CELLULAR_ABSTRACT_CC_CALL_DISCONNECT_INDICATION);

                MESSAGE_Send(
                    node,
                    callDiscIndicationMsg,
                    CELLULAR_ABSTRACT_HANDOVER_END_POLLING_INTERVAL);
                MEM_free(callIndicationPkt);

                if (DEBUG_HANDOVER)
                {
                    printf(
                        "at %015" TYPES_64BITFMT "d node %d src %d HO--handover is ongoing,"
                        "disc an application need to wait...\n",
                        node->getNodeTime(),
                        node->nodeId,
                        appSrcNodeId);
                    fflush(stdout);
                }
                return;
            }
            if (nwCellularAbstractScInfo->
                scAppInfo[moItemIndex].nwCcState ==
                    CELLULAR_ABSTRACT_NW_CC_STATE_NULL
                || nwCellularAbstractScInfo->
                    scAppInfo[moItemIndex].nwCcState ==
                CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST)
            {
                return;
            }
            else if (nwCellularAbstractScInfo->
                    scAppInfo[moItemIndex].nwCcState
                == CELLULAR_ABSTRACT_NW_CC_STATE_CALL_DELIVERED
                || nwCellularAbstractScInfo->
                    scAppInfo[moItemIndex].nwCcState ==
                    CELLULAR_ABSTRACT_NW_CC_STATE_CALL_PRESENT
                || nwCellularAbstractScInfo->
                    scAppInfo[moItemIndex].nwCcState ==
                    CELLULAR_ABSTRACT_NW_CC_STATE_CONNECT_REQUEST
                || nwCellularAbstractScInfo->
                    scAppInfo[moItemIndex].nwCcState ==
                    CELLULAR_ABSTRACT_NW_CC_STATE_MOBILE_TERM_CALL_CONFIRMED
                || nwCellularAbstractScInfo->
                    scAppInfo[moItemIndex].nwCcState ==
                    CELLULAR_ABSTRACT_NW_CC_STATE_ACTIVE)
            {
                CellularAbstractGenericTimerInfo timerInfo;

                //stop all call contro ltimer
                CellularAbstractScStopCallControlTimer(node, moItemIndex);

                CellularAbstractScSendCallDisconnectMsg(
                    node,
                    appId,
                    moTransactionId,
                    appSrcNodeId,
                    appDestNodeId,
                    CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
                    CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_NETWORK,
                    callDiscCause,
                    nwCellularAbstractScInfo->
                        scAppInfo[moItemIndex].bsNodeId);

                //start timer T305
                timerInfo.srcNodeId = appSrcNodeId;
                timerInfo.timerType = MSG_NETWORK_CELLULAR_T305Timer;
                timerInfo.transactionId = moTransactionId;

                nwCellularAbstractScInfo->scAppInfo[moItemIndex].timerT305 =
                    CellularAbstractLayer3StartTimer(
                        node,
                        DefaultCellularAbstractCallControl_T305Time,
                        &timerInfo,
                        sizeof(CellularAbstractGenericTimerInfo));
            }
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d SC node %d CC: MO and MT "
                    "in the same SC area, initiate"
                    "a MO CALL disconnect by NETWORK to MO's bs %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    nwCellularAbstractScInfo->
                        scAppInfo[moItemIndex].bsNodeId);
                fflush(stdout);
            }
        }
        else //ms-bs-SC1-gateway-sc2(here)-bs-ms
        {
            CellularAbstractCallDisconnectIndicationPkt *callIndicationPkt;
            NodeAddress nextHopId;

            callIndicationPkt =
                (CellularAbstractCallDisconnectIndicationPkt *)
                MEM_malloc(
                    sizeof(CellularAbstractCallDisconnectIndicationPkt));

            callIndicationPkt->appId = appId;
            callIndicationPkt->appSrcNodeId = appSrcNodeId;
            callIndicationPkt->appDestNodeId = appDestNodeId;
            callIndicationPkt->callDisconnectType =
                CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_NETWORK;

            callIndicationPkt->callSrcDestType =
                CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL;
            callIndicationPkt->callDiscCause = callDiscCause;

            nextHopId=nwCellularAbstractScInfo->gatewayNodeId;
            CellularAbstractSendCallIndication(
                node,
                (void *)callIndicationPkt,
                sizeof(CellularAbstractCallConnectIndicationPkt),
                CELLULAR_ABSTRACT_CALL_DISCONNECT_INDICATION,nextHopId);

            MEM_free(callIndicationPkt);
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d SC node %d CC:send "
                    "MO call or aggregated FO disconnect"
                    "indication to gateway %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    nextHopId);
                fflush(stdout);
            }
        }
    }
}
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractScSendDeactivatePDPRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Process PDP Deactivation Timer.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + appId            : int               : application Id
// + srcNodeId        : NodeAddress       : Src node Id
// + destNodeId       : NodeAddress       : Dest Node Id
// + callSrcDestType  : CellularAbstractCallSrcDestType: cal lsrc dest type
// + transactionId    : int               : transaction Id for the app
// + callDiscCause    : CellularAbstractCallDisconectCauseType  : disc cause
// + rcvdId           : NodeAddress       : nextHop node id
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractScSendDeactivatePDPRequestMsg(
        Node *node,
        int appId,
        NodeAddress srcNodeId,
        NodeAddress destNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        int transactionId,
        CellularAbstractCallDisconectCauseType callDiscCause,
        NodeAddress rcvdId)
{
    CellularAbstractDeactivatePDPContextRequestPkt *DPCReqPkt;
    Message *DPCReqMsg;

    CellularLayer3Data  *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;


    //build a deactivate PDP context request and send to ms
    DPCReqPkt =
        (CellularAbstractDeactivatePDPContextRequestPkt *)
        MEM_malloc(sizeof(CellularAbstractDeactivatePDPContextRequestPkt));

    DPCReqPkt->appId = appId;
    DPCReqPkt->appSrcNodeId = srcNodeId;
    DPCReqPkt->appDestNodeId = destNodeId;
    DPCReqPkt->callSrcDestType = callSrcDestType;
    DPCReqPkt->transactionId = transactionId;
    DPCReqPkt->callDiscCause = callDiscCause;

    CellularAbstractLayer3BuildMessage(
        node,
        &DPCReqMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        DPCReqPkt,
        sizeof(CellularAbstractDeactivatePDPContextRequestPkt));

    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &DPCReqMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//no meaning
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,//wired
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        rcvdId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        DPCReqMsg,
        CELLULAR_PD_SM,
        CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_REQUEST);

    //free the pkt
    MEM_free(DPCReqPkt);

    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d SC node %d SM: sent "
            "DEACTIVATE_PDP_CONTEXT_REQUEST to ms\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
}
///////////////////////////////////////////////////////////////////////////
//PROCESS FUNTION
//////////////////////////
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractScProcessT301Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T301.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractScProcessT301Timer(Node *node, Message *msg)
{
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d SC node %d process T301\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;
    CellularAbstractGenericTimerInfo *msgInfo;
    int itemIndex;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    msgInfo =
        (CellularAbstractGenericTimerInfo  *)MESSAGE_ReturnInfo(msg);

    if (CellularAbstractScLookForAppInfoItem(
            node,
            msgInfo->transactionId,
            msgInfo->srcNodeId,
            &itemIndex) == FALSE)
    {
        printf("node:%d msid %d\n", node->nodeId, msgInfo->srcNodeId);
        fflush(stdout);
        ERROR_ReportError("No app associate with this T301\n");
    }

    // reset the timer pointer
    nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT301 = NULL;


}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractScProcessT303Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T303.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractScProcessT303Timer(Node *node, Message *msg)
{
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d SC node %d process T303\n",
        node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;
    CellularAbstractGenericTimerInfo *msgInfo;
    int itemIndex;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    msgInfo =
        (CellularAbstractGenericTimerInfo  *)MESSAGE_ReturnInfo(msg);

    if (CellularAbstractScLookForAppInfoItem(
            node,
            msgInfo->transactionId,
            msgInfo->srcNodeId,
            &itemIndex) == FALSE)
    {
        printf("node:%d msid %d\n", node->nodeId, msgInfo->srcNodeId);
        fflush(stdout);
        ERROR_ReportError("No app associate with this T303\n");
    }

    // reset the timer pointer
    nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT303 = NULL;

}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractScProcessT305Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T305.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
#if 0
static
void CellularAbstractScProcessT305Timer(Node *node, Message *msg)
{
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d SC node %d process T305\n",
        node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    CellularAbstractTimer308Info timerInfo;
    CellularAbstractGenericTimerInfo *msgInfo;
    int                             itemIndex;
    int                             transactionId;
    int                             appId;
    NodeAddress                     appSrcNodeId;
    NodeAddress                     appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    msgInfo =
        (CellularAbstractGenericTimerInfo  *)MESSAGE_ReturnInfo(msg);

    if (CellularAbstractScLookForAppInfoItem(
            node,
            msgInfo->transactionId,
            msgInfo->srcNodeId,
            &itemIndex) == FALSE)
    {
        printf("node:%d msid %d\n", node->nodeId, msgInfo->srcNodeId);
        fflush(stdout);
        ERROR_ReportError("No app associate with this T305\n");
    }

    appId =
        nwCellularAbstractScInfo->scAppInfo[itemIndex].appId;

    appSrcNodeId =
        nwCellularAbstractScInfo->scAppInfo[itemIndex].srcMsNodeId;

    appDestNodeId =
        nwCellularAbstractScInfo->scAppInfo[itemIndex].destMsNodeId;

    callSrcDestType =
        nwCellularAbstractScInfo->scAppInfo[itemIndex].callSrcDestType;

    // reset the timer pointer
    nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT305 = NULL;

    //send call release msg to peer
    CellularAbstractScSendCallReleaseMsg(
        node,
        appId,
        appSrcNodeId,
        appDestNodeId,
        callSrcDestType,
        CELLULAR_ABSTRACT_CALL_RELEASE_BY_NETWORK);

    //start timer T308
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        timerInfo.srcNodeId = appSrcNodeId;
    }
    else if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        timerInfo.srcNodeId = appDestNodeId;
    }
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T308Timer;
    timerInfo.transactionId = transactionId;
    timerInfo.numExpiration = 0;
    nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT308 =
        CellularAbstractLayer3StartTimer(
            node,
            DefaultCellularAbstractCallControl_T308Time,
            &timerInfo,
            sizeof(CellularAbstractTimer308Info));

    //change the nw cc state to release request
    nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
        CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST;
}
#endif
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractScProcessT308Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T308.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractScProcessT308Timer(Node *node, Message *msg)
{
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d SC node %d process T308\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    CellularAbstractTimer308Info timerInfo;
    CellularAbstractTimer308Info *msgInfo;
    int numExpiration;
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    msgInfo =
        (CellularAbstractTimer308Info *)MESSAGE_ReturnInfo(msg);

    numExpiration = msgInfo->numExpiration;

    ERROR_Assert(
        CellularAbstractScLookForAppInfoItem(
            node,
            msgInfo->transactionId,
            msgInfo->srcNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this T308");

    appId =
        nwCellularAbstractScInfo->scAppInfo[itemIndex].appId;
    transactionId =
        nwCellularAbstractScInfo->scAppInfo[itemIndex].transactionId;
    appSrcNodeId =
        nwCellularAbstractScInfo->scAppInfo[itemIndex].srcMsNodeId;
    appDestNodeId =
        nwCellularAbstractScInfo->scAppInfo[itemIndex].destMsNodeId;
    callSrcDestType =
        nwCellularAbstractScInfo->scAppInfo[itemIndex].callSrcDestType;

    // reset timer pointer
    nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT308 = NULL;

    numExpiration ++;

    if (numExpiration < 2)
    {
        //send call release msg to peer
        CellularAbstractScSendCallReleaseMsg(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            CELLULAR_ABSTRACT_CALL_RELEASE_BY_NETWORK);

        //start timer T308
        if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            timerInfo.srcNodeId = appSrcNodeId;
        }
        else if (callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {
            timerInfo.srcNodeId = appDestNodeId;
        }
        timerInfo.timerType = MSG_NETWORK_CELLULAR_T308Timer;
        timerInfo.transactionId = transactionId;
        timerInfo.numExpiration = numExpiration;
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT308 =
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractCallControl_T308Time,
                &timerInfo,
                sizeof(CellularAbstractTimer308Info));

        //change the nw cc state to release request
        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST;
    }
    else
    {

        NodeAddress msNodeId;
        NodeAddress msNodeAddr;
        Message *clearComandMsg;

        //TODO:release MM connect

        //change the cc state to null
        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_NULL;

        //initaite the channel release by sending clear command to bs
        //build the clearcommand msg
        if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            msNodeId = appSrcNodeId;
            msNodeAddr = appSrcNodeId;//TODO:give the right value
        }
        else
        {
            msNodeId = appDestNodeId;
            msNodeAddr = appDestNodeId;//TODO:give the right value
        }

        CellularAbstractScBuildClearCommandMsg(
            node,
            &clearComandMsg,
            msNodeId,
            msNodeAddr,
            transactionId,
            CELLULAR_ABSTRACT_NORMAL_EVENT);

        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &clearComandMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//should be sccp id or interface
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,//wired interface
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            clearComandMsg,
            CELLULAR_PD_RR,
            CELLULAR_ABSTRACT_CLEAR_COMMAND);

        //update stats
        nwCellularAbstractScInfo->stats.numClearCommandSent ++;

        //set the appInfo back to unused and
        CellularAbstractScResetAppInfo(node, itemIndex);
    }
}

//********************************************************************
// /**
// FUNCTION   :: CellularAbstractScProcessT310Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T310.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractScProcessT310Timer(Node *node, Message *msg)
{
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d SC node %d process T310\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;
    CellularAbstractGenericTimerInfo *msgInfo;
    int itemIndex;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    msgInfo =
        (CellularAbstractGenericTimerInfo  *)MESSAGE_ReturnInfo(msg);

    if (CellularAbstractScLookForAppInfoItem(
            node,
            msgInfo->transactionId,
            msgInfo->srcNodeId,
            &itemIndex) == FALSE)
    {
        printf("node:%d msid %d\n", node->nodeId, msgInfo->srcNodeId);
        fflush(stdout);
        ERROR_ReportError("No app associate with this T310\n");
    }

    // reset the timer pointer
    nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT310 = NULL;


}
//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractScProcessT313Timer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers T313.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractScProcessT313Timer(Node *node, Message *msg)
{
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d SC node %d process T313\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;
    CellularAbstractGenericTimerInfo *msgInfo;
    int itemIndex;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    msgInfo =
        (CellularAbstractGenericTimerInfo  *)MESSAGE_ReturnInfo(msg);

    if (CellularAbstractScLookForAppInfoItem(
            node,
            msgInfo->transactionId,
            msgInfo->srcNodeId,
            &itemIndex) == FALSE)
    {
        printf("node:%d msid %d\n", node->nodeId, msgInfo->srcNodeId);
        fflush(stdout);
        ERROR_ReportError("No app associate with this T313\n");
    }

    // reset the timer pointer
    nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT313 = NULL;

}
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandlePagingTimer
// LAYER      :: Layer3
// PURPOSE    :: Handle Paging Timer.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractScHandlePagingTimer(Node *node, Message *msg)
{
    int i;
    BOOL found;
    CellularAbstractPagingTimerInfo *timerInfo;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    //update stats TODO
    timerInfo = (CellularAbstractPagingTimerInfo *)MESSAGE_ReturnInfo(msg);

    found = FALSE;

    for (i = 0;i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_SC;i ++)
    {
        if (nwCellularAbstractScInfo->scpagingInfo[i].inUse == TRUE
            && nwCellularAbstractScInfo->scpagingInfo[i].appId ==
                timerInfo->appId
            && nwCellularAbstractScInfo->scpagingInfo[i].appSrcNodeId ==
                    timerInfo->appSrcNodeId
            && nwCellularAbstractScInfo->scpagingInfo[i].appDestNodeId ==
                timerInfo->appDestNodeId)
        {
            found=TRUE;
            break;
        }
    }

    ERROR_Assert(found == TRUE, "cannot find the app in the paging list");

    nwCellularAbstractScInfo->scpagingInfo[i].inUse = FALSE;
    nwCellularAbstractScInfo->scpagingInfo[i].pagingTimer = NULL;
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleLocationUpdateRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle location update request msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractScHandleLocationUpdateRequestMsg(Node *node, Message *msg)
{

    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d MM: receive a location update "
            "request and process it at MSC/VLR\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    CellularAbstractLocationUpdateRequestPkt *locUpdatePkt;
    CellularAbstractNetowrkToMacMsgInfo *locUpdateMsgInfo;
    NodeAddress msNodeId;
    NodeAddress msNodeAddr;
    CellularAbstractLocationUpdatingType locUpdatingType;
    int lac;
    BOOL newMs;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    //get the location information
    locUpdatePkt =
      (CellularAbstractLocationUpdateRequestPkt *)MESSAGE_ReturnPacket(msg);

    lac = locUpdatePkt->lac;
    msNodeId = locUpdatePkt->msNodeId;
    msNodeAddr = locUpdatePkt->msNodeAddr;
    locUpdatingType = locUpdatePkt->locationUpdatingType;

    //update the statistics
    nwCellularAbstractScInfo->stats.numLocationUpdateRcvd ++;


    //fisrt look for msNodeId in the VLR to see
    //if it is a already member in the VLR
    //if find one, update to the current lac if needed.
    //otherwise create one and update to the HLR
    if (CellularAbstractScUpdateVLR(node, lac, msNodeId, msNodeAddr, &newMs))
    {

        //update HLR if needed
        if (newMs==TRUE ||
            locUpdatingType == CELLULAR_ABSTRACT_IMSI_ATTACH ||
            locUpdatingType == CELLULAR_ABSTRACT_IMSI_DETACH)
        {
            CellularAbstractSendHLRUpdateLocationMsg(
                node,
                msNodeId,
                lac,
                locUpdatingType);

            //update stats
            nwCellularAbstractScInfo->stats.numMapdUpdateLocationSent ++;
        }
        //reply with positive answer
        //
        Message *locUpdateAcceptMsg;

        //build the msg
        CellularAbstractScBuildLocationUpdateAcceptMsg(
            node,
            &locUpdateAcceptMsg,
            locUpdatingType,
            lac,
            msNodeId,
            msNodeAddr);

        locUpdateMsgInfo =
            (CellularAbstractNetowrkToMacMsgInfo *)MESSAGE_ReturnInfo(msg);

        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &locUpdateAcceptMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0, //sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            locUpdatePkt->bsNodeId);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            locUpdateAcceptMsg,
            CELLULAR_PD_MM,
            CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_LOCATION_UPDATE_ACCEPT);

        //update stats
        nwCellularAbstractScInfo->stats.numLocationUpdateAcceptSent ++;
        if (DEBUG_MM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d MM: update the new info about"
                "MS %d lac %d at MSC/VLR is successful\n",
                node->getNodeTime(), node->nodeId,
                msNodeId, lac);
            fflush(stdout);
        }
    }
    else //too many nodes in the VLR
    {
        //build negtive answer
        Message *locUpdateRejectMsg;
        //build the msg
        CellularAbstractScBuildLocationUpdateRejectMsg(
            node,
            &locUpdateRejectMsg,
            locUpdatingType,
            lac,
            msNodeId,
            msNodeAddr);

        locUpdateMsgInfo =
            (CellularAbstractNetowrkToMacMsgInfo *)MESSAGE_ReturnInfo(msg);

        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &locUpdateRejectMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0, //sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            locUpdatePkt->bsNodeId);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            locUpdateRejectMsg,
            CELLULAR_PD_MM,
            CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_LOCATION_UPDATE_REJECT);

        //update stats
        nwCellularAbstractScInfo->stats.numLocationUpdateRejectSent ++;
        if (DEBUG_MM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d MM: update the new info about MS %d "
                "lac %d at MSC/VLR is rejected\n",
                node->getNodeTime(), node->nodeId,
                msNodeId, lac);
            fflush(stdout);

        }
    }

    Message *clearComandMsg;

    //build the clear command msg
    CellularAbstractScBuildClearCommandMsg(
        node,
        &clearComandMsg,
        msNodeId,msNodeAddr,
        0,
        CELLULAR_ABSTRACT_NORMAL_EVENT);

    locUpdateMsgInfo =
        (CellularAbstractNetowrkToMacMsgInfo *)MESSAGE_ReturnInfo(msg);

    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &clearComandMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0, //sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        locUpdatePkt->bsNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        clearComandMsg,
        CELLULAR_PD_RR,
        CELLULAR_ABSTRACT_CLEAR_COMMAND);

    //update stats
    nwCellularAbstractScInfo->stats.numClearCommandSent ++;

    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR: send clear command to BS for MS %d\n",
            node->getNodeTime(),
            node->nodeId,
            msNodeId);
        fflush(stdout);
    }
}//CellularAbstractScHandleLocationUpdateRequestMsg
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleMapdCancelLocationMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle MPAD cancel location msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractScHandleMapdCancelLocationMsg(Node *node, Message *msg)
{
    CellularAbstractMapdCancelLocationPkt *mapdCancelLocPkt;
    int i;
    NodeAddress msNodeId;
    BOOL found = FALSE;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
    node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    //update the stats
    nwCellularAbstractScInfo->stats.numMapdCancelLocationRcvd ++;

    mapdCancelLocPkt =
        (CellularAbstractMapdCancelLocationPkt *)
        MESSAGE_ReturnPacket(msg);

    msNodeId = mapdCancelLocPkt->msNodeId;

    for (i = 0;i < CELLULAR_ABSTRACT_MAX_MS_PER_SC;i ++)
    {
        if (nwCellularAbstractScInfo->scVlr[i].inUse == TRUE &&
            nwCellularAbstractScInfo->scVlr[i].msNodeId == msNodeId)
        {
            found = TRUE;
            break;
        }
    }
    //ERROR_Assert(found == TRUE, "HLR and VLR mismatch");
    if (found ==TRUE)
    {
        nwCellularAbstractScInfo->scVlr[i].inUse = FALSE;
    }
    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d SC/VLR MM: cancel the record for MS  %d\n",
            node->getNodeTime(), node->nodeId, msNodeId);
        fflush(stdout);
    }
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleCMServiceRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle CM service request msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractScHandleCMServiceRequestMsg(Node *node, Message *msg)
{

    NodeAddress msNodeId;
    NodeAddress msNodeAddr;
    NodeAddress bsNodeId;
    int transactionId;
    CellularAbstractCMServiceType cmServiceType;
    CellularAbstractCMServiceRequestPkt *cmServiceReqPkt;
    int lac = -1;
    BOOL newMs;
    int bsIndex;
    BOOL found;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    cmServiceReqPkt =
        (CellularAbstractCMServiceRequestPkt *)MESSAGE_ReturnPacket(msg);

    msNodeId = cmServiceReqPkt->msNodeId;
    msNodeAddr = cmServiceReqPkt->msNodeAddr;
    transactionId = cmServiceReqPkt->transactionId;
    cmServiceType = cmServiceReqPkt->cmServiceType;
    bsNodeId = cmServiceReqPkt->bsNodeId;
    nwCellularAbstractScInfo->stats.numCMServiceRequestRcvd ++;

    //check if VLR has this MS before
    found = FALSE;
    for (bsIndex = 0;
        bsIndex < nwCellularAbstractScInfo->numScControlBs; bsIndex ++)
    {
        if (nwCellularAbstractScInfo->
            scControlBsInfo[bsIndex].bsNodeId == bsNodeId)
        {
            lac = nwCellularAbstractScInfo->scControlBsInfo[bsIndex].lac;
            found = TRUE;
            break;
        }
    }
    ERROR_Assert(
        found == TRUE,
        "SC get a CM service req form a BS not"
        "under its control, something is wrong");

    if (CellularAbstractScUpdateVLR(
        node,
        lac,
        msNodeId,
        msNodeAddr,
        &newMs) == TRUE)
    {
        CellularAbstractScSendCMServiceAccpet(
            node,
            msg,
            transactionId,
            msNodeId,
            cmServiceType,
            bsNodeId);

        //update HLR if needed
        //this is for the case, location update failure
        //before the CM service request
        if (newMs == TRUE)
        {
            CellularAbstractSendHLRUpdateLocationMsg(
                node,
                msNodeId,
                lac,
                CELLULAR_ABSTRACT_IMSI_ATTACH);

            //update stas
            nwCellularAbstractScInfo->stats.numMapdUpdateLocationSent ++;
        }
    }
    else
    {
        //TODO CM SERIVE REJECT
    }

    if (DEBUG_MM||DEBUG_PROGRESS)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d MM: handlle CM request from %d "
            "TRansId %d and sent CM service accpet to %d\n",
            node->getNodeTime(), node->nodeId,
            msNodeId,
            transactionId,
            bsNodeId);
        fflush(stdout);
    }
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleDeactivatePDPContextRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Deactivate PDP Context Request msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractScHandleDeactivatePDPContextRequestMsg(Node *node,
                                                            Message *msg)
{
    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d SM:handle DeactivatePDPContextRequest msg\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

    CellularAbstractDeactivatePDPContextRequestPkt  *DPCReqPkt;
    int itemIndex;
    int transactionId;
    int appId;
    CellularAbstractApplicationType appType;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;
    NodeAddress msNodeId;
    NodeAddress msNodeAddr;
    Message *clearComandMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData = (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    DPCReqPkt =
        (CellularAbstractDeactivatePDPContextRequestPkt *)
        MESSAGE_ReturnPacket(msg);

    appId = DPCReqPkt->appId;
    transactionId = DPCReqPkt->transactionId;
    appType = DPCReqPkt->appType;
    appSrcNodeId = DPCReqPkt->appSrcNodeId;
    appDestNodeId = DPCReqPkt->appDestNodeId;
    callSrcDestType = DPCReqPkt->callSrcDestType;
    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d SC node %d SMC: Handleing a deactivate PDP"
            "context request  message for APP between %d and %d\n",
            node->getNodeTime(),
            node->nodeId,
            appSrcNodeId,
            appDestNodeId);
        fflush(stdout);
    }
    if (CellularAbstractScLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            &itemIndex,
            &transactionId) == FALSE)
    {
        if (DEBUG_SM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d SC node %d SMC: the app may be deactivated"
                "due to HO or poweroff already\n",
                node->getNodeTime(),
                node->nodeId);
            fflush(stdout);
        }
        return;
    }

    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
        CELLULAR_ABSTRACT_NW_CC_STATE_NULL ||
        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
            CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST)
    {
        return;
    }
    //send deactivate PDP context accept
    CellularAbstractScSendDeactivatePDPContextAcceptMsg(
        node,
        msg,
        transactionId,
        appId,
        appSrcNodeId,
        appDestNodeId,
        callSrcDestType,
        nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);

    //change the cc state to null
    nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
        CELLULAR_ABSTRACT_NW_CC_STATE_NULL;

    //initaite the channel release by sending clear command to bs
    //build the clearcommand msg
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        msNodeId = appSrcNodeId;
        msNodeAddr = appSrcNodeId;//TODO:give the right value
    }
    else
    {
        msNodeId = appDestNodeId;
        msNodeAddr = appDestNodeId;//TODO:give the right value
    }
    CellularAbstractScBuildClearCommandMsg(
        node,
        &clearComandMsg,
        msNodeId,
        msNodeAddr,
        transactionId,
        CELLULAR_ABSTRACT_NORMAL_EVENT);

    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &clearComandMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//should be sccp id or interface
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,//wired interface
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        clearComandMsg,
        CELLULAR_PD_RR,
        CELLULAR_ABSTRACT_CLEAR_COMMAND);

    //update stats
    nwCellularAbstractScInfo->stats.numClearCommandSent ++;
    if (DEBUG_SM||DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR&SM: send clear command  to MS %d's"
            "Bs and reset the appInfo item\n",
            node->getNodeTime(), node->nodeId,
            msNodeId);
        fflush(stdout);
    }
    //set the appInfo back to unused and
    CellularAbstractScResetAppInfo(node, itemIndex);

    //if it  due to poweroff notify the other end to end the call
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL &&
        DPCReqPkt->callDiscCause ==
        CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_POWEROFF)
    {
        int mtItemIndex;
        int mtTransactionId;
        int lac;
        if (CellularAbstractScLookUpMsLocation(
            node,
            appDestNodeId,
            &lac) == TRUE) //src dest are in the same SC
        {
            if (CellularAbstractScLookForAppItemByAppId(
                    node,
                    appId,
                    appSrcNodeId,
                    appDestNodeId,
                    CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
                    &mtItemIndex,
                    &mtTransactionId) == TRUE)
            {
                if (nwCellularAbstractScInfo->
                        scAppInfo[mtItemIndex].isHandoverInProgress
                        == TRUE)
                {
                    CellularAbstractDeactivationTimerInfo timerInfo;
                    timerInfo.srcNodeId =
                        nwCellularAbstractScInfo->
                        scAppInfo[mtItemIndex].destMsNodeId;

                    timerInfo.transactionId = mtTransactionId;

                    timerInfo.callDiscCause =
                        DPCReqPkt->callDiscCause;

                    timerInfo.timerType =
                        MSG_NETWORK_CELLULAR_PDP_DEACTIVATION_Timer;
                    CellularAbstractLayer3StartTimer(
                        node,
                        CELLULAR_ABSTRACT_HANDOVER_END_POLLING_INTERVAL,
                        &timerInfo,
                        sizeof(CellularAbstractDeactivationTimerInfo));
                    if (DEBUG_POWERONOFF)
                    {
                        printf(
                            "at %015" TYPES_64BITFMT "d node  %d: poweroff "
                            "call dropped, the dest end is "
                            "handover so send deactive tiemr msg for call"
                            "src %d dest %d\n",
                            node->getNodeTime(),
                            node->nodeId,
                            appSrcNodeId,
                            appDestNodeId);
                        fflush(stdout);
                    }

                }
                else if (nwCellularAbstractScInfo->
                                scAppInfo[mtItemIndex].nwCcState !=
                           CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST &&
                           nwCellularAbstractScInfo->
                                scAppInfo[mtItemIndex].nwCcState !=
                                CELLULAR_ABSTRACT_NW_CC_STATE_NULL)
                {
                    CellularAbstractScSendDeactivatePDPRequestMsg(
                        node,

                        nwCellularAbstractScInfo->
                            scAppInfo[mtItemIndex].appId,

                        nwCellularAbstractScInfo->
                            scAppInfo[mtItemIndex].srcMsNodeId,

                        nwCellularAbstractScInfo->
                            scAppInfo[mtItemIndex].destMsNodeId,

                        nwCellularAbstractScInfo->
                            scAppInfo[mtItemIndex].callSrcDestType,

                        nwCellularAbstractScInfo->
                            scAppInfo[mtItemIndex].transactionId,

                        CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_POWEROFF,

                        nwCellularAbstractScInfo->
                            scAppInfo[mtItemIndex].bsNodeId);

                    nwCellularAbstractScInfo->
                        scAppInfo[mtItemIndex].nwCcState =
                        CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST;
                    if (DEBUG_POWERONOFF)
                    {
                        printf(
                            "at %015" TYPES_64BITFMT "d node %d POWEROFF: "
                            "some call droped send "
                            "deactivate PDP to the other end of the "
                            "call src %d dest %d "
                            "callsrcdesttype %d to BS %d\n",
                            node->getNodeTime(),
                            node->nodeId,
                            nwCellularAbstractScInfo->
                            scAppInfo[mtItemIndex].srcMsNodeId,

                            nwCellularAbstractScInfo->
                            scAppInfo[mtItemIndex].destMsNodeId,

                            nwCellularAbstractScInfo->
                                scAppInfo[mtItemIndex].callSrcDestType,
                                nwCellularAbstractScInfo->
                            scAppInfo[mtItemIndex].bsNodeId);
                        fflush(stdout);
                    }
                }
            }
        }
    }

}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleDeactivatePDPContextAcceptMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Deactivate PDP Context accept msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractScHandleDeactivatePDPContextAcceptMsg(Node *node,
                                                           Message *msg)
{
    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d SM:handle DeactivatePDPContextAccpet msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    CellularAbstractDeactivatePDPContextAcceptPkt *DPCAcceptPkt;
    int itemIndex;
    int transactionId;
    int appId;

    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;
    NodeAddress msNodeId;
    NodeAddress msNodeAddr;
    Message *clearComandMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo =
        (CellularAbstractLayer3ScInfo *)
        nwCellularAbstractData->scLayer3Info;

    DPCAcceptPkt =
        (CellularAbstractDeactivatePDPContextAcceptPkt  *)
        MESSAGE_ReturnPacket(msg);

    appId = DPCAcceptPkt->appId;
    transactionId = DPCAcceptPkt->transactionId;
    appSrcNodeId = DPCAcceptPkt->appSrcNodeId;
    appDestNodeId = DPCAcceptPkt->appDestNodeId;
    callSrcDestType = DPCAcceptPkt->callSrcDestType;
    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d SM: Handleing a deactivate PDP context"
            "accpet  message for APP between %d and %d\n",
            node->getNodeTime(),
            node->nodeId,
            appSrcNodeId,
            appDestNodeId);
        fflush(stdout);
    }
    ERROR_Assert(
        CellularAbstractScLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            &itemIndex,
            &transactionId) == TRUE,
        "cannot find the appInfo for this deactivate PDP accept msg");

    //change the cc state to null
    nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
        CELLULAR_ABSTRACT_NW_CC_STATE_NULL;

    //initaite the channel release by sending clear command to bs
    //build the clearcommand msg
    if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        msNodeId = appSrcNodeId;
        msNodeAddr = appSrcNodeId;//TODO:give the right value
    }
    else
    {
        msNodeId = appDestNodeId;
        msNodeAddr = appDestNodeId;//TODO:give the right value
    }

    CellularAbstractScBuildClearCommandMsg(
        node,
        &clearComandMsg,
        msNodeId,
        msNodeAddr,
        transactionId,
        CELLULAR_ABSTRACT_NORMAL_EVENT);

    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &clearComandMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//should be sccp id or interface
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,//wired interface
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        clearComandMsg,
        CELLULAR_PD_RR,
        CELLULAR_ABSTRACT_CLEAR_COMMAND);

    //update stats
    nwCellularAbstractScInfo->stats.numClearCommandSent ++;

    //set the appInfo back to unused and
    CellularAbstractScResetAppInfo(node, itemIndex);
    if (DEBUG_SM||DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR&SM: send clear command  to Ms"
            "%d'sBs and reset the appInfo item\n",
            node->getNodeTime(), node->nodeId, msNodeId);
        fflush(stdout);
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleActivatePDPContextRequestMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle activate PDP Context request msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractScHandleActivatePDPContextRequestMsg(Node *node,
                                                          Message *msg)
{
    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d SM: handle ActivatePDPContextRequest msg\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

    CellularAbstractActivatePDPContextRequestPkt *APCReqPkt;
    int itemIndex;
    int transactionId;
    int appId;
    CellularAbstractApplicationType appType;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    clocktype appDuration;
    CellularAbstractCallSrcDestType callSrcDestType;
    int numChannelRequired;
    double bandwidthRequired;
    int lac;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo =
        nwCellularAbstractData->scLayer3Info;

    APCReqPkt =
        (CellularAbstractActivatePDPContextRequestPkt *)
        MESSAGE_ReturnPacket(msg);

    appId = APCReqPkt->appId;
    transactionId = APCReqPkt->transactionId;
    appType = APCReqPkt->appType;
    appSrcNodeId = APCReqPkt->appSrcNodeId;
    appDestNodeId = APCReqPkt->appDestNodeId;
    callSrcDestType = APCReqPkt->callSrcDestType;
    numChannelRequired = APCReqPkt->numChannelRequired;
    bandwidthRequired = APCReqPkt->bandwidthRequired;
    appDuration = APCReqPkt->appDuration;
    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d SC node %d SM: Handleing a activate PDP context"
            "request  message for APP between %d and %d\n",
            node->getNodeTime(),
            node->nodeId,
            appSrcNodeId,
            appDestNodeId);
        fflush(stdout);
    }
    if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        if (DEBUG_SM || DEBUG_PROGRESS)
        {

            char clockStr[MAX_STRING_LENGTH];
            ctoa(node->getNodeTime(), clockStr);
            printf("at %015" TYPES_64BITFMT "d SC node %d SM: Handleing a MO activate PDP"
                "context request  message for APP between %d and %d\n",
                node->getNodeTime(),
                node->nodeId,
                appSrcNodeId,
                appDestNodeId
                );
            fflush(stdout);
        }

        CellularAbstractScCreateAppInfoItem(
            node, transactionId,appId, appType,
             appSrcNodeId, appDestNodeId, callSrcDestType,
             numChannelRequired, bandwidthRequired, &itemIndex);

        nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId =
            APCReqPkt->srcBsNodeId;

        //since rcvd the pdp request, state go to initial
        //and prepare the pdp accpet msg to MS
        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_CALL_INITIATED;

        //build pdp accpet and send to the Appsrc via bs
        CellularAbstractScSendActivatePDPContextAcceptMsg(
            node, msg, transactionId, appId, appSrcNodeId,
            appDestNodeId, callSrcDestType, APCReqPkt->srcBsNodeId);

        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_ACTIVE;

        //get the destination ms's lac so the sc can page the
        //ms or send a setup to gateway the the setup to
        if (CellularAbstractScLookUpMsLocation(
            node, appDestNodeId, &lac)==TRUE)//found
            //ms-bs1-SC(here)-bs2(can be different from bs1)-ms
        {
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d CC:find the lac for the dest %d is %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    appDestNodeId,
                    lac);
                fflush(stdout);
            }

            //all the bs control this lac should be within
            //the control of this SC for each bsNodeId
            int bsIndex;
            int numBsPaged=0;
            for (bsIndex = 0;
                bsIndex < nwCellularAbstractScInfo->numScControlBs;
                bsIndex ++)
            {
                //comment this for page all the BS
                if (nwCellularAbstractScInfo->
                    scControlBsInfo[bsIndex].lac == lac)
                //build paging message for each bs
                {
                    NodeAddress bsNodeId;
                    bsNodeId =
                        nwCellularAbstractScInfo->
                        scControlBsInfo[bsIndex].bsNodeId;

                    CellularAbstractScSendPagingMsg(
                        node, appId, appSrcNodeId, appDestNodeId,appType,
                        numChannelRequired, bandwidthRequired, appDuration,
                        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL, bsNodeId);

                    numBsPaged ++;

                    if (DEBUG_RR)
                    {
                        printf(
                            "at %015" TYPES_64BITFMT "d node %d RR:send paging to BS %d for dest %d\n",
                            node->getNodeTime(), node->nodeId, bsNodeId, appDestNodeId);
                        fflush(stdout);
                    }
                }
            }
            CellularAbstractScCreatePagingItem(
                node, appId, appSrcNodeId,
                appDestNodeId, appType, numBsPaged);
        }
        else//ms-bs-SC1(here)-gateway-(sc2-bs-ms or aggregated)
        {
            //duplicae PDPContextRequestPkt msg  and forward to gaeway
            CellularAbstractPDPContextIndicationPkt *callIndicationPkt;
            NodeAddress nextHopId;

            callIndicationPkt =
                (CellularAbstractPDPContextIndicationPkt *)
                MEM_malloc(sizeof(CellularAbstractPDPContextIndicationPkt));

            memcpy(
                callIndicationPkt,
                APCReqPkt,
                sizeof(CellularAbstractPDPContextIndicationPkt));

            nextHopId = nwCellularAbstractScInfo->gatewayNodeId;
            CellularAbstractSendCallIndication(
                node,
                (void *)callIndicationPkt,
                sizeof(CellularAbstractPDPContextIndicationPkt),
                CELLULAR_ABSTRACT_PDP_CONTEXT_INDICATION, nextHopId);

            MEM_free(callIndicationPkt);

            if (DEBUG_SM)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d SM: send PDPContextIndication"
                    "to gateway %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    nextHopId);
                fflush(stdout);
            }
        }
    }
    else if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    //it means the after sending the request,
    //the ms had reply with PDP ctivation reuquest
    {
        //CellularAbstractGenericTimerInfo timerInfo;
        if (DEBUG_SM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d  node %d SM: Handleing a "
                "MT activate PDP context request"
                "message for APP between %d and %d\n",
                node->getNodeTime(),
                node->nodeId,
                appSrcNodeId,
                appDestNodeId);
            fflush(stdout);
        }

        ERROR_Assert(
            CellularAbstractScLookForAppInfoItem(
                node, transactionId, appDestNodeId, &itemIndex) == TRUE,
            "caanot find the appInfo for this activate pdp accept msg");

        //since rcvd the pdp request, state go to initial
        //and prepare the pdp accpet msg to MS
        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_CALL_INITIATED;

        //build pdp accpet and send to the Appsrc via bs
        CellularAbstractScSendActivatePDPContextAcceptMsg(
            node, msg, transactionId, appId, appSrcNodeId,
            appDestNodeId, callSrcDestType, APCReqPkt->destBsNodeId);

        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_ACTIVE;

        //scheduel the deactivation timer,
        //it is only to emulate the real traffic
        /*timerInfo.srcNodeId = appDestNodeId;
        timerInfo.transactionId = transactionId;
        timerInfo.timerType = MSG_NETWORK_CELLULAR_PDP_DEACTIVATION_Timer;
        CellularAbstractLayer3StartTimer(
            node,
            APCReqPkt->appDuration,
            &timerInfo,sizeof(CellularAbstractGenericTimerInfo));*/

        CellularAbstractDeactivationTimerInfo *timerInfo;
        nwCellularAbstractScInfo->scAppInfo[itemIndex].deactivatePDPTimer =
            MESSAGE_Alloc(
                node,
                NETWORK_LAYER,
                NETWORK_PROTOCOL_CELLULAR,
                MSG_NETWORK_CELLULAR_TimerExpired);

        MESSAGE_InfoAlloc(
            node,
            nwCellularAbstractScInfo->
                scAppInfo[itemIndex].deactivatePDPTimer,
            sizeof(CellularAbstractDeactivationTimerInfo));

        timerInfo =
            (CellularAbstractDeactivationTimerInfo *) MESSAGE_ReturnInfo(
                nwCellularAbstractScInfo->
                    scAppInfo[itemIndex].deactivatePDPTimer);

        timerInfo->srcNodeId = appDestNodeId;
        timerInfo->transactionId = transactionId;
        timerInfo->callDiscCause = CELLULAR_ABSTRACT_CALL_DISCONNECT_NORMAL;
        timerInfo->timerType = MSG_NETWORK_CELLULAR_PDP_DEACTIVATION_Timer;

        MESSAGE_Send(
            node,
            nwCellularAbstractScInfo->
                scAppInfo[itemIndex].deactivatePDPTimer,
            APCReqPkt->appDuration);
    }
}
//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandlePDPContextIndication
// LAYER      :: Layer3
// PURPOSE    :: Handle PDP Context indication msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractScHandlePDPContextIndication(Node *node,Message *msg)
{
    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d SC node %d SM: Handleing PDPContextIndication\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    CellularAbstractPDPContextIndicationPkt *pdpIndicationPkt;
    int appId;
    CellularAbstractApplicationType appType;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    clocktype appDuration;
    int numChannelRequired;
    double bandwidthRequired;
    int lac = 0;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    pdpIndicationPkt =
        (CellularAbstractPDPContextIndicationPkt *)
        MESSAGE_ReturnPacket(msg);

    appId = pdpIndicationPkt->appId;
    appType = pdpIndicationPkt->appType;
    appSrcNodeId = pdpIndicationPkt->appSrcNodeId;
    appDestNodeId = pdpIndicationPkt->appDestNodeId;

    numChannelRequired = pdpIndicationPkt->numChannelRequired;
    bandwidthRequired = pdpIndicationPkt->bandwidthRequired;
    appDuration = pdpIndicationPkt->appDuration;

    if (DEBUG_SM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d handle PDPD indication APPTYPE =%d\n",
            node->getNodeTime(), node->nodeId, appType);
        fflush(stdout);
    }
    ERROR_Assert(
        CellularAbstractScLookUpMsLocation(
        node, appDestNodeId, &lac) == TRUE,
        "ONLY MT'SC should recv PDP indication");//only found

    //ms-bs1-SC(here)-bs2(can be different from bs1)-ms
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d CC:find the lac for the dest %d is %d\n",
                node->getNodeTime(), node->nodeId, appDestNodeId, lac);
        fflush(stdout);
    }

    //all the bs control this lac should be within the control of this SC
    //for each bsNodeId
    int bsIndex;
    int numBsPaged = 0;
    for (bsIndex = 0;
        bsIndex < nwCellularAbstractScInfo->numScControlBs; bsIndex ++)
    {
        //comment this for paging all BS
        if (nwCellularAbstractScInfo->
            scControlBsInfo[bsIndex].lac == lac)
        //build paging message for each bs
        {
            NodeAddress bsNodeId;
            bsNodeId =
                nwCellularAbstractScInfo->scControlBsInfo[bsIndex].bsNodeId;

            CellularAbstractScSendPagingMsg(
                node, appId, appSrcNodeId, appDestNodeId, appType,
                numChannelRequired, bandwidthRequired, appDuration,
                CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL, bsNodeId);

            numBsPaged ++;
            if (DEBUG_RR)
            {
                printf("at %015" TYPES_64BITFMT "d node %d RR:send "
                    "paging to BS %d for dest %d\n",
                    node->getNodeTime(), node->nodeId, bsNodeId, appDestNodeId);
                fflush(stdout);
            }
        }
    }
    CellularAbstractScCreatePagingItem(
        node,
        appId,
        appSrcNodeId,
        appDestNodeId,
        appType,
        numBsPaged);
}

//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractScProcessPDPDeactivationTimer
// LAYER      :: Layer3
// PURPOSE    :: Process PDP Deactivation Timer.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//****************************************************************************
static
void CellularAbstractScProcessPDPDeactivationTimer(Node *node, Message *msg)
{
    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d SC node %d SM: Handleing deactivation timer\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress srcNodeId;
    NodeAddress destNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;
    NodeAddress msNodeId;

    CellularAbstractDeactivationTimerInfo *timerInfo;

    CellularLayer3Data  *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    timerInfo =
        (CellularAbstractDeactivationTimerInfo *)MESSAGE_ReturnInfo(msg);

    transactionId = timerInfo->transactionId;
    msNodeId = timerInfo->srcNodeId;


    if (CellularAbstractScLookForAppInfoItem(
        node, transactionId, msNodeId, &itemIndex) == FALSE)
    {

        if (DEBUG_SM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d: cannot find the appInfo for this"
                "deactivate PDP timer\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
        return;
    }

    // reset the timer pointer
    nwCellularAbstractScInfo->scAppInfo[itemIndex].deactivatePDPTimer =NULL;

    appId = nwCellularAbstractScInfo->scAppInfo[itemIndex].appId;

    callSrcDestType =
        nwCellularAbstractScInfo->scAppInfo[itemIndex].callSrcDestType;

    srcNodeId =
        nwCellularAbstractScInfo->scAppInfo[itemIndex].srcMsNodeId;

    destNodeId =
        nwCellularAbstractScInfo->scAppInfo[itemIndex].destMsNodeId;

    if (nwCellularAbstractScInfo->
        scAppInfo[itemIndex].isHandoverInProgress == TRUE)
    {
        Message *pdpDeactiveTimer;
        pdpDeactiveTimer = MESSAGE_Duplicate(node, msg);

        MESSAGE_Send(
            node,
            pdpDeactiveTimer,
            CELLULAR_ABSTRACT_HANDOVER_END_POLLING_INTERVAL);
        if (DEBUG_HANDOVER)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d HO--handover is ongoing,"
                "deactivate a PDP for call src %d dest %d"
                "calldest Type %d need to wait...\n",
                node->getNodeTime(),
                node->nodeId, srcNodeId, destNodeId, callSrcDestType);
            fflush(stdout);
        }
        return;
    }

    if (nwCellularAbstractScInfo->
        scAppInfo[itemIndex].nwCcState ==
        CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST ||
        nwCellularAbstractScInfo->
        scAppInfo[itemIndex].nwCcState ==
        CELLULAR_ABSTRACT_NW_CC_STATE_NULL)
    {
        if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d: HO--failure has already start or "
            "finish the deactivation for call "
            "src %d dest %d calldest Type %d\n",
             node->getNodeTime(), node->nodeId,
             srcNodeId, destNodeId, callSrcDestType);
            fflush(stdout);
    }
        return;
    }

    CellularAbstractScSendDeactivatePDPRequestMsg(
        node,
        appId,
        srcNodeId,
        destNodeId,
        callSrcDestType,
        transactionId,
        timerInfo->callDiscCause,
        nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);

    nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
        CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST;
    //update stats TODO

    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d SC node %d SM: Handleing deactivation timer & sent"
            "DEACTIVATE_PDP_CONTEXT_REQUEST to ms\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleCallSetupMsg
// LAYER      :: Layer3
// PURPOSE    :: SC Handle Call Setup Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractScHandleCallSetupMsg(Node *node, Message *msg)
{
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d CC: handle Call Setup msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    CellularAbstractCallSetupPkt *callSetupPkt;
    int itemIndex;
    int transactionId;
    int appId;
    CellularAbstractApplicationType appType;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;
    int numChannelRequired;
    double bandwidthRequired;
    clocktype appDuration;
    int lac = 0;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    //update stats
    nwCellularAbstractScInfo->stats.numMOCallSetupRcvd ++;

    //nwSrcCcState
    callSetupPkt =
        (CellularAbstractCallSetupPkt *)MESSAGE_ReturnPacket(msg);

    transactionId = callSetupPkt->transactionId;
    appId = callSetupPkt->appId;
    appType = callSetupPkt->appType;
    appSrcNodeId = callSetupPkt->appSrcNodeId;
    appDestNodeId = callSetupPkt->appDestNodeId;
    bandwidthRequired = callSetupPkt->bandwidthRequired;
    numChannelRequired = callSetupPkt->numChannelRequired;
    callSrcDestType = callSetupPkt->callSrcDestType;
    appDuration=0;//for voice duration has no meaning
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d CC: Handleing a CALL SETUP"
            "message for APP between %d and %d\n",
            node->getNodeTime(), node->nodeId,
            appSrcNodeId, appDestNodeId);
        fflush(stdout);
    }
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        CellularAbstractScCreateAppInfoItem(
            node,
            transactionId,
            appId,
            appType,//this transaction id coms from src
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            numChannelRequired,
            bandwidthRequired,
            &itemIndex);
        nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId =
            callSetupPkt->srcBsNodeId;

        //since rcvd the setup, state go to inita and
        //prepare the call proceeding msg to MS
        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_CALL_INITIATED;

        //build call proceeding and send to the Appsrc via bs
        CellularAbstractScSendCallProceedingMsg(
            node, msg, transactionId, appId, appSrcNodeId,
            appDestNodeId, callSetupPkt->srcBsNodeId);

        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_MOBILE_ORIG_CALL_PROCEEDING;

        //get the destination ms's lac so the sc can page the ms or
        //send a setup to gateway the the setup to
        if (CellularAbstractScLookUpMsLocation(
                node, appDestNodeId, &lac) == TRUE)//found
        {
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d CC:find the "
                    "lac for the dest %d is %d\n",
                    node->getNodeTime(), node->nodeId, appDestNodeId, lac);
                fflush(stdout);
            }
            //ms-bs1-SC(here)-bs2(can be different from bs1)-ms
            //all the bs control this lac should be within
            //the control of this SC for each bsNodeId
            int bsIndex;
            int numBsPaged=0;

            for (bsIndex = 0;
                bsIndex < nwCellularAbstractScInfo->numScControlBs;
                bsIndex ++)
            {
                //comment this for paging all the BS
                if (nwCellularAbstractScInfo->
                        scControlBsInfo[bsIndex].lac == lac)
                //build paging message for each bs
                {
                    NodeAddress bsNodeId;

                    bsNodeId =
                        nwCellularAbstractScInfo->
                        scControlBsInfo[bsIndex].bsNodeId;

                    CellularAbstractScSendPagingMsg(
                        node,
                        appId,
                        appSrcNodeId,
                        appDestNodeId,
                        callSetupPkt->appType,
                        callSetupPkt->numChannelRequired,
                        callSetupPkt->bandwidthRequired,
                        appDuration,
                        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
                        bsNodeId);

                    numBsPaged ++;
                    if (DEBUG_RR)
                    {
                        printf(
                            "at %015" TYPES_64BITFMT "d node %d RR:send paging "
                            "to BS %d for dest %d\n",
                            node->getNodeTime(),
                            node->nodeId,
                            bsNodeId,
                            appDestNodeId);
                        fflush(stdout);
                    }
                }
            }
            CellularAbstractScCreatePagingItem(
                node,
                appId,
                appSrcNodeId,
                appDestNodeId,
                appType,
                numBsPaged);
        }

        else//ms-bs-SC1(here)-gateway-(sc2-bs-ms or aggregated)
        {
            //duplicae the call setup msg  and forward to gaeway
            CellularAbstractCallSetupIndicationPkt* callIndicationPkt;
            NodeAddress nextHopId;

            callIndicationPkt =
                (CellularAbstractCallSetupIndicationPkt *)
                MEM_malloc(sizeof(CellularAbstractCallSetupIndicationPkt));

            memcpy(
                callIndicationPkt,
                callSetupPkt,
                sizeof(CellularAbstractCallSetupIndicationPkt));
            //in case src's HLr update not finished yet,
            //carry the sc's id for return path
            callIndicationPkt->appSrcScNodeId = node->nodeId;
            nextHopId =
                nwCellularAbstractScInfo->gatewayNodeId;

            CellularAbstractSendCallIndication(
                node,
                (void *)callIndicationPkt,
                sizeof(CellularAbstractCallSetupIndicationPkt),
                CELLULAR_ABSTRACT_CALL_SETUP_INDICATION,
                nextHopId);

            MEM_free(callIndicationPkt);

            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d CC:send call setup indication"
                    "to gateway %d\n",
                    node->getNodeTime(), node->nodeId, nextHopId);
                fflush(stdout);
            }

        }
        //updae the MO nw cc state
        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_MOBILE_ORIG_CALL_PROCEEDING;



    }
    else if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        //ms-bs-sc1-gateway-SC2(here)-bs-ms or
        //aggregated-gateway-SC(here)-bs-ms
        if (DEBUG_CC)
        {
            printf("at %015" TYPES_64BITFMT "d node %d CC: Handleing a "
                "MT CALL(must be a interSC"
                "MO-MT call or FO-MT call) SETUP"
                "message for APP between %d and %d\n",
                node->getNodeTime(),
                node->nodeId,
                appSrcNodeId,
                appDestNodeId);
            fflush(stdout);
        }
        ERROR_Assert(
            CellularAbstractScLookUpMsLocation(
                node, appDestNodeId,&lac) == TRUE,
            "HLR AND SC/VLR foes not match");//found
        {
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d CC: "
                    "find the lac for the dest %d is %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    appDestNodeId,
                    lac);
                fflush(stdout);
            }

            //all the bs control this lac should be within the
            //control of this SC for each bsNodeId
            int bsIndex;
            int numBsPaged=0;
            for (bsIndex = 0;
                bsIndex < nwCellularAbstractScInfo->numScControlBs;
                bsIndex ++)
            {
                //comment this for paging all the BS
                if (nwCellularAbstractScInfo->
                    scControlBsInfo[bsIndex].lac == lac)
                //build paging message for each bs
                {
                    NodeAddress bsNodeId;
                    bsNodeId =
                        nwCellularAbstractScInfo->
                        scControlBsInfo[bsIndex].bsNodeId;

                    CellularAbstractScSendPagingMsg(
                        node,
                        appId,
                        appSrcNodeId,
                        appDestNodeId,
                        callSetupPkt->appType,
                        callSetupPkt->numChannelRequired,
                        callSetupPkt->bandwidthRequired,
                        appDuration,
                        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
                        bsNodeId);

                    numBsPaged++;
                    if (DEBUG_RR)
                    {
                        printf(
                            "at %015" TYPES_64BITFMT "d node %d RR: "
                            "send paging to BS %d for dest %d\n",
                            node->getNodeTime(),
                            node->nodeId,
                            bsNodeId,
                            appDestNodeId);
                        fflush(stdout);
                    }
                }
            }
            CellularAbstractScCreatePagingItem(
                node,
                appId,
                appSrcNodeId,
                appDestNodeId,
                appType,
                numBsPaged);
        }
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleMTCallRejectIndication
// LAYER      :: Layer3
// PURPOSE    :: Sc Handle MT Call Reject Indication.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractScHandleMTCallRejectIndication(Node *node,
                                                    Message *msg)
{
    CellularAbstractMTCallRejectIndication* mtCallRejectPkt;
    CellularAbstractMTCallRejectIndication* outMsgPkt;
    Message* outMsg;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractApplicationType appType;
    int lac;
    BOOL disconnectNeded;
    int moItemIndex = -1;
    int moTransactionId = -1;
    int i;
    BOOL found;

    CellularLayer3Data* nwCellularData;
    CellularAbstractLayer3Data* nwCellularAbstractData;
    CellularAbstractLayer3ScInfo* nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData = (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;


    mtCallRejectPkt =
        (CellularAbstractMTCallRejectIndication *)
        MESSAGE_ReturnPacket(msg);

    appId = mtCallRejectPkt->appId;
    appSrcNodeId = mtCallRejectPkt->appSrcNodeId;
    appDestNodeId = mtCallRejectPkt->appDestNodeId;
    appType = mtCallRejectPkt->appType;
    disconnectNeded = FALSE;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RCVD and handle "
            "MTCallRejectIndication for src %d  dest %d\n",
            node->getNodeTime(),
            node->nodeId,
            appSrcNodeId,
            appDestNodeId);
        fflush(stdout);
    }


    //update the paging info associate with the app
    //at dest's side only received all the
    //reject could a call rejejct send to src
    if (mtCallRejectPkt->callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        found = FALSE;
        for (i = 0;i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_SC;i ++)
        {
            if (nwCellularAbstractScInfo->scpagingInfo[i].inUse == TRUE &&
                nwCellularAbstractScInfo->scpagingInfo[i].appId == appId&&

                nwCellularAbstractScInfo->
                    scpagingInfo[i].appSrcNodeId == appSrcNodeId&&

                nwCellularAbstractScInfo->
                    scpagingInfo[i].appDestNodeId==appDestNodeId)
            {
                found=TRUE;
                break;
            }
        }

        ERROR_Assert(
            found == TRUE,
            "cannot find the app in the paging list");

        nwCellularAbstractScInfo->scpagingInfo[i].numBsResponsed ++;

        if (nwCellularAbstractScInfo->scpagingInfo[i].msResponsed == TRUE)
        {
            return;
        }
        else if (nwCellularAbstractScInfo->
                scpagingInfo[i].msResponsed == FALSE
                &&
                nwCellularAbstractScInfo->scpagingInfo[i].numBsResponsed ==
                    nwCellularAbstractScInfo->scpagingInfo[i].numBsPaged)
        {
            //receive all the negative res,reset the paging info item to
            //unused, send reject to src ms if it is voice
            nwCellularAbstractScInfo->scpagingInfo[i].inUse = FALSE;
            if (nwCellularAbstractScInfo->scpagingInfo[i].pagingTimer != NULL)
            {
                MESSAGE_CancelSelfMsg(
                    node,
                    nwCellularAbstractScInfo->scpagingInfo[i].pagingTimer);

                nwCellularAbstractScInfo->scpagingInfo[i].pagingTimer =NULL;
            }
        }
        else return;
    }

    //only voice call need to notify the src call rejected othe pdp do
    //not need? leave the retrnasmission to high layer
    if (appType == CELLULAR_ABSTRACT_VOICE_PHONE)
    {
        if (mtCallRejectPkt->callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {

            if (CellularAbstractScLookUpMsLocation(
                node, appSrcNodeId, &lac) == TRUE)
            {
                //build msg
                CellularAbstractLayer3BuildMessage(
                    node,
                    &outMsg,
                    MAC_LAYER,
                    MAC_PROTOCOL_CELLULAR,
                    MSG_MAC_CELLULAR_FromNetwork,
                    mtCallRejectPkt,
                    sizeof(CellularAbstractMTCallRejectIndication));

                outMsgPkt =
                    (CellularAbstractMTCallRejectIndication *)
                    MESSAGE_ReturnPacket(outMsg);

                outMsgPkt->callSrcDestType =
                    CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;

                ERROR_Assert(
                    CellularAbstractScLookForAppItemByAppId(
                        node,
                        appId,
                        appSrcNodeId,
                        appDestNodeId,
                        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
                        &moItemIndex,
                        &moTransactionId) == TRUE,
                    "cannot find the appInfo for this MT rejection msg");

                //add wired info
                CellularAbstractAddNetworkToMacMsgInfo(
                    node,
                    &outMsg,
                    CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
                    0,//sccp id
                    CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
                    CELLULAR_ABSTRACT_RECEIVER_SINGLE,

                    nwCellularAbstractScInfo->
                        scAppInfo[moItemIndex].bsNodeId);

                //send to mac
                CellularAbstractSendMsgOverNonCellularLink(
                    node,
                    outMsg,
                    CELLULAR_PD_CC,
                    CELLULAR_ABSTRACT_CC_CALL_REJECT_INDICATION);

                disconnectNeded = TRUE;
                if (DEBUG_CAC || DEBUG_CC)
                {
                    printf(
                        "at %015" TYPES_64BITFMT "d node %d CAC: MO and MT "
                        "in then same SC area, "
                        "forward reject indication for "
                        "call src %d dest %d to MO's bs %d",
                        node->getNodeTime(),
                        node->nodeId,
                        appSrcNodeId,
                        appDestNodeId,
                        nwCellularAbstractScInfo->
                            scAppInfo[moItemIndex].bsNodeId);
                    fflush(stdout);
                }
            }
            else //in differnt sc or FO-MT call,send indication to gateway
            {

                //build msg
                CellularAbstractLayer3BuildMessage(
                    node,
                    &outMsg,
                    MAC_LAYER,
                    MAC_PROTOCOL_CELLULAR,
                    MSG_MAC_CELLULAR_FromNetwork,
                    mtCallRejectPkt,
                    sizeof(CellularAbstractMTCallRejectIndication));

                //add wired info
                CellularAbstractAddNetworkToMacMsgInfo(
                    node,
                    &outMsg,
                    CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
                    0,//sccp id
                    CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
                    CELLULAR_ABSTRACT_RECEIVER_SINGLE,
                    nwCellularAbstractScInfo->gatewayNodeId);

                //send to mac
                CellularAbstractSendMsgOverNonCellularLink(
                    node,
                    outMsg,
                    CELLULAR_PD_CC,
                    CELLULAR_ABSTRACT_CC_CALL_REJECT_INDICATION);

                if (DEBUG_CAC || DEBUG_CC)
                {
                    printf(
                        "at %015" TYPES_64BITFMT "d node %d CAC: interSC call or FO-MT call, "
                        "forward reject indication to gateway\n",
                        node->getNodeTime(), node->nodeId);
                    fflush(stdout);
                }
            }
        }
        else if (mtCallRejectPkt->callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)//if in differnt sc
        {
            //build msg
            CellularAbstractLayer3BuildMessage(
                node,
                &outMsg,
                MAC_LAYER,
                MAC_PROTOCOL_CELLULAR,
                MSG_MAC_CELLULAR_FromNetwork,
                mtCallRejectPkt,
                sizeof(CellularAbstractMTCallRejectIndication));

            outMsgPkt =
                (CellularAbstractMTCallRejectIndication *)
                MESSAGE_ReturnPacket(outMsg);

            ERROR_Assert(
                CellularAbstractScLookForAppItemByAppId(
                    node,
                    appId,
                    appSrcNodeId,
                    appDestNodeId,
                    CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
                    &moItemIndex,
                    &moTransactionId) == TRUE,
                "cannot find the appInfo for this MT reject msg");

            outMsgPkt->callSrcDestType =
                CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;

            //add wired info
            CellularAbstractAddNetworkToMacMsgInfo(
                node,
                &outMsg,
                CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
                0,//sccp id
                CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
                CELLULAR_ABSTRACT_RECEIVER_SINGLE,
                nwCellularAbstractScInfo->
                    scAppInfo[moItemIndex].bsNodeId);

            //send to mac
            CellularAbstractSendMsgOverNonCellularLink(
                node,
                outMsg,
                CELLULAR_PD_CC,
                CELLULAR_ABSTRACT_CC_CALL_REJECT_INDICATION);

            disconnectNeded = TRUE;

            if (DEBUG_CAC || DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d CAC: MO's src's SC rcvd"
                    "the indication from gateway forward to MO's BS\n",
                    node->getNodeTime(),
                    node->nodeId);
                fflush(stdout);
            }
        }

        //send a call disconnect to ms
        if (disconnectNeded == TRUE)
        {
            CellularAbstractGenericTimerInfo timerInfo;

            //stop all call contro ltimer
            CellularAbstractScStopCallControlTimer(node, moItemIndex);

            //send local ms a diconnect msg
            CellularAbstractScSendCallDisconnectMsg(
                node,
                appId,
                moTransactionId,
                appSrcNodeId,
                appDestNodeId,
                CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
                CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_NETWORK,
                CELLULAR_ABSTRACT_CALL_DISCONNECT_MTReject,
                nwCellularAbstractScInfo->scAppInfo[moItemIndex].bsNodeId);

            //start timer T305
            //only src's SC need to disconnect  call
            timerInfo.srcNodeId = appSrcNodeId;
            timerInfo.timerType = MSG_NETWORK_CELLULAR_T305Timer;
            timerInfo.transactionId = moTransactionId;

            nwCellularAbstractScInfo->scAppInfo[moItemIndex].timerT305 =
                CellularAbstractLayer3StartTimer(
                    node,
                    DefaultCellularAbstractCallControl_T305Time,
                    &timerInfo,
                    sizeof(CellularAbstractGenericTimerInfo));

            //change the nw cc state to release request
            nwCellularAbstractScInfo->scAppInfo[moItemIndex].nwCcState =
                CELLULAR_ABSTRACT_NW_CC_STATE_DISCONNECT_REQUEST;

            if (DEBUG_CAC || DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d CAC: MO's src SC "
                    "initiate the call disconect msg\n",
                     node->getNodeTime(), node->nodeId);
                fflush(stdout);
            }
        }
    }
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleCallAlertingMsg
// LAYER      :: Layer3
// PURPOSE    :: Sc Handle Call Alerting Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractScHandleCallAlertingMsg(Node *node,Message *msg)
{
    CellularAbstractGenericTimerInfo timerInfo;
    CellularAbstractCallAlertingPkt *callAlertingPkt;
    CellularAbstractCallSrcDestType callSrcDestType;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    int itemIndex;
    int lac;


    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData
        =(CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    callAlertingPkt =
        (CellularAbstractCallAlertingPkt *)MESSAGE_ReturnPacket(msg);

    //MT case
    appId = callAlertingPkt->appId;
    appSrcNodeId = callAlertingPkt->appSrcNodeId;
    appDestNodeId = callAlertingPkt->appDestNodeId;
    callSrcDestType = callAlertingPkt->callSrcDestType;
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {

        //update stats
        nwCellularAbstractScInfo->stats.numMTCallAlertingRcvd ++;

        //change cc state to call received
        //look for item with AppId,src,dest,and callSrcDestType
        ERROR_Assert(
            CellularAbstractScLookForAppItemByAppId(
                node,
                appId,
                appSrcNodeId,
                appDestNodeId,
                callSrcDestType,
                &itemIndex,
                &transactionId) == TRUE,
            "cannot find the appInfo for this call alerting msg");

        //stop T310
        if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT310 != NULL)
        {
            MESSAGE_CancelSelfMsg(
                node,
                nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT310);

            nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT310 = NULL;
        }

        ////start 301
        timerInfo.srcNodeId = appDestNodeId;
        timerInfo.timerType = MSG_NETWORK_CELLULAR_T301Timer;
        timerInfo.transactionId = transactionId;

        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT301 =
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractCallControl_T301Time,
                &timerInfo,
                sizeof(CellularAbstractGenericTimerInfo));

        //change state
        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_CALL_RECEIVED;

        //find the MO's alerting SC by look up VLR
        //if find(in the same SC, using src node id and appid
        //to locate trasaction id, forward alerting to MO's bs
        if (CellularAbstractScLookUpMsLocation(
            node, appSrcNodeId, &lac) == TRUE)
            //ms-bs1-SC(here)-bs2(can be different from bs1)-ms
        {
            int moItemIndex;
            int moTransactionId;
            Message *moAlertingMsg;
            CellularAbstractCallAlertingPkt *moAlertingPkt;

            ERROR_Assert(
                CellularAbstractScLookForAppItemByAppId(
                    node,
                    appId,
                    appSrcNodeId,
                    appDestNodeId,
                    CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
                    &moItemIndex,
                    &moTransactionId) == TRUE,
                "cannot find the appInfo for this call alerting msg");

            //build msg
            CellularAbstractLayer3BuildMessage(
                node,
                &moAlertingMsg,
                MAC_LAYER,
                MAC_PROTOCOL_CELLULAR,
                MSG_MAC_CELLULAR_FromNetwork,
                callAlertingPkt,
                sizeof(CellularAbstractCallAlertingPkt));

            moAlertingPkt =
                (CellularAbstractCallAlertingPkt *)
                MESSAGE_ReturnPacket(moAlertingMsg);

            moAlertingPkt->callSrcDestType =
                CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;

            moAlertingPkt->transactionId = moTransactionId;

            //add wired info
            CellularAbstractAddNetworkToMacMsgInfo(
                node,
                &moAlertingMsg,
                CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
                0,//sccp id
                CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
                CELLULAR_ABSTRACT_RECEIVER_SINGLE,

                nwCellularAbstractScInfo->
                    scAppInfo[moItemIndex].bsNodeId);

            //send to mac
            CellularAbstractSendMsgOverNonCellularLink(
                node,
                moAlertingMsg,
                CELLULAR_PD_CC,
                CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_ALERTING);

            //update stats
            nwCellularAbstractScInfo->stats.numMOCallAlertingSent ++;

            //change nw cc state
            nwCellularAbstractScInfo->scAppInfo[moItemIndex].nwCcState =
                CELLULAR_ABSTRACT_NW_CC_STATE_CALL_DELIVERED;

            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d SC node %d CC: "
                    "MO and MT in then same SC area,"
                    "forward alerting to MO's bs %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    nwCellularAbstractScInfo->
                        scAppInfo[moItemIndex].bsNodeId);
                fflush(stdout);
            }
        }
        //else if not,  build a MO's alerting indication to gateway
        else
        {
            //MO-MT ms->bs->sc->gateway->sc2(here)->bs->ms or
            //FO-MT aggregated->gateway->sc(here)->bs->ms

            //duplicae the call alerting msg  and forward to gaeway
            CellularAbstractCallAlertingIndicationPkt   *callIndicationPkt;
            NodeAddress nextHopId;

            callIndicationPkt =
                (CellularAbstractCallAlertingIndicationPkt *)
                MEM_malloc(
                    sizeof(CellularAbstractCallAlertingIndicationPkt));

            memcpy(
                callIndicationPkt,
                callAlertingPkt,
                sizeof(CellularAbstractCallAlertingIndicationPkt));

            nextHopId = nwCellularAbstractScInfo->gatewayNodeId;

            CellularAbstractSendCallIndication(
                node,
                (void *)callIndicationPkt,
                sizeof(CellularAbstractCallAlertingIndicationPkt),
                CELLULAR_ABSTRACT_CALL_ALERTING_INDICATION,
                nextHopId);
            MEM_free(callIndicationPkt);

            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d SC node %d CC: "
                    "send call alerting indication to"
                    "gateway %d for appId%d  src %d dest %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    nextHopId,
                    callIndicationPkt->appId,
                    callIndicationPkt->appSrcNodeId,
                    callIndicationPkt->appDestNodeId);
                fflush(stdout);
            }
        }
    }
    else if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)

    {
        //MO-MT ms-bs-SC1(here)-gateway-sc2-bs-ms
        //or MO-FT ms-bs-SC(here)-gateway-aggregatd
        int moItemIndex;
        int moTransactionId;
        Message *moAlertingMsg;
        CellularAbstractCallAlertingPkt *moAlertingPkt;

        ERROR_Assert(
            CellularAbstractScLookForAppItemByAppId(
                node,
                appId,
                appSrcNodeId,
                appDestNodeId,
                CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
                &moItemIndex,
                &moTransactionId) == TRUE,
            "cannot find the appInfo for this call alerting msg");

        moAlertingMsg =
            MESSAGE_Alloc(
                node,
                MAC_LAYER, // TODO change
                MAC_PROTOCOL_CELLULAR,//TODO change
                MSG_MAC_CELLULAR_FromNetwork);//this should be change later

        MESSAGE_PacketAlloc(node,
                            moAlertingMsg,
                            sizeof(CellularAbstractCallAlertingPkt),
                            TRACE_CELLULAR);

        moAlertingPkt =
            (CellularAbstractCallAlertingPkt *)
            MESSAGE_ReturnPacket(moAlertingMsg);

        moAlertingPkt->appId = appId;
        moAlertingPkt->appSrcNodeId = appSrcNodeId;
        moAlertingPkt->appDestNodeId = appDestNodeId;

        moAlertingPkt->callSrcDestType =
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;

        moAlertingPkt->transactionId = moTransactionId;

        //send to mac
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &moAlertingMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_TCH,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractScInfo->scAppInfo[moItemIndex].bsNodeId);

        CellularAbstractSendMsgOverNonCellularLink(
            node,
            moAlertingMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_ALERTING);

        //update stats
        nwCellularAbstractScInfo->stats.numMOCallAlertingSent ++;

        //change to call deliverd
        nwCellularAbstractScInfo->scAppInfo[moItemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_CALL_DELIVERED;

        if (DEBUG_CC)
        {
            printf("at %015" TYPES_64BITFMT "d SC node %d CC: MO and MT in differnt SC"
                "area or MO-FT call, forward alerting to MO's bs %d",
                node->getNodeTime(), node->nodeId,
                nwCellularAbstractScInfo->scAppInfo[moItemIndex].bsNodeId);
            fflush(stdout);
        }
    }
}
//********************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleCallConnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Sc Handle Call Connect Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractScHandleCallConnectMsg(Node *node, Message *msg)
{
    CellularAbstractCallConnectPkt *callConnectPkt;
    CellularAbstractCallSrcDestType callSrcDestType;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    int itemIndex;
    int lac;


    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    callConnectPkt =
        (CellularAbstractCallConnectPkt *)MESSAGE_ReturnPacket(msg);

    //MT case
    appId = callConnectPkt->appId;
    appSrcNodeId = callConnectPkt->appSrcNodeId;
    appDestNodeId = callConnectPkt->appDestNodeId;
    callSrcDestType = callConnectPkt->callSrcDestType;
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        //look for item with AppId,src,dest,and callSrcDestType
        ERROR_Assert(
            CellularAbstractScLookForAppItemByAppId(
                node,
                appId,
                appSrcNodeId,
                appDestNodeId,
                callSrcDestType,
                &itemIndex,
                &transactionId) == TRUE,
            "cannot find the appInfo for this call connect msg");

        //stop T301,310,303

        //stop  T301
        if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT301 != NULL)
        {
            MESSAGE_CancelSelfMsg(
                node,
                nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT301);
            nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT301 = NULL;
        }

        //stop T303
        if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT303 != NULL)
        {
            MESSAGE_CancelSelfMsg(
                node,
                nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT303);
            nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT303 = NULL;
        }

        //stop T310
        if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT310 != NULL)
        {
            MESSAGE_CancelSelfMsg(
                node,
                nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT310);
            nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT310 = NULL;
        }

        //update stats
        nwCellularAbstractScInfo->stats.numMTCallConnectRcvd ++;

        //change cc state to call received
        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_CONNECT_REQUEST;

        //send CONNECT ACK to dest ms
        CellularAbstractScSendConnectAckMsg(
            node,
            transactionId,
            appId,
            callSrcDestType,
            appSrcNodeId,
            0,
            appDestNodeId,
            nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);

        //send connect inidcation to MO part
        //find the MO's Connect SC by look up VLR

        //if find(in the same SC, using src node id and appid
        //to locate trasaction id, forward alerting to MO's bs
        if (CellularAbstractScLookUpMsLocation(
            node, appSrcNodeId, &lac) == TRUE)
        {
            int moItemIndex;
            int moTransactionId;

            //ms-bs1-SC(here)-bs2(could be different from bs1)-ms
            ERROR_Assert(
                CellularAbstractScLookForAppItemByAppId(
                    node,
                    appId,
                    appSrcNodeId,
                    appDestNodeId,
                    CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
                    &moItemIndex,
                    &moTransactionId) == TRUE,
                "cannot find the appInfo for this call connect msg");

            Message *moConnectMsg;
            CellularAbstractCallConnectPkt *moConnectPkt;
            CellularAbstractGenericTimerInfo timerInfo;

            //build msg
            CellularAbstractLayer3BuildMessage(
                node,
                &moConnectMsg,
                MAC_LAYER,
                MAC_PROTOCOL_CELLULAR,
                MSG_MAC_CELLULAR_FromNetwork,
                callConnectPkt,
                sizeof(CellularAbstractCallConnectPkt));

            moConnectPkt =
                (CellularAbstractCallConnectPkt *)
                MESSAGE_ReturnPacket(moConnectMsg);

            moConnectPkt->callSrcDestType =
                CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;

            moConnectPkt->transactionId = moTransactionId;

            //add wired info
            CellularAbstractAddNetworkToMacMsgInfo(
                node,
                &moConnectMsg,
                CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
                0,//sccp id
                CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
                CELLULAR_ABSTRACT_RECEIVER_SINGLE,
                nwCellularAbstractScInfo->
                    scAppInfo[moItemIndex].bsNodeId);

            //send to mac
            CellularAbstractSendMsgOverNonCellularLink(
                node,
                moConnectMsg,
                CELLULAR_PD_CC,
                CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT);

            //update stats
            nwCellularAbstractScInfo->stats.numMOCallConnectSent ++;

            // start T313
            timerInfo.srcNodeId = appSrcNodeId;
            timerInfo.timerType = MSG_NETWORK_CELLULAR_T313Timer;
            timerInfo.transactionId = moTransactionId;

            nwCellularAbstractScInfo->scAppInfo[moItemIndex].timerT313 =
                CellularAbstractLayer3StartTimer(
                    node,
                    DefaultCellularAbstractCallControl_T313Time,
                    &timerInfo,
                    sizeof(CellularAbstractGenericTimerInfo));

            //change nw cc state
            nwCellularAbstractScInfo->scAppInfo[moItemIndex].nwCcState =
                CELLULAR_ABSTRACT_NW_CC_STATE_CONNECT_INDICATION;

            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d SC node %d CC: "
                    "MO and MT in then same SC area,"
                    "forward alerting to MO's bs %d",
                    node->getNodeTime(),
                    node->nodeId,
                    nwCellularAbstractScInfo->
                        scAppInfo[moItemIndex].bsNodeId);
                fflush(stdout);
            }

        }
        //else if not,  build a MO's coonect to gateway
        else//ms-bs-SC1(here)-gateway-(sc2-bs-ms or aggregated)
        {
            //duplicae the call connect msg  and forward to gaeway
            CellularAbstractCallConnectIndicationPkt *callIndicationPkt;
            NodeAddress nextHopId;

            callIndicationPkt =
                (CellularAbstractCallConnectIndicationPkt *)
                MEM_malloc(
                    sizeof(CellularAbstractCallConnectIndicationPkt));

            memcpy(
                callIndicationPkt,
                callConnectPkt,
                sizeof(CellularAbstractCallConnectIndicationPkt));

            nextHopId = nwCellularAbstractScInfo->gatewayNodeId;

            CellularAbstractSendCallIndication(
                node,
                (void *)callIndicationPkt,
                sizeof(CellularAbstractCallConnectIndicationPkt),
                CELLULAR_ABSTRACT_CALL_CONNECT_INDICATION,
                nextHopId);

            MEM_free(callIndicationPkt);
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d SC node %d CC:send call connect "
                    "indication to gateway %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    nextHopId);
                fflush(stdout);
            }
        }
    }
    else if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    //ms-bs-sc1(Here)-gateway-SC2-bs-ms or aggregated-gateway-SC(here)-bs-ms
    {
        int moItemIndex;
        int moTransactionId;
        CellularAbstractGenericTimerInfo timerInfo;
        Message *moConnectMsg;
        CellularAbstractCallConnectPkt *moConnectPkt;

        ERROR_Assert(
            CellularAbstractScLookForAppItemByAppId(
                node,
                appId,
                appSrcNodeId,
                appDestNodeId,
                CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
                &moItemIndex,
                &moTransactionId) == TRUE,
            "cannot find the appInfo for this call connnect msg");

        moConnectMsg =
            MESSAGE_Alloc(
                node,
                MAC_LAYER,
                MAC_PROTOCOL_CELLULAR,
                MSG_MAC_CELLULAR_FromNetwork);//this should be change later

        MESSAGE_PacketAlloc(node,
                            moConnectMsg,
                            sizeof(CellularAbstractCallConnectPkt),
                            TRACE_CELLULAR);

        moConnectPkt =
            (CellularAbstractCallConnectPkt *)
            MESSAGE_ReturnPacket(moConnectMsg);

        moConnectPkt->appId = appId;
        moConnectPkt->appSrcNodeId = appSrcNodeId;
        moConnectPkt->appDestNodeId = appDestNodeId;

        moConnectPkt->callSrcDestType =
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;

        moConnectPkt->transactionId = moTransactionId;

        //send to mac
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &moConnectMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0, //sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nwCellularAbstractScInfo->scAppInfo[moItemIndex].bsNodeId);

        CellularAbstractSendMsgOverNonCellularLink(
            node,
            moConnectMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT);

        //update stats
        nwCellularAbstractScInfo->stats.numMOCallConnectSent ++;

        //TODO: start T313
        timerInfo.srcNodeId = appSrcNodeId;
        timerInfo.timerType = MSG_NETWORK_CELLULAR_T313Timer;
        timerInfo.transactionId = moTransactionId;
        nwCellularAbstractScInfo->scAppInfo[moItemIndex].timerT313 =
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractCallControl_T313Time,
                &timerInfo,
                sizeof(CellularAbstractGenericTimerInfo));

        //change nw cc state
        nwCellularAbstractScInfo->scAppInfo[moItemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_CONNECT_INDICATION;
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d SC node %d CC: MO and MT in then differnt"
                "SC area or ms to aggregated node,"
                " forward alerting to MO's bs %d",
                node->getNodeTime(), node->nodeId,
                nwCellularAbstractScInfo->scAppInfo[moItemIndex].bsNodeId);
            fflush(stdout);
        }
    }
}
//*******************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleCallDisconnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Sc Handle Call Disconnect Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractScHandleCallDisconnectMsg(Node *node, Message *msg)
{
    CellularAbstractCallDisconnectPkt *callDisconnectPkt;
    CellularAbstractCallSrcDestType callSrcDestType;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallDisconnectType callDisconnectType;
    int itemIndex;
    CellularAbstractTimer308Info timerInfo;

    CellularLayer3Data* nwCellularData;
    CellularAbstractLayer3Data* nwCellularAbstractData;
    CellularAbstractLayer3ScInfo* nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    callDisconnectPkt =
        (CellularAbstractCallDisconnectPkt *)MESSAGE_ReturnPacket(msg);

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d SC node %d rcvd and handle call disconnect msg\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

    appId = callDisconnectPkt->appId;
    appSrcNodeId = callDisconnectPkt->appSrcNodeId;
    appDestNodeId = callDisconnectPkt->appDestNodeId;
    callSrcDestType = callDisconnectPkt->callSrcDestType;
    callDisconnectType = callDisconnectPkt->callDisconnectType;

    //look for item with AppId,src,dest,and callSrcDestType
    if (CellularAbstractScLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            &itemIndex,
            &transactionId) == FALSE)
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d Node %d: cannot find the appInfo for call "
                "src %d, dest %d srcdest type %d, "
                "may be due to  handover failuare\n",
                node->getNodeTime(),
                node->nodeId,
                appSrcNodeId,
                appDestNodeId,
                callSrcDestType);
            fflush(stdout);
        }
        return;
    }

    //if nw cc state in null or discoonect request ignore it
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
            CELLULAR_ABSTRACT_NW_CC_STATE_NULL
        || nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
            CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST)
    {
        return;
    }

    else if (nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
            CELLULAR_ABSTRACT_NW_CC_STATE_CALL_DELIVERED
            || nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
                CELLULAR_ABSTRACT_NW_CC_STATE_CALL_PRESENT
            || nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
                CELLULAR_ABSTRACT_NW_CC_STATE_CONNECT_REQUEST
            || nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
                CELLULAR_ABSTRACT_NW_CC_STATE_MOBILE_TERM_CALL_CONFIRMED
            || nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
                CELLULAR_ABSTRACT_NW_CC_STATE_ACTIVE)
    {
        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_DISCONNECT_REQUEST;

        // stop all call contro ltimer
        CellularAbstractScStopCallControlTimer(node, itemIndex);

        //send disconnect message to the other side of the call
        CellularAbstractScSendCallDisconnectionIndicationToRemoteUser(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            callDisconnectType,
            callDisconnectPkt->callDiscCause);

        //send call release msg to peer
        CellularAbstractScSendCallReleaseMsg(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            CELLULAR_ABSTRACT_CALL_RELEASE_BY_NETWORK);

        //start timer T308
        if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            timerInfo.srcNodeId = appSrcNodeId;
        }
        else if (callSrcDestType==CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {
            timerInfo.srcNodeId = appDestNodeId;
        }

        timerInfo.timerType = MSG_NETWORK_CELLULAR_T308Timer;
        timerInfo.transactionId = transactionId;
        timerInfo.numExpiration = 0;
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT308 =
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractCallControl_T308Time,
                &timerInfo,
                sizeof(CellularAbstractTimer308Info));

        //change the nw cc state to release request
        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST;
    }
    else if (nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
                CELLULAR_ABSTRACT_NW_CC_STATE_DISCONNECT_INDICATION)
    {
        //TODO: stop all call contro ltimer
        CellularAbstractScStopCallControlTimer(node, itemIndex);

        //send disconnect inidcation to the other side of the call
        CellularAbstractScSendCallDisconnectionIndicationToRemoteUser(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            callDisconnectType,
            callDisconnectPkt->callDiscCause);

        //send call release msg to peer
        CellularAbstractScSendCallReleaseMsg(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            CELLULAR_ABSTRACT_CALL_RELEASE_BY_NETWORK);

        //start timer T308
        if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            timerInfo.srcNodeId = appSrcNodeId;
        }
        else if (callSrcDestType ==
                CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {
            timerInfo.srcNodeId = appDestNodeId;
        }

        timerInfo.timerType = MSG_NETWORK_CELLULAR_T308Timer;
        timerInfo.transactionId = transactionId;
        timerInfo.numExpiration = 0;
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT308 =
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractCallControl_T308Time,
                &timerInfo,
                sizeof(CellularAbstractTimer308Info));

        //change the nw cc state to release request
        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST;
    }

    //update stats
    if (callDisconnectType == CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_MS)
    {
        if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            nwCellularAbstractScInfo->stats.numMTCallDisconnectByMsRcvd ++;
        }
        else if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {
            nwCellularAbstractScInfo->stats.numMOCallDisconnectByMsRcvd ++;
        }
    }
}
//********************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleCallDisconnectIndication
// LAYER      :: Layer3
// PURPOSE    :: Sc Handle Call Disconnect Indication.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractScHandleCallDisconnectIndication(Node *node,
                                                      Message *msg)
{
    CellularAbstractCallDisconnectIndicationPkt *callDisconnectIndicationPkt;
    CellularAbstractCallSrcDestType callSrcDestType;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallDisconnectType callDisconnectType;
    int itemIndex;
    CellularAbstractGenericTimerInfo timerInfo;


    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    callDisconnectIndicationPkt =
        (CellularAbstractCallDisconnectIndicationPkt *)
        MESSAGE_ReturnPacket(msg);
    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d SC node %d rcvd and handle call disconnect"
            "indication, must from network\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

    appId = callDisconnectIndicationPkt->appId;
    appSrcNodeId = callDisconnectIndicationPkt->appSrcNodeId;
    appDestNodeId = callDisconnectIndicationPkt->appDestNodeId;
    callSrcDestType = callDisconnectIndicationPkt->callSrcDestType;
    callDisconnectType = CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_NETWORK;

    //look for item with AppId,src,dest,and callSrcDestType
    if (CellularAbstractScLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            &itemIndex,
            &transactionId) == FALSE)
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d: cannot find the "
                "appInfo for call src %d, dest %d"
                "srcdest type %d, may be due to hadover failure\n",
                node->getNodeTime(),
                node->nodeId,
                appSrcNodeId,
                appDestNodeId,
                callSrcDestType);
            fflush(stdout);
        }
        return;
    }

    if (nwCellularAbstractScInfo->
        scAppInfo[itemIndex].isHandoverInProgress == TRUE)
    {
        Message *callDiscMsgCopy;
        CellularAbstractLayer3BuildMessage(
            node,
            &callDiscMsgCopy,
            NETWORK_LAYER,
            NETWORK_PROTOCOL_CELLULAR,
            MSG_NETWORK_CELLULAR_PollHandoverForCallManagement,
            callDisconnectIndicationPkt,
            sizeof(CellularAbstractCallDisconnectIndicationPkt));

        CellularAbstractAddLayer3MsgHeader(
            node,
            &callDiscMsgCopy,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_CALL_DISCONNECT_INDICATION);

        MESSAGE_Send(
            node,
            callDiscMsgCopy,
            CELLULAR_ABSTRACT_HANDOVER_END_POLLING_INTERVAL);

        if (DEBUG_HANDOVER)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d HO--handover is ongoing,"
                "disc an application src %d dest %d need to wait...\n",
                node->getNodeTime(),
                node->nodeId,
                appSrcNodeId,
                appDestNodeId);
            fflush(stdout);
        }
        return;
    }
    //if nw cc state in null or discoonect request ignore it
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
        CELLULAR_ABSTRACT_NW_CC_STATE_NULL
        || nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
            CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST)
    {
        return;

    }
    else if (nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
        CELLULAR_ABSTRACT_NW_CC_STATE_CALL_DELIVERED
        || nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
            CELLULAR_ABSTRACT_NW_CC_STATE_CALL_PRESENT
        || nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
            CELLULAR_ABSTRACT_NW_CC_STATE_CONNECT_REQUEST
        || nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
            CELLULAR_ABSTRACT_NW_CC_STATE_MOBILE_TERM_CALL_CONFIRMED
        || nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
            CELLULAR_ABSTRACT_NW_CC_STATE_ACTIVE)
    {
        //stop all call contro ltimer
        CellularAbstractScStopCallControlTimer(node, itemIndex);

        //send local ms a diconnect msg
        CellularAbstractScSendCallDisconnectMsg(
            node,
            appId,
            transactionId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_NETWORK,
            callDisconnectIndicationPkt->callDiscCause,
            nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);

        //start timer T305
        if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            timerInfo.srcNodeId = appSrcNodeId;
        }
        else if (callSrcDestType==CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {
            timerInfo.srcNodeId = appDestNodeId;
        }

        timerInfo.timerType = MSG_NETWORK_CELLULAR_T305Timer;
        timerInfo.transactionId = transactionId;

        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT305 =
            CellularAbstractLayer3StartTimer(
                node,
                DefaultCellularAbstractCallControl_T305Time,
                &timerInfo,
                sizeof(CellularAbstractGenericTimerInfo));

        //change the nw cc state to release request
        nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
            CELLULAR_ABSTRACT_NW_CC_STATE_DISCONNECT_REQUEST;
    }
    //update stats
    if (callDisconnectType == CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_NETWORK)
    {
        if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            nwCellularAbstractScInfo->stats.numMTCallDisconnectByNwSent ++;
        }
        else if (callSrcDestType==CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {
            nwCellularAbstractScInfo->stats.numMOCallDisconnectByNwSent ++;
        }
    }

}

//***************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleCallConnectAckMsg
// LAYER      :: Layer3
// PURPOSE    :: Sc Handle Call Connect Ack Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractScHandleCallConnectAckMsg(Node *node, Message *msg)
{

    CellularAbstractCallConnectAckPkt *callConnectAckPkt;
    int transactionId;
    int appId;
    CellularAbstractCallSrcDestType callSrcDestType;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    int itemIndex;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    callConnectAckPkt =
        (CellularAbstractCallConnectAckPkt *)MESSAGE_ReturnPacket(msg);
    appId = callConnectAckPkt->appId;
    transactionId = callConnectAckPkt->transactionId;
    callSrcDestType = callConnectAckPkt->callSrcDestType;
    appSrcNodeId = callConnectAckPkt->appSrcNodeId;
    appDestNodeId = callConnectAckPkt->appDestNodeId;
    ERROR_Assert(
        callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL,
        "SC can only recv MO CALL COENCT ACK");

    ERROR_Assert(
        CellularAbstractScLookForAppInfoItem(
            node,
            transactionId,
            appSrcNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this call connect ack msg");;

    //stop T313
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT313 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node,
            nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT313);

        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT313 = NULL;
    }

    //update the Cc state
    nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
        CELLULAR_ABSTRACT_NW_CC_STATE_ACTIVE;

    //update stats
    nwCellularAbstractScInfo->stats.numMOCallConnectAckRcvd ++;
    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d SC node %d NW CC: rcvd "
            "a MO CAll COONET ACK message\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleCallReleaseCompleteMsg
// LAYER      :: Layer3
// PURPOSE    :: Sc Handle Call Release Complete Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractScHandleCallReleaseCompleteMsg(Node *node, Message *msg)
{
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractCallReleaseCompleteType callReleaseCompleteType;
    CellularAbstractCallReleaseCompletePkt *callReleaseCompletePkt;
    Message *clearComandMsg;
    NodeAddress msNodeId;
    NodeAddress msNodeAddr;


    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    callReleaseCompletePkt =
        (CellularAbstractCallReleaseCompletePkt *)MESSAGE_ReturnPacket(msg);

    appId = callReleaseCompletePkt->appId;
    transactionId = callReleaseCompletePkt->transactionId;
    appSrcNodeId = callReleaseCompletePkt->appSrcNodeId;
    appDestNodeId = callReleaseCompletePkt->appDestNodeId;
    callSrcDestType = callReleaseCompletePkt->callSrcDestType;

    callReleaseCompleteType =
        callReleaseCompletePkt->callReleaseCompleteType;

    ERROR_Assert(
        CellularAbstractScLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            &itemIndex,
            &transactionId) == TRUE,
        "cannot find the appInfo for this call release complete msg");

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d CC: rcvd a call release complete"
            "and will send clear command to ms\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
    //stop all control timer
    CellularAbstractScStopCallControlTimer(node, itemIndex);

    //TODO:release MM connect

    //change the cc state to null
    nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
        CELLULAR_ABSTRACT_NW_CC_STATE_NULL;

    //initaite the channel release by sending clear command to bs
    //build the clearcommand msg
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        msNodeId = appSrcNodeId;
        msNodeAddr = appSrcNodeId;//TODO:give the right value
    }
    else
    {
        msNodeId = appDestNodeId;
        msNodeAddr = appDestNodeId;//TODO:give the right value
    }

    CellularAbstractScBuildClearCommandMsg(
        node,
        &clearComandMsg,
        msNodeId,
        msNodeAddr,
        transactionId,
        CELLULAR_ABSTRACT_NORMAL_EVENT);

    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &clearComandMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//should be sccp id or interface
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,//wired interface
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        clearComandMsg,
        CELLULAR_PD_RR,
        CELLULAR_ABSTRACT_CLEAR_COMMAND);

    //update stats
    nwCellularAbstractScInfo->stats.numClearCommandSent ++;

    //set the appInfo back to unused and
    CellularAbstractScResetAppInfo(node, itemIndex);
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR: send clear command and "
            "reset the appInfo item to BS\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//*******************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleCallReleaseMsg
// LAYER      :: Layer3
// PURPOSE    :: Sc Handle Call Release Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractScHandleCallReleaseMsg(Node *node, Message *msg)
{
    CellularAbstractCallReleasePkt *callReleasePkt;
    Message *clearCommandMsg;
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractCallReleaseType callReleaseType;

    NodeAddress msNodeId;
    NodeAddress msNodeAddr;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    callReleasePkt =
        (CellularAbstractCallReleasePkt *)MESSAGE_ReturnPacket(msg);

    appId = callReleasePkt->appId;
    appSrcNodeId = callReleasePkt->appSrcNodeId;
    appDestNodeId = callReleasePkt->appDestNodeId;
    callSrcDestType = callReleasePkt->callSrcDestType;
    callReleaseType = callReleasePkt->callReleaseType;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d rcvd call release "
               "src %d dest %d calldesttype %d,"
               " appId = %d\n",
               node->getNodeTime(),
               node->nodeId,
               appSrcNodeId,
               appDestNodeId,
               callSrcDestType,
               appId);
        fflush(stdout);
    }

    ERROR_Assert(
        CellularAbstractScLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType,
            &itemIndex,
            &transactionId) == TRUE,
        "cannot find the appInfo for this call release msg");

    //update stat
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        nwCellularAbstractScInfo->stats.numMOCallReleaseByMsRcvd ++;
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC:recv a MO call release by MS \n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }
    else if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        nwCellularAbstractScInfo->stats.numMTCallReleaseByMsRcvd ++;
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d CC:recv a MT call release by MS \n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }

    //if nw cc state in null or discoonect request ignore it
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
        CELLULAR_ABSTRACT_NW_CC_STATE_NULL
        || nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState ==
        CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST)
    {
        return;
    }
    //stop al lcall control timer
    CellularAbstractScStopCallControlTimer(node, itemIndex);

    //send call releae complete
    CellularAbstractScSendCallReleaseCompleteMsg(
        node,
        appId,
        appSrcNodeId,
        appDestNodeId,
        callSrcDestType,
        CELLULAR_ABSTRACT_CALL_RELEASE_COMPLETE_BY_NETWORK);

    //TODO:release MM conection

    nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
        CELLULAR_ABSTRACT_NW_CC_STATE_NULL;

    //initiate release the RR channel
    //build the clearcommand msg
    if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
    {
        msNodeId = appSrcNodeId;
        msNodeAddr = appSrcNodeId;//TODO:give the right value
    }
    else
    {
        msNodeId = appDestNodeId;
        msNodeAddr = appDestNodeId;//TODO:give the right value
    }
    CellularAbstractScBuildClearCommandMsg(
        node,
        &clearCommandMsg,
        msNodeId,
        msNodeAddr,
        transactionId,
        CELLULAR_ABSTRACT_NORMAL_EVENT);

    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &clearCommandMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//should be sccp id or interface
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,//wired interface
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        clearCommandMsg,
        CELLULAR_PD_RR,
        CELLULAR_ABSTRACT_CLEAR_COMMAND);

    //update stats
    nwCellularAbstractScInfo->stats.numClearCommandSent ++;

    //TODO: set the appInfo back to unused and
    CellularAbstractScResetAppInfo(node, itemIndex);
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d RR: send clear command"
            "and reset the appInfo item to BS\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandlePageResponseMsg
// LAYER      :: Layer3
// PURPOSE    :: Sc Handle Page Response Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractScHandlePageResponseMsg(Node *node, Message *msg)
{
    CellularAbstractPageResponsePkt *pageRespPkt;
    int itemIndex;
    int transactionId;
    int appId;
    CellularAbstractApplicationType appType;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;
    int numChannelRequired;
    double bandwidthRequired;
    clocktype appDuration;
    BOOL found;
    int i;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d SC node %d CC: RCVD a page response\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //update stats
    nwCellularAbstractScInfo->stats.numPageResponseRcvd ++;

    pageRespPkt =
        (CellularAbstractPageResponsePkt *)MESSAGE_ReturnPacket(msg);

    //this is transactionId from destination ms
    transactionId = pageRespPkt->transactionId;
    appId = pageRespPkt->appId;
    appType = pageRespPkt->appType;

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d handle pageresponse "
            "appType=%d src %d dest %d calldest type %d\n",
            node->getNodeTime(),
            node->nodeId,
            appType,
            pageRespPkt->appSrcNodeId,
            pageRespPkt->appDestNodeId,
            pageRespPkt->callSrcDestType);
        fflush(stdout);
    }

    appSrcNodeId = pageRespPkt->appSrcNodeId;
    appDestNodeId = pageRespPkt->appDestNodeId;
    numChannelRequired = pageRespPkt->numChannelRequired;
    bandwidthRequired = pageRespPkt->bandwidthRequired;
    appDuration = pageRespPkt->appDuration;
    callSrcDestType = pageRespPkt->callSrcDestType;

    //update the paging info associate with the app
    found = FALSE;

    for (i = 0;i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_SC; i ++)
    {
        if (nwCellularAbstractScInfo->scpagingInfo[i].inUse == TRUE
            && nwCellularAbstractScInfo->scpagingInfo[i].appId == appId
            && nwCellularAbstractScInfo->scpagingInfo[i].appSrcNodeId ==
                appSrcNodeId
            && nwCellularAbstractScInfo->scpagingInfo[i].appDestNodeId ==
                appDestNodeId)
        {
            found = TRUE;
            break;
        }
    }

    ERROR_Assert(found == TRUE, "cannot find the app in the paging list");
    nwCellularAbstractScInfo->scpagingInfo[i].msResponsed = TRUE;
    nwCellularAbstractScInfo->scpagingInfo[i].numBsResponsed ++;

    if (nwCellularAbstractScInfo->scpagingInfo[i].numBsResponsed ==
        nwCellularAbstractScInfo->scpagingInfo[i].numBsPaged)
    {
        //if the last res is positive reset the paging info item to unused
        nwCellularAbstractScInfo->scpagingInfo[i].inUse = FALSE;
        if (nwCellularAbstractScInfo->scpagingInfo[i].pagingTimer != NULL)
        {
            MESSAGE_CancelSelfMsg(
                node,
                nwCellularAbstractScInfo->scpagingInfo[i].pagingTimer);
            nwCellularAbstractScInfo->scpagingInfo[i].pagingTimer = NULL;
        }
    }

    //create a appInfo for this dest node
    CellularAbstractScCreateAppInfoItem(
        node,
        transactionId,
        appId,
        appType,
        appSrcNodeId,
        appDestNodeId,
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
        numChannelRequired,
        bandwidthRequired,
        &itemIndex);

    nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId =
        pageRespPkt->destBsNodeId;

    if (appType == CELLULAR_ABSTRACT_VOICE_PHONE)
    {
        //since rcvd the setup, state go to inita and
        //prepare the call proceeding msg to MS
        //send a SETUP to the dest MS
        CellularAbstractScSendSetupMsg(
            node,
            transactionId,
            appId,
            appType,
            appSrcNodeId,
            appDestNodeId,
            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
            numChannelRequired,
            bandwidthRequired,
            nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);
    }
    else if (appType == CELLULAR_ABSTRACT_VIDEO_PHONE
        ||appType == CELLULAR_ABSTRACT_TEXT_MAIL
        ||appType == CELLULAR_ABSTRACT_PICTURE_MAIL
        ||appType == CELLULAR_ABSTRACT_ANIMATION_MAIL
        ||appType == CELLULAR_ABSTRACT_WEB)
    {
        CellularAbstractSCSendRequestPDPContextActivationMsg(
            node,
            transactionId,
            appId,
            appType,
            appSrcNodeId,
            appDestNodeId,
            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
            numChannelRequired,
            bandwidthRequired,
            appDuration,
            nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId);
        //TODO:session mangement state and timer T3380
    }

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d SC node %d CC: finish handle the page response\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleCallConfirmMsg
// LAYER      :: Layer3
// PURPOSE    :: Sc Handle Call Confirm Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractScHandleCallConfirmMsg(Node *node, Message *msg)
{

    CellularAbstractCallConfirmPkt *callConfirmPkt;
    CellularAbstractGenericTimerInfo timerInfo;
    int itemIndex;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    callConfirmPkt =
        (CellularAbstractCallConfirmPkt *)MESSAGE_ReturnPacket(msg);

    ERROR_Assert(
        callConfirmPkt->callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
        "ERROR:only MT call be here");

    ERROR_Assert(
        CellularAbstractScLookForAppInfoItem(
            node,
            callConfirmPkt->transactionId,
            callConfirmPkt->appDestNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo for this call confirm msg");

    //cancel T303 if running
    if (nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT303 != NULL)
    {
        MESSAGE_CancelSelfMsg(
            node, nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT303);
        nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT303 = NULL;
    }

    //start T310
    timerInfo.srcNodeId = callConfirmPkt->appDestNodeId;
    timerInfo.timerType = MSG_NETWORK_CELLULAR_T310Timer;
    timerInfo.transactionId = callConfirmPkt->transactionId;
    nwCellularAbstractScInfo->scAppInfo[itemIndex].timerT310 =
        CellularAbstractLayer3StartTimer(
            node,
            DefaultCellularAbstractCallControl_T310Time,
            &timerInfo,
            sizeof(CellularAbstractGenericTimerInfo));

    //update stat
    nwCellularAbstractScInfo->stats.numMTCallConfirmRcvd ++;
    //change nw cc state
    nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
        CELLULAR_ABSTRACT_NW_CC_STATE_MOBILE_TERM_CALL_CONFIRMED;
}
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleHandoverRequiredMsg
// LAYER      :: Layer3
// PURPOSE    :: Sc Handle Handover Required Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractScHandleHandoverRequiredMsg(Node *node, Message *msg)
{
    int i;
    int itemIndex;

    CellularAbstractHandoverRequiredPkt *hoRequiredPkt;
    Message *hoRequestMsg;
    NodeAddress recvId;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    //update stats
    nwCellularAbstractScInfo->stats.numHandoverRequiredRcvd ++;

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HO:rcvd and ready to "
            "handle HANDOVER REQURIED msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    hoRequiredPkt =
        (CellularAbstractHandoverRequiredPkt *)MESSAGE_ReturnPacket(msg);

    if (hoRequiredPkt->currentBsNodeId == hoRequiredPkt->targetBsNodeId
        && hoRequiredPkt->currentSectorId != hoRequiredPkt->targetSectorId)
    {
        hoRequiredPkt->handoverType =
            CELLULAR_ABSTRACT_HANDOVER_TYPE_INTRA_CELL;

        //update stats
        nwCellularAbstractScInfo->stats.numIntraCellHandoverRequiredRcvd ++;
    }
    else
    {
        ERROR_Assert(
            hoRequiredPkt->currentBsNodeId != hoRequiredPkt->targetBsNodeId,
            "handover should be in different BS");

        //look for the target BS to see if it is under control by this SC
        int bsIndex;
        BOOL found;
        found = FALSE;

        for (bsIndex = 0;
            bsIndex < nwCellularAbstractScInfo->numScControlBs; bsIndex ++)
        {
            if (nwCellularAbstractScInfo->scControlBsInfo[bsIndex].bsNodeId ==
                hoRequiredPkt->targetBsNodeId)
            {
                found = TRUE;
                break;
            }

        }
        if (found == TRUE)
        {
            hoRequiredPkt->handoverType =
                CELLULAR_ABSTRACT_HANDOVER_TYPE_INTER_CELL_INTRA_SC;

            //update stats
            nwCellularAbstractScInfo->
                stats.numInterCellIntraScHandoverRequiredRcvd ++;
        }
        else
        {
            hoRequiredPkt->handoverType =
                CELLULAR_ABSTRACT_HANDOVER_TYPE_INTER_SC;

            //update stats
          nwCellularAbstractScInfo->stats.numInterScHandoverRequiredRcvd ++;
        }
    }

    //updatet the appInfo
    for (i = 0;i < hoRequiredPkt->numApplication; i ++)
    {
        ERROR_Assert(
            CellularAbstractScLookForAppInfoItem(
                node,
                hoRequiredPkt->handoverAppInfo[i].transactionId,
                hoRequiredPkt->msNodeId,
                &itemIndex) == TRUE,
            "cannot find the appInfo for this ho required msg");

        nwCellularAbstractScInfo->
            scAppInfo[itemIndex].isHandoverInProgress = TRUE;
    }

    //build msg
    CellularAbstractLayer3BuildMessage(
        node,
        &hoRequestMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        hoRequiredPkt,
        sizeof(CellularAbstractHandoverRequiredPkt));

    if (hoRequiredPkt->handoverType ==
        CELLULAR_ABSTRACT_HANDOVER_TYPE_INTRA_CELL
        || hoRequiredPkt->handoverType ==
        CELLULAR_ABSTRACT_HANDOVER_TYPE_INTER_CELL_INTRA_SC)
    {
        recvId = hoRequiredPkt->targetBsNodeId;
        if (DEBUG_HANDOVER)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d HANDOVER:it's a intra-CELL or"
                "intrasc-intercell HANDOVER REQUIRED\n",
                node->getNodeTime(),
                node->nodeId);
            fflush(stdout);
        }
    }
    else
    {
        recvId = nwCellularAbstractScInfo->gatewayNodeId;
        if (DEBUG_HANDOVER)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d HANDOVER:"
                "it's a inter SC HANDOVER REQUIRED\n",
                node->getNodeTime(),
                node->nodeId);
            fflush(stdout);
        }
    }
    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &hoRequestMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        recvId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        hoRequestMsg,
        CELLULAR_PD_RR,
        CELLULAR_ABSTRACT_HANDOVER_REQUEST);

    //update stats
    nwCellularAbstractScInfo->stats.numHandoverRequestSent ++;

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HANDOVER: send HANDOVER REQUEST"
            "msg to BS or gateway %d\n",
            node->getNodeTime(),
            node->nodeId,
            recvId);
        fflush(stdout);
    }
}

//************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleHandoverRequestAckMsg
// LAYER      :: Layer3
// PURPOSE    :: Sc Handle Handover Request Ack Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractScHandleHandoverRequestAckMsg(Node *node, Message *msg)
{
    CellularAbstractHandoverRequestAckPkt *hoRequestAckPkt;
    Message *hoCommandMsg;
    NodeAddress recvId;
    int i;
    int itemIndex;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData
        =(CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HO:rcvd and ready to handle"
            "HANDOVER REQUEST  ACK msg\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }

    //update stats
    nwCellularAbstractScInfo->stats.numHandoverRequestAckRcvd ++;

    hoRequestAckPkt =
        (CellularAbstractHandoverRequestAckPkt *)MESSAGE_ReturnPacket(msg);


    if (hoRequestAckPkt->handoverType ==
        CELLULAR_ABSTRACT_HANDOVER_TYPE_INTRA_CELL
        || hoRequestAckPkt->handoverType ==
        CELLULAR_ABSTRACT_HANDOVER_TYPE_INTER_CELL_INTRA_SC)
    {
        recvId = hoRequestAckPkt->currentBsNodeId;
        if (DEBUG_HANDOVER)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d HANDOVER:it's a intra-CELL or"
                "intrasc-intercell HANDOVER request ACK\n",
                node->getNodeTime(),
                node->nodeId);
            fflush(stdout);
        }
    }
    else
    {
        //look for the current BS to see if it is under control by this SC
        int bsIndex;
        BOOL found;
        found=FALSE;
        for (bsIndex = 0;
            bsIndex < nwCellularAbstractScInfo->numScControlBs; bsIndex ++)
        {
            if (nwCellularAbstractScInfo->scControlBsInfo[bsIndex].bsNodeId ==
                hoRequestAckPkt->currentBsNodeId)
            {
                found = TRUE;
                break;
            }
        }
        if (found == TRUE)
        {
            recvId=hoRequestAckPkt->currentBsNodeId;
        }
        else
        {
            //TODO
            //forward ACK to gateway
            Message *hoReqAckMsg;
            recvId = nwCellularAbstractScInfo->gatewayNodeId;
            //build msg
            CellularAbstractLayer3BuildMessage(
                node,
                &hoReqAckMsg,
                MAC_LAYER,
                MAC_PROTOCOL_CELLULAR,
                MSG_MAC_CELLULAR_FromNetwork,
                hoRequestAckPkt,
                sizeof(CellularAbstractHandoverRequestAckPkt));

            //add wired info
            CellularAbstractAddNetworkToMacMsgInfo(
                node,
                &hoReqAckMsg,
                CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
                0,//sccp id
                CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
                CELLULAR_ABSTRACT_RECEIVER_SINGLE,
                recvId);

            CellularAbstractSendMsgOverNonCellularLink(
                node,
                hoReqAckMsg,
                CELLULAR_PD_RR,
                CELLULAR_ABSTRACT_HANDOVER_REQUEST_ACK);

            if (DEBUG_HANDOVER)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d HANDOVER: "
                    "it's a inter SC HANDOVER request ack\n",
                    node->getNodeTime(),
                    node->nodeId);
                fflush(stdout);
            }
            return;
        }
    }

    //build msg
    CellularAbstractLayer3BuildMessage(
        node,
        &hoCommandMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        hoRequestAckPkt,
        sizeof(CellularAbstractHandoverRequestAckPkt));

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &hoCommandMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        recvId);


    CellularAbstractSendMsgOverNonCellularLink(
        node,
        hoCommandMsg,
        CELLULAR_PD_RR,
        CELLULAR_ABSTRACT_HANDOVER_COMMAND);

    //update stats
    nwCellularAbstractScInfo->stats.numHandoverCommandSent ++;

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HANDOVER:send "
            "HANDOVER COMMAND msg to BS or gateway %d\n",
            node->getNodeTime(),
            node->nodeId, recvId);
        fflush(stdout);
    }

    //handle the droped call due to handover
    for (i = 0; i < hoRequestAckPkt->numApplication; i ++)
    {

        ERROR_Assert(
            CellularAbstractScLookForAppInfoItem(
                node,
                hoRequestAckPkt->handoverAppInfo[i].transactionId,
                hoRequestAckPkt->msNodeId,
                &itemIndex) == TRUE,
            "cannot find the appInfo for this HO complete msg");

        if (hoRequestAckPkt->handoverAppInfo[i].isHandoverAllowed == FALSE)
        {
            if (hoRequestAckPkt->handoverAppInfo[i].appType ==
                CELLULAR_ABSTRACT_VOICE_PHONE)
            {
               //notify the other ned of this drop
               CellularAbstractScSendCallDisconnectionIndicationToRemoteUser(
                    node,
                    hoRequestAckPkt->handoverAppInfo[i].appId,
                    hoRequestAckPkt->handoverAppInfo[i].appSrcNodeId,
                    hoRequestAckPkt->handoverAppInfo[i].appDestNodeId,
                    hoRequestAckPkt->handoverAppInfo[i].callSrcDestType,
                    CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_NETWORK,
                    CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_HANDOVER);
                if (DEBUG_HANDOVER)
                {
                    printf(
                        "at %015" TYPES_64BITFMT "d node %d HANDOVER:some calls dropped "
                        "call disconnect inidcation to the other end of the "
                        "call src %d dest %d callsrcdesttype %d\n",
                        node->getNodeTime(),
                        node->nodeId,
                        hoRequestAckPkt->handoverAppInfo[i].appSrcNodeId,
                        hoRequestAckPkt->handoverAppInfo[i].appDestNodeId,
                        hoRequestAckPkt->handoverAppInfo[i].callSrcDestType);
                    fflush(stdout);
                }
            }
            else if (hoRequestAckPkt->handoverAppInfo[i].callSrcDestType ==
                        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
            {
                //for MS originating data calls notify the other end
                //but for the terminating call here do nothing, when
                //HO complete msg is rcvd, SC will so the cleaning work
                int lac;
                int mtItemIndex;
                int mtTransactionId;
                if (CellularAbstractScLookUpMsLocation(
                    node,
                    hoRequestAckPkt->handoverAppInfo[i].appDestNodeId,
                    &lac) == TRUE) //src dest are in the same SC
                {
                    if (CellularAbstractScLookForAppItemByAppId(
                            node,
                            hoRequestAckPkt->handoverAppInfo[i].appId,
                            hoRequestAckPkt->handoverAppInfo[i].appSrcNodeId,
                            hoRequestAckPkt->handoverAppInfo[i].appDestNodeId,
                            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
                            &mtItemIndex,
                            &mtTransactionId) == TRUE)
                    {
                        if (nwCellularAbstractScInfo->
                                    scAppInfo[mtItemIndex].isHandoverInProgress
                                    == TRUE)
                            {
                                CellularAbstractDeactivationTimerInfo timerInfo;
                                timerInfo.srcNodeId =
                                    nwCellularAbstractScInfo->
                                        scAppInfo[mtItemIndex].destMsNodeId;

                                timerInfo.transactionId = mtTransactionId;

                                timerInfo.callDiscCause =
                                    CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_HANDOVER;

                                timerInfo.timerType =
                                    MSG_NETWORK_CELLULAR_PDP_DEACTIVATION_Timer;
                                CellularAbstractLayer3StartTimer(
                                    node,
                                    CELLULAR_ABSTRACT_HANDOVER_END_POLLING_INTERVAL,
                                    &timerInfo,
                                    sizeof(CellularAbstractDeactivationTimerInfo));
                                if (DEBUG_HANDOVER)
                                {
                                    printf(
                                        "at %015" TYPES_64BITFMT "d node %d hanodve call dropped,"
                                        "the dest end is handover so send deactive "
                                        "tiemr msg for call src %d dest %d\n",
                                        node->getNodeTime(),
                                        node->nodeId,
                                        hoRequestAckPkt->
                                        handoverAppInfo[i].appSrcNodeId,
                                        hoRequestAckPkt->
                                        handoverAppInfo[i].appDestNodeId);
                                    fflush(stdout);

                                }

                            }
                        else if (nwCellularAbstractScInfo->
                                        scAppInfo[mtItemIndex].nwCcState !=
                              CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST&&
                                   nwCellularAbstractScInfo->
                                        scAppInfo[mtItemIndex].nwCcState !=
                                        CELLULAR_ABSTRACT_NW_CC_STATE_NULL)
                        {
                            CellularAbstractScSendDeactivatePDPRequestMsg(
                                node,

                                nwCellularAbstractScInfo->
                                    scAppInfo[mtItemIndex].appId,

                                nwCellularAbstractScInfo->
                                    scAppInfo[mtItemIndex].srcMsNodeId,

                                nwCellularAbstractScInfo->
                                    scAppInfo[mtItemIndex].destMsNodeId,

                                nwCellularAbstractScInfo->
                                    scAppInfo[mtItemIndex].callSrcDestType,

                                nwCellularAbstractScInfo->
                                    scAppInfo[mtItemIndex].transactionId,

                                CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_HANDOVER,

                                nwCellularAbstractScInfo->
                                    scAppInfo[mtItemIndex].bsNodeId);

                            nwCellularAbstractScInfo->
                                scAppInfo[mtItemIndex].nwCcState =
                                CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST;
                            if (DEBUG_HANDOVER)
                            {
                                printf(
                                    "at %015" TYPES_64BITFMT "d node %d HANDOVER: some call droped send "
                                    "deactivate PDP to the other end of the "
                                    "call src %d dest %d callsrcdesttype %d to BS %d\n",
                                    node->getNodeTime(),
                                    node->nodeId,
                                    nwCellularAbstractScInfo->
                                    scAppInfo[mtItemIndex].srcMsNodeId,

                                    nwCellularAbstractScInfo->
                                    scAppInfo[mtItemIndex].destMsNodeId,

                                    nwCellularAbstractScInfo->
                                        scAppInfo[mtItemIndex].callSrcDestType,
                                        nwCellularAbstractScInfo->
                                    scAppInfo[mtItemIndex].bsNodeId);
                                fflush(stdout);
                            }
                        }
                    }
                }


            }
        }
    }
}

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleHandoverFailureMsg
// LAYER      :: Layer3
// PURPOSE    :: Sc Handle Handover Failure Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractScHandleHandoverFailureMsg(Node *node, Message *msg)
{
    CellularAbstractHandoverFailurePkt *hoFailurePkt;
    BOOL found;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HANDOVER:rcvd and ready to"
            "handle HANDOVER Failure msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData
        =(CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    //update stats
    nwCellularAbstractScInfo->stats.numHandoverFailureRcvd ++;

    found = FALSE;
    hoFailurePkt =
        (CellularAbstractHandoverFailurePkt *)MESSAGE_ReturnPacket(msg);

    if (hoFailurePkt->handoverType ==
        CELLULAR_ABSTRACT_HANDOVER_TYPE_INTER_SC)
    {
        int bsIndex;
        for (bsIndex = 0;
            bsIndex < nwCellularAbstractScInfo->numScControlBs; bsIndex ++)
        {
            if (nwCellularAbstractScInfo->scControlBsInfo[bsIndex].bsNodeId ==
                hoFailurePkt->currentBsNodeId)
            {
                found = TRUE;
                break;
            }
        }
        if (found == FALSE)
        {
            //forward to gateway
            Message *hoFailureMsg;
            if (DEBUG_HANDOVER)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d rcvd a handover "
                    "failure for MS %d and forward to"
                    "gateway %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    hoFailurePkt->msNodeId,
                    nwCellularAbstractScInfo->gatewayNodeId);
                fflush(stdout);
            }

            //build msg
            CellularAbstractLayer3BuildMessage(
                node,
                &hoFailureMsg,
                MAC_LAYER,
                MAC_PROTOCOL_CELLULAR,
                MSG_MAC_CELLULAR_FromNetwork,
                hoFailurePkt,
                sizeof(CellularAbstractHandoverFailurePkt));

            //add wired info
            CellularAbstractAddNetworkToMacMsgInfo(
                node,
                &hoFailureMsg,
                CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
                0,//sccp id
                CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
                CELLULAR_ABSTRACT_RECEIVER_SINGLE,
                nwCellularAbstractScInfo->gatewayNodeId);

            CellularAbstractSendMsgOverNonCellularLink(
                node,
                hoFailureMsg,
                CELLULAR_PD_RR,
                CELLULAR_ABSTRACT_HANDOVER_FAILURE);
            return;
        }
    }
    if (hoFailurePkt->handoverType ==
        CELLULAR_ABSTRACT_HANDOVER_TYPE_INTRA_CELL ||
        hoFailurePkt->handoverType ==
        CELLULAR_ABSTRACT_HANDOVER_TYPE_INTER_CELL_INTRA_SC ||
        found == TRUE)
    {
        int i;
        int itemIndex;

        //update the appInfo item 's handover status
        for (i = 0; i < hoFailurePkt->numApplication; i ++)
        {
            ERROR_Assert(
            CellularAbstractScLookForAppInfoItem(
                node,
                hoFailurePkt->handoverAppInfo[i].transactionId,
                hoFailurePkt->msNodeId,
                &itemIndex) == TRUE,
            "cannot find the appInfo for this HO failure msg");

            // updatet he app handover status
            nwCellularAbstractScInfo->
                scAppInfo[itemIndex].isHandoverInProgress = FALSE;

            //for those terminating data call start deactivation
            if (nwCellularAbstractScInfo->
                    scAppInfo[itemIndex].applicationType !=
                CELLULAR_ABSTRACT_VOICE_PHONE &&
                nwCellularAbstractScInfo->
                    scAppInfo[itemIndex].callSrcDestType ==
                CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
            {
                CellularAbstractScSendDeactivatePDPRequestMsg(
                    node,

                    nwCellularAbstractScInfo->
                        scAppInfo[itemIndex].appId,

                    nwCellularAbstractScInfo->
                        scAppInfo[itemIndex].srcMsNodeId,

                    nwCellularAbstractScInfo->
                        scAppInfo[itemIndex].destMsNodeId,

                    nwCellularAbstractScInfo->
                        scAppInfo[itemIndex].callSrcDestType,

                    nwCellularAbstractScInfo->
                        scAppInfo[itemIndex].transactionId,

                    CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_HANDOVER,

                    nwCellularAbstractScInfo->
                        scAppInfo[itemIndex].bsNodeId);

                nwCellularAbstractScInfo->scAppInfo[itemIndex].nwCcState =
                    CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST;

                if (DEBUG_HANDOVER)
                {
                    printf(
                        "at %015" TYPES_64BITFMT "d node %d ecvd a handover failure start "
                        "deactivate terminating data call src %d dest %d"
                        " the msg is to BS %d\n",
                        node->getNodeTime(),
                        node->nodeId,
                        nwCellularAbstractScInfo->
                            scAppInfo[itemIndex].srcMsNodeId,

                        nwCellularAbstractScInfo->
                            scAppInfo[itemIndex].destMsNodeId,

                        nwCellularAbstractScInfo->
                            scAppInfo[itemIndex].bsNodeId);
                    fflush(stdout);
                }

            }
            else if (nwCellularAbstractScInfo->
                    scAppInfo[itemIndex].applicationType !=
                CELLULAR_ABSTRACT_VOICE_PHONE &&
                nwCellularAbstractScInfo->
                    scAppInfo[itemIndex].callSrcDestType ==
                CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
            {
                int lac;
                int mtItemIndex;
                int mtTransactionId;
                if (CellularAbstractScLookUpMsLocation(
                        node,
                        nwCellularAbstractScInfo->
                        scAppInfo[itemIndex].destMsNodeId,
                        &lac) == TRUE)
                {
                    //in the same SC
                    if (CellularAbstractScLookForAppItemByAppId(
                            node,
                            nwCellularAbstractScInfo->
                                scAppInfo[itemIndex].appId,
                            nwCellularAbstractScInfo->
                                scAppInfo[itemIndex].srcMsNodeId,
                            nwCellularAbstractScInfo->
                                scAppInfo[itemIndex].destMsNodeId,

                            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL,
                            &mtItemIndex,
                            &mtTransactionId) == TRUE)
                    {
                        //the appInfo is there
                        if (nwCellularAbstractScInfo->
                                scAppInfo[mtItemIndex].isHandoverInProgress
                                == TRUE)
                        {
                            CellularAbstractDeactivationTimerInfo timerInfo;
                            timerInfo.srcNodeId = nwCellularAbstractScInfo->
                                      scAppInfo[mtItemIndex].destMsNodeId;
                            timerInfo.transactionId = mtTransactionId;

                            timerInfo.callDiscCause =
                                CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_HANDOVER;
                            timerInfo.timerType =
                                MSG_NETWORK_CELLULAR_PDP_DEACTIVATION_Timer;
                            CellularAbstractLayer3StartTimer(
                                node,
                                CELLULAR_ABSTRACT_HANDOVER_END_POLLING_INTERVAL,
                                &timerInfo,
                                sizeof(CellularAbstractDeactivationTimerInfo));
                            if (DEBUG_HANDOVER)
                            {
                                printf(
                                    "at %015" TYPES_64BITFMT "d node %d hanodve call dropped,"
                                    "the dest end is "
                                    "handover so send deactive tiemr msg for call "
                                    "src %d dest %d\n",
                                    node->getNodeTime(),
                                    node->nodeId,
                                    nwCellularAbstractScInfo->
                                        scAppInfo[itemIndex].srcMsNodeId,
                                    nwCellularAbstractScInfo->
                                        scAppInfo[itemIndex].destMsNodeId);
                                fflush(stdout);

                            }
                        }
                        else if (nwCellularAbstractScInfo->
                                    scAppInfo[mtItemIndex].nwCcState !=
                                CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST &&
                                nwCellularAbstractScInfo->
                                    scAppInfo[mtItemIndex].nwCcState !=
                                    CELLULAR_ABSTRACT_NW_CC_STATE_NULL)
                        {
                            CellularAbstractScSendDeactivatePDPRequestMsg(
                                    node,

                                    nwCellularAbstractScInfo->
                                        scAppInfo[mtItemIndex].appId,

                                    nwCellularAbstractScInfo->
                                        scAppInfo[mtItemIndex].srcMsNodeId,

                                    nwCellularAbstractScInfo->
                                        scAppInfo[mtItemIndex].destMsNodeId,

                                    nwCellularAbstractScInfo->
                                        scAppInfo[mtItemIndex].callSrcDestType,

                                    nwCellularAbstractScInfo->
                                        scAppInfo[mtItemIndex].transactionId,

                                    CELLULAR_ABSTRACT_CALL_DISCONNECT_DROP_HANDOVER,

                                    nwCellularAbstractScInfo->
                                        scAppInfo[mtItemIndex].bsNodeId);

                                nwCellularAbstractScInfo->
                                    scAppInfo[mtItemIndex].nwCcState =
                                    CELLULAR_ABSTRACT_NW_CC_STATE_RELEASE_REQUEST;

                            if (DEBUG_HANDOVER)
                            {
                                printf(
                                    "at %015" TYPES_64BITFMT "d node %d hanodve call faileuare, so send deactivateion "
                                    "msg for call src %d dest %d to BS %d\n ",
                                    node->getNodeTime(),
                                    node->nodeId,
                                    nwCellularAbstractScInfo->
                                        scAppInfo[mtItemIndex].srcMsNodeId,
                                    nwCellularAbstractScInfo->
                                        scAppInfo[mtItemIndex].destMsNodeId,
                                    nwCellularAbstractScInfo->
                                        scAppInfo[mtItemIndex].bsNodeId);
                                fflush(stdout);

                            }
                        }
                    }
                }
                else
                {
                    //to ither SCor aggreagatd node
                    //TODO
                }

            }

            //for voice call, the MS wil ltake care the tear doen

        }//for

        //send a handover requried reject msg to current BS
        if (DEBUG_HANDOVER)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d rcvd a handover failure and ready to send"
                "HO required reject msg to MS %d's current BS %d"
                "controled by this SC\n",
                node->getNodeTime(),
                node->nodeId,
                hoFailurePkt->msNodeId,
                hoFailurePkt->currentBsNodeId);
            fflush(stdout);
        }
        Message * hoRequiredRejectMsg;

        //buildthe msg
        CellularAbstractLayer3BuildMessage(
            node,
            &hoRequiredRejectMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            hoFailurePkt,
            sizeof(CellularAbstractHandoverFailurePkt));

        //add wired info
        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &hoRequiredRejectMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            hoFailurePkt->currentBsNodeId);

        CellularAbstractSendMsgOverNonCellularLink(
            node,
            hoRequiredRejectMsg,
            CELLULAR_PD_RR,
            CELLULAR_ABSTRACT_HANDOVER_REQUIRED_REJECT);

    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleHandoverCompleteMsg
// LAYER      :: Layer3
// PURPOSE    :: Sc Handle Handover Complete Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractScHandleHandoverCompleteMsg(Node *node, Message *msg)
{
    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d HANDOVER:rcvd and ready to"
            "handle HANDOVER COMPLETE msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    int i;
    int itemIndex;
    CellularAbstractHandoverCompletePkt *hoCompletePkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    //update stats
    nwCellularAbstractScInfo->stats.numHandoverCompleteRcvd ++;

    hoCompletePkt =
        (CellularAbstractHandoverCompletePkt *)MESSAGE_ReturnPacket(msg);

    if (hoCompletePkt->handoverType ==
        CELLULAR_ABSTRACT_HANDOVER_TYPE_INTRA_CELL)
    {
        if (DEBUG_HANDOVER)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d HANDOVER:it is a intra handover, "
                "sc needs to do nothing but reset AppInfo\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }

        //updatet the appInfo
        for (i = 0;i < hoCompletePkt->numApplication;i ++)
        {
            ERROR_Assert(
                CellularAbstractScLookForAppInfoItem(
                    node,
                    hoCompletePkt->handoverAppInfo[i].transactionId,
                    hoCompletePkt->msNodeId,
                    &itemIndex) == TRUE,
                "cannot find the appInfo for this HO complete msg");

            if (hoCompletePkt->handoverAppInfo[i].isHandoverAllowed == FALSE)
            {
                CellularAbstractScResetAppInfo(node, itemIndex);
            }
            else
            {
                nwCellularAbstractScInfo->
                    scAppInfo[itemIndex].isHandoverInProgress = FALSE;
            }
        }
        return;
    }
    else
    {
        //look for the current BS to see if it is under control by this SC
        int bsIndex;
        BOOL found;
        int oldLac = -1;
        int newLac = -1;
        found = FALSE;

        for (bsIndex = 0;
            bsIndex < nwCellularAbstractScInfo->numScControlBs; bsIndex ++)
        {
            if (nwCellularAbstractScInfo->scControlBsInfo[bsIndex].bsNodeId ==
                hoCompletePkt->currentBsNodeId)
            {
                found = TRUE;
                oldLac =
                    nwCellularAbstractScInfo->scControlBsInfo[bsIndex].lac;
                break;
            }
        }
        if (found == TRUE) //interSC interCell HO
        {
            //updatet the appInfo
            for (i = 0; i < hoCompletePkt->numApplication; i ++)
            {

                ERROR_Assert(
                    CellularAbstractScLookForAppInfoItem(
                        node,
                        hoCompletePkt->handoverAppInfo[i].transactionId,
                        hoCompletePkt->msNodeId,
                        &itemIndex) == TRUE,
                    "cannot find the appInfo for this ho complete msg");

                if (hoCompletePkt->
                    handoverAppInfo[i].isHandoverAllowed == FALSE)
                {
                    CellularAbstractScResetAppInfo(node,itemIndex);
                }
                else
                {
                    nwCellularAbstractScInfo->
                        scAppInfo[itemIndex].isHandoverInProgress = FALSE;

                    nwCellularAbstractScInfo->scAppInfo[itemIndex].bsNodeId =
                        hoCompletePkt->targetBsNodeId;
                }
            }

            if (DEBUG_HANDOVER)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d HANDOVER:"
                    "it is a interBS/IntraSc handover "
                    "or interSC handover's original SC, sc reset AppInfo\n",
                    node->getNodeTime(),
                    node->nodeId);
                fflush(stdout);
            }

            //send HO CLEAR COMMAND to Original BS
            Message *hoClearCommandMsg;

            //build msg
            CellularAbstractLayer3BuildMessage(
                node,
                &hoClearCommandMsg,
                MAC_LAYER,
                MAC_PROTOCOL_CELLULAR,
                MSG_MAC_CELLULAR_FromNetwork,
                hoCompletePkt,
                sizeof(CellularAbstractHandoverCompletePkt));

            //add wired info
            CellularAbstractAddNetworkToMacMsgInfo(
                node,
                &hoClearCommandMsg,
                CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
                0,//sccp id
                CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
                CELLULAR_ABSTRACT_RECEIVER_SINGLE,
                hoCompletePkt->currentBsNodeId);

            CellularAbstractSendMsgOverNonCellularLink(
                node,
                hoClearCommandMsg,
                CELLULAR_PD_RR,
                CELLULAR_ABSTRACT_HANDOVER_CLEAR_COMMAND);

            //update VLR if needed
            //since found is true, both Bs are in the
            //same sc BUT MAY HAV DIFFERNT LAC

            //found the new BS's lac
            for (bsIndex = 0;
                bsIndex < nwCellularAbstractScInfo->numScControlBs;
                bsIndex ++)
            {
                if (nwCellularAbstractScInfo->
                    scControlBsInfo[bsIndex].bsNodeId ==
                    hoCompletePkt->targetBsNodeId)
                {
                    newLac =
                        nwCellularAbstractScInfo->
                            scControlBsInfo[bsIndex].lac;
                    break;
                }

            }

            BOOL newMs;
            if (oldLac != newLac)
            {
                CellularAbstractScUpdateVLR(
                    node,
                    newLac,
                    hoCompletePkt->msNodeId,
                    hoCompletePkt->msNodeId,
                    &newMs);
            }
            if (DEBUG_HANDOVER)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d HANDOVER: send clear "
                    "command to riginal BS %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    hoCompletePkt->currentBsNodeId);
                fflush(stdout);
            }
        }
        else
        {
            //TODO inter SC handover
            if (DEBUG_HANDOVER)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d HANDOVER:it is a inter SC, "
                    "sc needs to do nothing but forward to gateway\n",
                    node->getNodeTime(),
                    node->nodeId);
                fflush(stdout);
            }//forward to gateway
        }
    }
}
////////////////////////////////////////////////////////////////////////
//GATEWAY part
///////////////////////////////////////////////////////////////////////
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractHLRLookForMsLocation
// LAYER      :: Layer3
// PURPOSE    :: HLR look for a MS's location.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msNodeId         : NodeAddress       : MS's node id.
// + scNodeId         : NodeAddress       : SC's node id.
// + msActiveStatus   : CellularAbstractMsActiveStatus :
//                                        MS's status, active/inactive
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
BOOL CellularAbstractHLRLookForMsLocation(
          Node *node,
          NodeAddress msNodeId,
          NodeAddress *scNodeId,
          CellularAbstractMsActiveStatus *msActiveStatus)
{
    BOOL found;
    int hlrIndex;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;


    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo =
        nwCellularAbstractData->gatewayLayer3Info;

    found = FALSE;
    for (hlrIndex = 0;
        hlrIndex < CELLULAR_ABSTRACT_MAX_MS_PER_HLR;
        hlrIndex ++)
    {
        if (nwCellularAbstractGatewayInfo->hlr[hlrIndex].inUse == TRUE
            && nwCellularAbstractGatewayInfo->hlr[hlrIndex].msNodeId ==
                msNodeId)
        {
            found = TRUE;
            *scNodeId =
                nwCellularAbstractGatewayInfo->hlr[hlrIndex].scNodeId;
            *msActiveStatus =
                nwCellularAbstractGatewayInfo->hlr[hlrIndex].msActiveStatus;
            break;
        }
    }
    return found;
}
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractHLRUpdateLocation
// LAYER      :: Layer3
// PURPOSE    :: HLR update a MS's location.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msNodeId         : NodeAddress       : MS's node id.
// + lac              : int               : Location area code
// + newScNodeId      : NodeAddress       : New SC's node id.
// + oldScNodeId      : NodeAddress *     : Pointer to old SC's node id.
// + ClocationUpdatingType : ellularAbstractLocationUpdatingType   :
//                                        locatio update type
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
BOOL CellularAbstractHLRUpdateLocation(
        Node *node,
        NodeAddress msNodeId,
        int lac,
        NodeAddress newScNodeId,
        NodeAddress *oldScNodeId,
        CellularAbstractLocationUpdatingType   locationUpdatingType)
{
    BOOL found;
    BOOL availableEntry;
    int hlrIndex;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData = (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo =
        nwCellularAbstractData->gatewayLayer3Info;

    found = FALSE;
    for (hlrIndex = 0;
        hlrIndex < CELLULAR_ABSTRACT_MAX_MS_PER_HLR;
        hlrIndex ++)
    {
        if (nwCellularAbstractGatewayInfo->hlr[hlrIndex].inUse == TRUE
            && nwCellularAbstractGatewayInfo->
                hlr[hlrIndex].msNodeId == msNodeId)
        {
            found = TRUE;
            *oldScNodeId =
                nwCellularAbstractGatewayInfo->hlr[hlrIndex].scNodeId;
            break;
        }
    }
    if (found == FALSE)//find the first unused record
    {
        availableEntry = FALSE;
        for (hlrIndex = 0;
            hlrIndex < CELLULAR_ABSTRACT_MAX_MS_PER_HLR;hlrIndex ++)
        {
            if (nwCellularAbstractGatewayInfo->hlr[hlrIndex].inUse == FALSE)
            {
                availableEntry = TRUE;
                break;
            }
        }

        if (availableEntry == FALSE)
        {
            //TODO
            //error happen
            printf(
                "CELLULAR ABSTRACT LAYER3: Increase HLR size\n");
            assert(FALSE);
            abort();
        }
    }

    nwCellularAbstractGatewayInfo->hlr[hlrIndex].inUse = TRUE;
    nwCellularAbstractGatewayInfo->hlr[hlrIndex].msNodeId = msNodeId;
    nwCellularAbstractGatewayInfo->hlr[hlrIndex].lac = lac;

    nwCellularAbstractGatewayInfo->
        hlr[hlrIndex].scNodeId = newScNodeId;

    nwCellularAbstractGatewayInfo->
        hlr[hlrIndex].lastUpdated = node->getNodeTime();
    if (locationUpdatingType ==  CELLULAR_ABSTRACT_IMSI_DETACH)
    {
        nwCellularAbstractGatewayInfo->
            hlr[hlrIndex].msActiveStatus = CELLULAR_ABSTRACT_MS_INACTIVE;
    }
    else
    {
        nwCellularAbstractGatewayInfo->
            hlr[hlrIndex].msActiveStatus = CELLULAR_ABSTRACT_MS_ACTIVE;
    }

    return found;
}
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractHLRSendCancelLocationMsg
// LAYER      :: Layer3
// PURPOSE    :: Send a cancel location msg to SC for MS's location.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msNodeId         : NodeAddress       : MS's node id.
// + lac              : int               : Location area code
// + scNodeId         : NodeAddress       : SC's node id.
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractHLRSendCancelLocationMsg(Node* node,
                                              NodeAddress msNodeId,
                                              int lac,
                                              NodeAddress scNodeId)
{
    CellularAbstractMapdCancelLocationPkt *mapdCancalLocPkt;
    Message *mapdCancelLocMsg;
    CellularLayer3Data              *nwCellularData;
    CellularAbstractLayer3Data      *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo   *nwCellularAbstractGatewayInfo;


    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo =
        nwCellularAbstractData->gatewayLayer3Info;


    //TODO:change the msg content to fit IP
    mapdCancelLocMsg =
        MESSAGE_Alloc(node,
                      MAC_LAYER,
                      MAC_PROTOCOL_CELLULAR,
                      MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        mapdCancelLocMsg,
                        sizeof(CellularAbstractMapdCancelLocationPkt),
                        TRACE_CELLULAR);

    mapdCancalLocPkt =
        (CellularAbstractMapdCancelLocationPkt *)
        MESSAGE_ReturnPacket(mapdCancelLocMsg);

    mapdCancalLocPkt->msNodeId = msNodeId;
    mapdCancalLocPkt->lac = lac;
    //TODO mapdCancalLocPkt->cancelCause


    //add info filed
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &mapdCancelLocMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET ,
        0,//sccp id,
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        scNodeId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        mapdCancelLocMsg,
        CELLULAR_PD_MM,
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_MAPD_CANCEL_LOCATION);

    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d gateway MM: send the CANCEL LOCATION "
            "for node %d to old SC %d\n",
            node->getNodeTime(),
            node->nodeId,
            msNodeId,
            scNodeId);
        fflush(stdout);
    }
}

//********************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleMapdUpdateLocationMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Mapd Update Location Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractGatewayHandleMapdUpdateLocationMsg(Node *node,
                                                        Message *msg)
{
    CellularAbstractMapdUpdateLocationPkt *mapdUpdateLocPkt;
    CellularAbstractLocationUpdatingType   locationUpdatingType;
    NodeAddress msNodeId;
    int lac;
    NodeAddress newScNodeId;
    NodeAddress oldScNodeId = 0;
    CellularLayer3Data  *nwCellularData;
    CellularAbstractLayer3Data  *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;


    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo
        = nwCellularAbstractData->gatewayLayer3Info;

    //update the stats
    nwCellularAbstractGatewayInfo->stats.numMapdUpdateLocationRcvd ++;

    //update the HLR
    mapdUpdateLocPkt =
        (CellularAbstractMapdUpdateLocationPkt *)MESSAGE_ReturnPacket(msg);

    msNodeId = mapdUpdateLocPkt->msNodeId;
    lac = mapdUpdateLocPkt->lac;
    newScNodeId = mapdUpdateLocPkt->scNodeId;
    locationUpdatingType = mapdUpdateLocPkt ->locationUpdatingType;

    if (CellularAbstractHLRUpdateLocation(
        node, msNodeId, lac, newScNodeId,
        &oldScNodeId, locationUpdatingType) == TRUE)
    {
        //send cacellocation to old sc
        if (newScNodeId != oldScNodeId )
        {
            CellularAbstractHLRSendCancelLocationMsg(
            node, msNodeId, lac, oldScNodeId);

            //update the stats
            nwCellularAbstractGatewayInfo->
                stats.numMapdCancelLocationSent ++;
        }

        if (locationUpdatingType == CELLULAR_ABSTRACT_IMSI_DETACH)
        {
            CellularAbstractHLRSendCancelLocationMsg(
            node, msNodeId, lac, newScNodeId);

            //update the stats
            nwCellularAbstractGatewayInfo->
                stats.numMapdCancelLocationSent ++;
        }


    }

    //TODO: send update location result to sc

    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d MM: updated the "
            "hlr for node %d to SC %d \n",
            node->getNodeTime(),
            node->nodeId, msNodeId, newScNodeId);
        fflush(stdout);
    }
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleCallSetupIndication
// LAYER      :: Layer3
// PURPOSE    :: Handle Call Setup Indication.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractGatewayHandleCallSetupIndication(Node *node,
                                                      Message *msg)
{
    NodeAddress msNodeId;
    NodeAddress scNodeId;
    NodeAddress nextHopId;
    CellularAbstractMsActiveStatus msActiveStatus;
    BOOL found;
    CellularAbstractCallSetupIndicationPkt *callSetupIndicationPkt;
    CellularAbstractCallSetupPkt *callSetupPkt;
    Message *callSetupMsg;
    CellularLayer3Data  *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;


    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo
        = nwCellularAbstractData->gatewayLayer3Info;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: rcvd call setup indication\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    callSetupIndicationPkt =
        (CellularAbstractCallSetupIndicationPkt *)MESSAGE_ReturnPacket(msg);

    msNodeId =
        callSetupIndicationPkt->appDestNodeId;

    //send a call setup msg to nexthop
    //TODO:change the msg content to fit IP
    callSetupMsg =
        MESSAGE_Alloc(node,
                      MAC_LAYER,
                      MAC_PROTOCOL_CELLULAR,
                      MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(node,
                        callSetupMsg,
                        sizeof(CellularAbstractCallSetupPkt),
                        TRACE_CELLULAR);

    callSetupPkt =
        (CellularAbstractCallSetupPkt *)
        MESSAGE_ReturnPacket(callSetupMsg);

    memcpy(
        callSetupPkt,
        callSetupIndicationPkt,
        sizeof(CellularAbstractCallSetupPkt));

    found = CellularAbstractHLRLookForMsLocation(
                node,
                msNodeId,
                &scNodeId,
                &msActiveStatus);

    if (found == TRUE && msActiveStatus ==
       CELLULAR_ABSTRACT_MS_ACTIVE)//send to the ms's sc
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send call setup indication"
                "to appDest ms's Sc %d\n",
                node->getNodeTime(), node->nodeId, scNodeId);
            fflush(stdout);
        }
        nextHopId = scNodeId;
        callSetupPkt->callSrcDestType =
            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL;

        //update stats
        nwCellularAbstractGatewayInfo->stats.numInterScMOMTCall ++;
    }
    else if (msNodeId == nwCellularAbstractGatewayInfo->aggregatedNodeId)
        //send to aggregated node
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send call setup"
                "indication to AppDest a aggregated node\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
        nextHopId =
            nwCellularAbstractGatewayInfo->aggregatedNodeId;

        callSetupPkt->callSrcDestType =
            CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL;

        //update stats
        nwCellularAbstractGatewayInfo->stats.numMOFTDataCall ++;
    }
    else
    {
        //buidle the rejejct msg and send to src's sc
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: the destination node"
                "%d is not attached to the PLMN\n",
                node->getNodeTime(), node->nodeId, msNodeId);
            fflush(stdout);
        }
        Message *mtCallRejectMsg;
        NodeAddress nextHop;
        CellularAbstractMTCallRejectIndication *mtCallRejectPkt;

        mtCallRejectPkt =
            (CellularAbstractMTCallRejectIndication *)
            MEM_malloc(sizeof(CellularAbstractMTCallRejectIndication));

        mtCallRejectPkt->appId = callSetupPkt->appId;
        mtCallRejectPkt->appType = callSetupPkt->appType;
        mtCallRejectPkt->appSrcNodeId = callSetupPkt->appSrcNodeId;
        mtCallRejectPkt->appDestNodeId = callSetupPkt->appDestNodeId;

        if (mtCallRejectPkt->appSrcNodeId ==
            nwCellularAbstractGatewayInfo->aggregatedNodeId)
        {
            mtCallRejectPkt->callSrcDestType =
                CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL;
            nextHop = nwCellularAbstractGatewayInfo->aggregatedNodeId;
        }
        else
        {
            mtCallRejectPkt->callSrcDestType =
                CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;
            nextHop = callSetupIndicationPkt->appSrcScNodeId;
        }

        if (found == TRUE && msActiveStatus == CELLULAR_ABSTRACT_MS_INACTIVE)
        {
            mtCallRejectPkt->rejectCause =
                CELLULAR_ABSTRACT_CALL_REJECT_CAUSE_USER_POWEROFF;
        }
        else
        {
            mtCallRejectPkt->rejectCause =
                CELLULAR_ABSTRACT_CALL_REJECT_CAUSE_UNKNOWN_USER;
        }

        CellularAbstractLayer3BuildMessage(
            node,
            &mtCallRejectMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            mtCallRejectPkt,
            sizeof(CellularAbstractMTCallRejectIndication));

        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &mtCallRejectMsg,
            CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,//wired
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nextHop);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            mtCallRejectMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_CALL_REJECT_INDICATION);

        MEM_free(mtCallRejectPkt);

        MESSAGE_Free(node, callSetupMsg);
        return;
    }

    //mapdCancalLocPkt->cancelCause

    //add info filed
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callSetupMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET ,
        0,//sccp id,
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callSetupMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_SETUP);

}
//******************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandlePDPContextIndication
// LAYER      :: Layer3
// PURPOSE    :: Handle PDP Context Indication.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//******************************************************************
static
void CellularAbstractGatewayHandlePDPContextIndication(Node *node,
                                                       Message *msg)
{
    NodeAddress msNodeId;
    NodeAddress scNodeId;
    NodeAddress nextHopId;
    CellularAbstractMsActiveStatus msActiveStatus;
    BOOL found;
    CellularAbstractPDPContextIndicationPkt *PDPcontextIndicationPkt;
    CellularAbstractPDPContextIndicationPkt *outMsgPkt;
    Message *outMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;


    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo =
        nwCellularAbstractData->gatewayLayer3Info;

    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d GATEWAY node %d SM: "
            "rcvd call PDPContextIndication \n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    PDPcontextIndicationPkt =
        (CellularAbstractPDPContextIndicationPkt *)
        MESSAGE_ReturnPacket(msg);

    //build msg
    CellularAbstractLayer3BuildMessage(
        node,
        &outMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        PDPcontextIndicationPkt,
        sizeof(CellularAbstractPDPContextIndicationPkt));

    outMsgPkt =
        (CellularAbstractPDPContextIndicationPkt *)
        MESSAGE_ReturnPacket(outMsg);

    //indication only send to destination
    msNodeId = outMsgPkt->appDestNodeId;

    found = CellularAbstractHLRLookForMsLocation(
                node,
                msNodeId,
                &scNodeId,
                &msActiveStatus);
    if (found == TRUE && msActiveStatus == CELLULAR_ABSTRACT_MS_ACTIVE)
        //send to the ms's sc,send indication first
    {
        nextHopId = scNodeId;
        outMsgPkt->callSrcDestType =
            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL;
        if (DEBUG_SM)
        {   printf(
                "GATEWAY node %d SM: send PDPContextIndication "
                "to appDest ms's Sc %d\n",
                node->nodeId,scNodeId);
            fflush(stdout);
        }
    }
    else if (msNodeId ==
        nwCellularAbstractGatewayInfo->aggregatedNodeId)
    {
        nextHopId = nwCellularAbstractGatewayInfo->aggregatedNodeId;
        outMsgPkt->callSrcDestType =
            CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL;
        if (DEBUG_SM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d SM: "
                "send call PDPContextIndication"
                "to AppDest a aggregated node\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }
    else //unkown node
    {
        //for PDP if dest MS is not attached, discard it
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: the destination node"
                "%d is not attached to the PLMN\n",
                node->getNodeTime(), node->nodeId, msNodeId);
            fflush(stdout);
        }
        MESSAGE_Free(node, outMsg);
        return;
    }

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &outMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        outMsg,
        CELLULAR_PD_SM,
        CELLULAR_ABSTRACT_SM_PDP_CONTEXT_INDICATION);
}
//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleCallAlertingIndication
// LAYER      :: Layer3
// PURPOSE    :: Handle Call Alerting Indication.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractGatewayHandleCallAlertingIndication(Node *node,
                                                         Message *msg)
{
    NodeAddress msNodeId;
    NodeAddress scNodeId;
    NodeAddress nextHopId;
    CellularAbstractMsActiveStatus msActiveStatus;
    BOOL found;

    CellularAbstractCallAlertingPkt *callAlertingIndicationPkt;
    CellularAbstractCallAlertingPkt *callAlertingPkt;
    Message *callAlertingMsg;
    CellularLayer3Data  *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;


    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo =
        nwCellularAbstractData->gatewayLayer3Info;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: "
            "rcvd call Alerting indication\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    callAlertingIndicationPkt =
        (CellularAbstractCallAlertingIndicationPkt *)
        MESSAGE_ReturnPacket(msg);

    msNodeId =
        callAlertingIndicationPkt->appSrcNodeId;
    // Alerting indication is to appSrc

    //send a call alerting msg to nexthop
    //build msg
    callAlertingMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        callAlertingMsg,
        sizeof(CellularAbstractCallAlertingPkt),
        TRACE_CELLULAR);

    callAlertingPkt =
        (CellularAbstractCallAlertingPkt *)
        MESSAGE_ReturnPacket(callAlertingMsg);

    memcpy(
        callAlertingPkt,
        callAlertingIndicationPkt,
        sizeof(CellularAbstractCallAlertingPkt));

    found = CellularAbstractHLRLookForMsLocation(
                node,
                msNodeId,
                &scNodeId,
                &msActiveStatus);

    if (found == TRUE && msActiveStatus ==
       CELLULAR_ABSTRACT_MS_ACTIVE)//send to the ms's sc
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send call Alerting"
                "indication to appSrc ms's Sc %d\n",
                node->getNodeTime(), node->nodeId, scNodeId);
            fflush(stdout);
        }
        nextHopId = scNodeId;
        callAlertingPkt->callSrcDestType =
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;
    }
    else if (msNodeId ==
             nwCellularAbstractGatewayInfo->
             aggregatedNodeId)//send to aggregated node
    {
        if (DEBUG_CC)
        {
            printf("at %015" TYPES_64BITFMT "d GATEWAY node %d CC: "
                "send call Alerting indication"
                "to AppSrc an aggregated node %d dest %d"
                "for appId %d\n",
                node->getNodeTime(), node->nodeId,
                callAlertingPkt->appSrcNodeId,
                callAlertingPkt->appDestNodeId,
                callAlertingPkt->callSrcDestType);
            fflush(stdout);
        }
        nextHopId = nwCellularAbstractGatewayInfo->aggregatedNodeId;
        callAlertingPkt->callSrcDestType =
            CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL;
    }
    else
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: the src node"
                "%d is not attached to the PLMN\n",
                node->getNodeTime(), node->nodeId, msNodeId);
            fflush(stdout);
        }
        MESSAGE_Free(node, callAlertingMsg);
        return;
    }

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callAlertingMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callAlertingMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_ALERTING);
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleCallConnectIndication
// LAYER      :: Layer3
// PURPOSE    :: Handle Call Connect Indication.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractGatewayHandleCallConnectIndication(Node *node,
                                                        Message *msg)
{
    NodeAddress msNodeId;
    NodeAddress scNodeId;
    NodeAddress nextHopId;
    CellularAbstractMsActiveStatus msActiveStatus;
    BOOL found;

    CellularAbstractCallConnectPkt *callConnectIndicationPkt;
    CellularAbstractCallConnectPkt *callConnectPkt;
    Message *callConnectMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;


    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo
        = nwCellularAbstractData->gatewayLayer3Info;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: rcvd call Connect indication\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    callConnectIndicationPkt =
        (CellularAbstractCallConnectIndicationPkt *)
        MESSAGE_ReturnPacket(msg);

    // Connect indication is to appSrc
    msNodeId = callConnectIndicationPkt->appSrcNodeId;

    //send a call Connect msg to nexthop
    //TODO:change the msg content to fit IP
    callConnectMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc (
        node,
        callConnectMsg,
        sizeof(CellularAbstractCallConnectPkt),
        TRACE_CELLULAR);

    callConnectPkt =
        (CellularAbstractCallConnectPkt *)
        MESSAGE_ReturnPacket(callConnectMsg);

    memcpy(
        callConnectPkt,
        callConnectIndicationPkt,
        sizeof(CellularAbstractCallConnectPkt));

    found = CellularAbstractHLRLookForMsLocation(
                node,
                msNodeId,
                &scNodeId,
                &msActiveStatus);

    if (found == TRUE && msActiveStatus ==
       CELLULAR_ABSTRACT_MS_ACTIVE)//send to the ms's sc
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send call Connect"
                "indication to appSrc ms's Sc %d\n",
                node->getNodeTime(),
                node->nodeId,
                scNodeId);
            fflush(stdout);
        }
        nextHopId = scNodeId;
        callConnectPkt->callSrcDestType =
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;
    }
    else if (msNodeId ==
             nwCellularAbstractGatewayInfo->aggregatedNodeId)
             //send to aggregated node
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: "
                "send call Connect indication"
                "to AppSrc a aggregated node\n",
                node->getNodeTime(),
                node->nodeId);
            fflush(stdout);
        }

        nextHopId =
            nwCellularAbstractGatewayInfo->aggregatedNodeId;

        callConnectPkt->callSrcDestType =
            CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL;
    }
    else
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: the src node"
                "%d is not attached to the PLMN\n",
                node->getNodeTime(), node->nodeId, msNodeId);
            fflush(stdout);
        }
        MESSAGE_Free(node, callConnectMsg);
        return;
    }

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callConnectMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callConnectMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT);
}
//*******************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleCallDisconnectIndication
// LAYER      :: Layer3
// PURPOSE    :: Handle Call Disconnect Indication.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractGatewayHandleCallDisconnectIndication(Node *node,
                                                           Message *msg)
{
    NodeAddress msNodeId = CELLULAR_ABSTRACT_INVALID_MS_ID;
    NodeAddress nextHopId;
    NodeAddress scNodeId;
    CellularAbstractMsActiveStatus msActiveStatus;
    BOOL found;

    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractCallDisconnectPkt *callDisconnectIndicationPkt;
    Message *outMsg;
    CellularAbstractMessageType messageType;
    CellularAbstractCallDisconnectPkt *outMsgPkt;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;


    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo =
        nwCellularAbstractData->gatewayLayer3Info;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: "
            "rcvd call DisConnect indication\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    callDisconnectIndicationPkt =
        (CellularAbstractCallDisconnectIndicationPkt *)
        MESSAGE_ReturnPacket(msg);

    callSrcDestType = callDisconnectIndicationPkt->callSrcDestType;

    // disConnect indication is to appSrc,
    //the inidcaiton is send from MT's SC
    if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
    {
        msNodeId = callDisconnectIndicationPkt->appSrcNodeId;
    }
    else if (callSrcDestType ==
        CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        //the indication is send from MT's ms
    {
        msNodeId = callDisconnectIndicationPkt->appDestNodeId;
    }

    ERROR_Assert(msNodeId != CELLULAR_ABSTRACT_INVALID_MS_ID,
                 "unknown msNodeId");
    //send a call disConnect msg to nexthop

    //build msg
    CellularAbstractLayer3BuildMessage(
        node,
        &outMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        callDisconnectIndicationPkt,
        sizeof(CellularAbstractCallDisconnectIndicationPkt));

    outMsgPkt =
        (CellularAbstractCallDisconnectPkt *) MESSAGE_ReturnPacket(outMsg);


    found = CellularAbstractHLRLookForMsLocation(
                node,
                msNodeId,
                &scNodeId,
                &msActiveStatus);

    if (found == TRUE && msActiveStatus ==
       CELLULAR_ABSTRACT_MS_ACTIVE)
       //send to the ms's sc,send indication first
    {
        nextHopId = scNodeId;
        if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {
            outMsgPkt->callSrcDestType =
                CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send call DisConnect"
                    "indication to appSrc ms's Sc %d\n",
                    node->getNodeTime(), node->nodeId, scNodeId);
                fflush(stdout);
            }
        }
        else if (callSrcDestType ==
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            outMsgPkt->callSrcDestType =
                CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL;
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send call DisConnect"
                    "indication to appDest ms's Sc %d\n",
                    node->getNodeTime(), node->nodeId, scNodeId);
                fflush(stdout);
            }
        }

        messageType = CELLULAR_ABSTRACT_CC_CALL_DISCONNECT_INDICATION;

    }
    else if (msNodeId == nwCellularAbstractGatewayInfo->aggregatedNodeId)
            //send to aggregated node ,only need diconnect message
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send call DisConnect"
                "indication to AppSrc a aggregated node\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
        nextHopId = nwCellularAbstractGatewayInfo->aggregatedNodeId;
        if (callSrcDestType == CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL)
        {
            outMsgPkt->callSrcDestType =
                CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL;
        }

        else if (callSrcDestType==CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL)
        {
            outMsgPkt->callSrcDestType =
                CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL;
        }

        messageType = CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_DISCONNECT;
    }
    else
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: the src node"
                "%d is not attached to the PLMN\n",
                node->getNodeTime(), node->nodeId, msNodeId);
            fflush(stdout);
        }
        MESSAGE_Free(node, outMsg);
        return;
    }

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &outMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        outMsg,
        CELLULAR_PD_CC,
        messageType);
}
//********************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleCallDisconnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Call Disconnect Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractGatewayHandleCallDisconnectMsg(Node *node,
                                                    Message *msg)
{
    NodeAddress msNodeId = CELLULAR_ABSTRACT_INVALID_MS_ID;
    NodeAddress nextHopId;
    NodeAddress scNodeId;
    CellularAbstractMsActiveStatus msActiveStatus;
    BOOL found;

    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractCallDisconnectPkt *callDisconnectPkt;
    Message *outMsg;
    CellularAbstractMessageType messageType;
    CellularAbstractCallDisconnectIndicationPkt *outMsgPkt;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;


    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo =
        nwCellularAbstractData->gatewayLayer3Info;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: rcvd call "
            "DisConnect msg from aggregated\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    callDisconnectPkt =
        (CellularAbstractCallDisconnectPkt *)MESSAGE_ReturnPacket(msg);

    callSrcDestType = callDisconnectPkt->callSrcDestType;

    //the inidcaiton is send from FT's MS
    if (callSrcDestType == CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL)
    {
        // disConnect indication is to appSrc
        msNodeId = callDisconnectPkt->appSrcNodeId;
    }
    //the indication is send from FO's ms
    else if (callSrcDestType ==
        CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL)
    {
        msNodeId=callDisconnectPkt->appDestNodeId;
    }

    ERROR_Assert(msNodeId != CELLULAR_ABSTRACT_INVALID_MS_ID,
                 "unknown msNodeId");
    //send a call disConnect indication msg to nexthop
    //build msg
    CellularAbstractLayer3BuildMessage(
        node,
        &outMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        callDisconnectPkt,
        sizeof(CellularAbstractCallDisconnectPkt));

    outMsgPkt =
        (CellularAbstractCallDisconnectIndicationPkt *)
        MESSAGE_ReturnPacket(outMsg);

    found = CellularAbstractHLRLookForMsLocation(
                node,
                msNodeId,
                &scNodeId,
                &msActiveStatus);
    if (found == TRUE && msActiveStatus == CELLULAR_ABSTRACT_MS_ACTIVE)
    //send to the ms's sc,send indication first
    {
        nextHopId = scNodeId;
        if (callSrcDestType == CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL)
        {
            outMsgPkt->callSrcDestType =
                CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send call DisConnect"
                    "indication to appSrc ms's Sc %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    scNodeId);
                fflush(stdout);
            }
        }
        else if (callSrcDestType ==
            CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL)
        {
            outMsgPkt->callSrcDestType =
                CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL;
            if (DEBUG_CC)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send call DisConnect"
                    "indication to appDest ms's Sc %d\n",
                    node->getNodeTime(),
                    node->nodeId,
                    scNodeId);
                fflush(stdout);
            }
        }
        messageType = CELLULAR_ABSTRACT_CC_CALL_DISCONNECT_INDICATION;

    }
    else if (msNodeId == nwCellularAbstractGatewayInfo->aggregatedNodeId)
    //send to aggregated node ,only need diconnect message
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send call DisConnect"
                "indication to AppSrc a aggregated node\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);

        }
        nextHopId = nwCellularAbstractGatewayInfo->aggregatedNodeId;

        if (callSrcDestType==CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL)
        {
            outMsgPkt->callSrcDestType =
                CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL;
        }
        else if (callSrcDestType ==
            CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL)
        {
            outMsgPkt->callSrcDestType =
                CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL;
        }
        messageType = CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_DISCONNECT;
    }
    else
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: the node"
                "%d is not attached to the PLMN\n",
                node->getNodeTime(), node->nodeId, msNodeId);
            fflush(stdout);
        }
        MESSAGE_Free(node, outMsg);
        return;
    }

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &outMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        outMsg,
        CELLULAR_PD_CC,
        messageType);
}

//********************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleCallAlertingMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Call Alerting Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//********************************************************************
static
void CellularAbstractGatewayHandleCallAlertingMsg(Node *node, Message *msg)
{
    CellularAbstractCallAlertingPkt *callAlertingPkt;
    Message *callAlertingMsg;
    NodeAddress msNodeId;
    NodeAddress scNodeId;
    NodeAddress nextHopId;
    CellularAbstractMsActiveStatus msActiveStatus;
    BOOL found;


    CellularLayer3Data  *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo =
        nwCellularAbstractData->gatewayLayer3Info;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: rcvd FT/or inter"
            "SC MT call Alerting msg \n",
            node->getNodeTime(), node->nodeId);
        //only call dest wil lsend the alerting
        fflush(stdout);

    }
    callAlertingMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        callAlertingMsg,
        sizeof(CellularAbstractCallAlertingPkt),
        TRACE_CELLULAR);

    callAlertingPkt =
        (CellularAbstractCallAlertingPkt *)
        MESSAGE_ReturnPacket(callAlertingMsg);

    memcpy(
        callAlertingPkt,
        MESSAGE_ReturnPacket(msg),
        sizeof(CellularAbstractCallAlertingPkt));

    msNodeId = callAlertingPkt->appSrcNodeId;

    found = CellularAbstractHLRLookForMsLocation(
                node,
                msNodeId,
                &scNodeId,
                &msActiveStatus);
    if (found == TRUE &&
       msActiveStatus ==
       CELLULAR_ABSTRACT_MS_ACTIVE)//send to the ms's sc
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d ATEWAY node %d CC: send call"
                "alerting to appSRC ms's Sc %d\n",
                node->getNodeTime(), node->nodeId,
                scNodeId);
            fflush(stdout);
        }

        nextHopId = scNodeId;
        callAlertingPkt->callSrcDestType =
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;
    }
    else if (msNodeId == nwCellularAbstractGatewayInfo->aggregatedNodeId)
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send call alerting"
                "to appSRC aggregated node\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }

        //send to aggregated node
        //in case if support Fix Originaitng-Fixed terminating call
        nextHopId =
            nwCellularAbstractGatewayInfo->aggregatedNodeId;

        //beware no loop exsit

        callAlertingPkt->callSrcDestType
            = CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL;
    }
    else
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: the src node"
                "%d is not attached to the PLMN\n",
                node->getNodeTime(), node->nodeId, msNodeId);
            fflush(stdout);
        }
        MESSAGE_Free(node, callAlertingMsg);

        return;
    }

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callAlertingMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callAlertingMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_ALERTING);
}

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleCallConnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Call Connect Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractGatewayHandleCallConnectMsg(Node *node, Message *msg)
{
    CellularAbstractCallConnectPkt *callConnectPkt;
    Message *callConnectMsg;
    NodeAddress msNodeId;
    NodeAddress scNodeId;
    NodeAddress nextHopId;
    CellularAbstractMsActiveStatus msActiveStatus;
    BOOL found;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo =
        nwCellularAbstractData->gatewayLayer3Info;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: rcvd FT or inter-SC"
            "MT call Connect msg \n", node->getNodeTime(), node->nodeId);
        fflush(stdout);

    }

    callConnectMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        callConnectMsg,
        sizeof(CellularAbstractCallConnectPkt),
        TRACE_CELLULAR);

    callConnectPkt =
        (CellularAbstractCallConnectPkt *)
        MESSAGE_ReturnPacket(callConnectMsg);

    memcpy(
        callConnectPkt,
        MESSAGE_ReturnPacket(msg),
        sizeof(CellularAbstractCallConnectPkt));

    msNodeId = callConnectPkt->appSrcNodeId;

    found = CellularAbstractHLRLookForMsLocation(
                node,
                msNodeId,
                &scNodeId,
                &msActiveStatus);
    if (found == TRUE && msActiveStatus ==
       CELLULAR_ABSTRACT_MS_ACTIVE)//send to the ms's sc
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send call"
                "Connect to appSRC ms's Sc %d\n",
                node->getNodeTime(), node->nodeId, scNodeId);
            fflush(stdout);
        }
        nextHopId = scNodeId;
        callConnectPkt->callSrcDestType =
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;
    }
    else if (msNodeId == nwCellularAbstractGatewayInfo->aggregatedNodeId)
    {
        //send to aggregated node
        //in case if support Fix Originaitng-Fixed terminating call
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send call Connect"
                "to appSRC aggregated node\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
        nextHopId =
            nwCellularAbstractGatewayInfo->aggregatedNodeId;

        callConnectPkt->callSrcDestType =
            CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL;
    }
    else
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: the src node"
                "%d is not attached to the PLMN\n",
                node->getNodeTime(), node->nodeId, msNodeId);
            fflush(stdout);
        }
        MESSAGE_Free(node, callConnectMsg);
        return;
    }

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callConnectMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callConnectMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT);
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleCallSetupMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Call Setup Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractGatewayHandleCallSetupMsg(Node *node, Message *msg)
{
    CellularAbstractCallSetupPkt *callSetupPkt;
    Message *callSetupMsg;
    NodeAddress msNodeId;
    NodeAddress scNodeId;
    NodeAddress nextHopId = CELLULAR_ABSTRACT_INVALID_SC_ID;
    CellularAbstractMsActiveStatus msActiveStatus;
    BOOL found;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;


    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo =
        nwCellularAbstractData->gatewayLayer3Info;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: rcvd FO or inter-SC"
            "MO call Setup msg \n",
            node->getNodeTime(), node->nodeId);

            //only call dest will send the call setup
        fflush(stdout);

    }
    callSetupMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        callSetupMsg,
        sizeof(CellularAbstractCallSetupPkt),
        TRACE_CELLULAR);

    callSetupPkt =
        (CellularAbstractCallSetupPkt *)
        MESSAGE_ReturnPacket(callSetupMsg);

    memcpy(
        callSetupPkt,
        MESSAGE_ReturnPacket(msg),
        sizeof(CellularAbstractCallSetupPkt));

    msNodeId = callSetupPkt->appDestNodeId;

    found = CellularAbstractHLRLookForMsLocation(
                node,
                msNodeId,
                &scNodeId,
                &msActiveStatus);

    //if MS is active
    if (found == TRUE &&
        msActiveStatus == CELLULAR_ABSTRACT_MS_ACTIVE)
        //send to the ms's sc
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send "
                "call Setup to appDest ms's Sc %d\n",
                node->getNodeTime(), node->nodeId, scNodeId);
            fflush(stdout);
        }

        nextHopId = scNodeId;
        callSetupPkt->callSrcDestType =
            CELLULAR_ABSTRACT_MOBILE_TERMINATING_CALL;

        //update stats
        nwCellularAbstractGatewayInfo->stats.numFOMTDataCall ++;
    }
    else if (msNodeId ==
        nwCellularAbstractGatewayInfo->aggregatedNodeId)
    {
        //send to aggregated node
        //in case if support Fix Originaitng-Fixed terminating call
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send call Connect"
                "to appDest aggregated node\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
        nextHopId =
            nwCellularAbstractGatewayInfo->aggregatedNodeId;
        callSetupPkt->callSrcDestType =
            CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL;

    }
    else
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: the destination node"
                "%d is not attached to the PLMN\n",
                node->getNodeTime(), node->nodeId,msNodeId);
            fflush(stdout);
        }

        //buidle the rejejct msg and send to src's sc
        Message *mtCallRejectMsg;
        NodeAddress nextHop = CELLULAR_ABSTRACT_INVALID_SC_ID;
        CellularAbstractMsActiveStatus srcActiveStatus;

        CellularAbstractMTCallRejectIndication *mtCallRejectPkt;

        mtCallRejectPkt =
            (CellularAbstractMTCallRejectIndication *)
            MEM_malloc(sizeof(CellularAbstractMTCallRejectIndication));

        mtCallRejectPkt->appId = callSetupPkt->appId;
        mtCallRejectPkt->appType = callSetupPkt->appType;
        mtCallRejectPkt->appSrcNodeId = callSetupPkt->appSrcNodeId;
        mtCallRejectPkt->appDestNodeId = callSetupPkt->appDestNodeId;

        if (CellularAbstractHLRLookForMsLocation(
                node,
                mtCallRejectPkt->appSrcNodeId,
                &scNodeId,
                &srcActiveStatus) == TRUE)
        {
            mtCallRejectPkt->callSrcDestType =
                CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;
            nextHop = scNodeId;
        }
        else if (mtCallRejectPkt->appSrcNodeId ==
            nwCellularAbstractGatewayInfo->aggregatedNodeId)
        {
            mtCallRejectPkt->callSrcDestType =
                CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL;
            nextHop = nwCellularAbstractGatewayInfo->aggregatedNodeId;
        }
        else
        {
            ERROR_ReportError(
                "even src is not in the HLR and not aggregated node\n");
        }
        if (found == TRUE &&
            msActiveStatus == CELLULAR_ABSTRACT_MS_INACTIVE)
        {
            mtCallRejectPkt->rejectCause =
                CELLULAR_ABSTRACT_CALL_REJECT_CAUSE_USER_POWEROFF;
        }
        else
        {
            mtCallRejectPkt->rejectCause =
                CELLULAR_ABSTRACT_CALL_REJECT_CAUSE_UNKNOWN_USER;
        }

        CellularAbstractLayer3BuildMessage(
            node,
            &mtCallRejectMsg,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork,
            mtCallRejectPkt,
            sizeof(CellularAbstractMTCallRejectIndication));

        CellularAbstractAddNetworkToMacMsgInfo(
            node,
            &mtCallRejectMsg,CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
            0,//sccp id
            CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,//wired
            CELLULAR_ABSTRACT_RECEIVER_SINGLE,
            nextHop);

        //send to mac
        CellularAbstractSendMsgOverNonCellularLink(
            node,
            mtCallRejectMsg,
            CELLULAR_PD_CC,
            CELLULAR_ABSTRACT_CC_CALL_REJECT_INDICATION);

        MEM_free(mtCallRejectPkt);
        MESSAGE_Free(node, callSetupMsg);

        return;
    }

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callSetupMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callSetupMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_SETUP);
}
//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleMTCallRejectIndication
// LAYER      :: Layer3
// PURPOSE    :: Handle MT Call Reject Indication.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractGatewayHandleMTCallRejectIndication(Node *node,
                                                         Message *msg)
{

    NodeAddress msNodeId;
    NodeAddress scNodeId;
    NodeAddress nextHopId;
    CellularAbstractMsActiveStatus msActiveStatus;
    BOOL found;

    CellularAbstractMTCallRejectIndication *inMsgPkt;
    CellularAbstractMTCallRejectIndication *outMsgPkt;
    Message *outMsg;

    CellularLayer3Data  *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;
    //second hierachy
    nwCellularAbstractData = (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo=nwCellularAbstractData->gatewayLayer3Info;

    inMsgPkt =
        (CellularAbstractMTCallRejectIndication *) MESSAGE_ReturnPacket(msg);

    //build msg
    CellularAbstractLayer3BuildMessage(
        node,
        &outMsg,
        MAC_LAYER,
        MAC_PROTOCOL_CELLULAR,
        MSG_MAC_CELLULAR_FromNetwork,
        inMsgPkt,
        sizeof(CellularAbstractMTCallRejectIndication));

    outMsgPkt =
        (CellularAbstractMTCallRejectIndication *)MESSAGE_ReturnPacket(outMsg);
    msNodeId = outMsgPkt->appSrcNodeId;

    found = CellularAbstractHLRLookForMsLocation(
                node,
                msNodeId,
                &scNodeId,
                &msActiveStatus);
    if (found == TRUE && msActiveStatus == CELLULAR_ABSTRACT_MS_ACTIVE)
    //send to the ms's sc
    {
        if (DEBUG_CAC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CAC: send MTCallRejectIndication"
                "to appSrc ms's Sc %d\n",
                node->getNodeTime(), node->nodeId,scNodeId);
            fflush(stdout);
        }
        nextHopId = scNodeId;
        outMsgPkt->callSrcDestType =
            CELLULAR_ABSTRACT_MOBILE_ORIGINATING_CALL;
    }
    else if (msNodeId ==
             nwCellularAbstractGatewayInfo->aggregatedNodeId)
    //send to aggregated node
    //in case if support Fix Originaitng-Fixed terminating call
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: send MTCallRejectIndication"
                "to appSrc a aggregated node\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
        nextHopId =
            nwCellularAbstractGatewayInfo->aggregatedNodeId;
        outMsgPkt->callSrcDestType =
            CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL;

    }
    else
    {
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d GATEWAY node %d CC: the src node"
                "%d is not attached to the PLMN\n",
                node->getNodeTime(), node->nodeId, msNodeId);
            fflush(stdout);
        }
        MESSAGE_Free(node, outMsg);

        return;
    }

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &outMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        outMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_CALL_REJECT_INDICATION);
}

/////////////////////////////////////////////////////////////////////////
//AGGREGATED NODE
/////////////////////////////////////////////////////////////////////////
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeCreateAppInfoItem
// LAYER      :: Layer3
// PURPOSE    :: Create a application information record
// PARAMETERS ::
// + node             : Node*     : Pointer to node.
// + transactionId    : int       : Thansaction Id of this applicaiton.
// + appId            : int       : Application Id
// + applicaitonType  : CellularAbstractApplicationType : app type
// + srcNodeId     : NodeAddress  : Application's src address
// + destNodeId    : NodeAddress  : Application's dest address
// + numChannelRequire: int       : Number of the channel required
// + bandwidthRequired: double    : Resource requirement for the application
// + callSrcDestType  : CellularAbstractCallSrcDestType
//                                : Type of the call srouce and destination
// + itemIndex        : int*      : Point to the index of the application
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractAggregatedNodeCreateAppInfoItem(
        Node *node,
        int transactionId,
        int appId,
        CellularAbstractApplicationType applicationType,
        NodeAddress srcNodeId,
        NodeAddress destNodeId,
        int numChannelRequired,
        double bandwidthRequired,
        CellularAbstractCallSrcDestType callSrcDestType,
        int *itemIndex)
{
    int i;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;

    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    BOOL found=FALSE;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData = (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    //look for the first un used item
    for (i = 0;
        i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_AGGREGATEDNODE; i ++)
    {
        if (nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].inUse == FALSE)
        {
            found = TRUE;
            break;
        }
    }

    //make sure there is enough room to keep these information
    ERROR_Assert(found == TRUE,
                "TOO MANY CONCURRENT TRANSACIONS!INCREASE THE calue of"
                "CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_AGGREGATEDNODE!");

    //update the item
    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[i].inUse = TRUE;

    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[i].appId = appId;

    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[i].transactionId = transactionId;

    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[i].applicationType = applicationType;

    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[i].srcMsNodeId = srcNodeId;

    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[i].destMsNodeId = destNodeId;

    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[i].numChannelRequired = numChannelRequired;

    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[i].bandwidthRequired = bandwidthRequired;

    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[i].callSrcDestType = callSrcDestType;

    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[i].isDedicatedChannelAssigned = TRUE;

    if (callSrcDestType == CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL)
    {
        nwCellularAbstractAggregatedNodeInfo->
            aggregatedNodeAppInfo[i].msNodeId = destNodeId;
    }
    else if (callSrcDestType == CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL)
    {
        nwCellularAbstractAggregatedNodeInfo->
            aggregatedNodeAppInfo[i].msNodeId = srcNodeId;
    }
    if (DEBUG_GENERAL)
    {
        printf(
            "node %d: add one appinfo with tranId"
            "%d for src %d dest %d msnode %d for appId %d\n",
            node->nodeId,
            nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].transactionId,
            nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].srcMsNodeId,
            nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].destMsNodeId,
            nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].msNodeId,
            nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].appId);
        fflush(stdout);
    }
    *itemIndex=i;
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeLookForAppInfoItem
// LAYER      :: Layer3
// PURPOSE    :: Look for a application information record
// PARAMETERS ::
// + node             : Node*     : Pointer to node.
// + transactionId    : int       : Thansaction Id of this applicaiton.
// + srcNodeId     : NodeAddress  : MS's address
// + itemIndex        : int*      : Point to the index of the application
// RETURN     :: BOOL : find or not
// **/
//**************************************************************************
static
BOOL CellularAbstractAggregatedNodeLookForAppInfoItem(
        Node *node,
        int transactionId,
        NodeAddress srcNodeId,
        int *itemIndex)
{
    int i;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;
    BOOL found = FALSE;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData = (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    //look for the first un used item
    if (DEBUG_GENERAL)
    {
        for (i = 0;
            i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_AGGREGATEDNODE; i++)
        {
            if (nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].inUse == TRUE)
            {
                printf(
                    "i %d, msnode %d tranId %d appId %d src %d dest %d\n",
                    i,
                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].msNodeId,
                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].transactionId,
                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].appId,
                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].srcMsNodeId,
                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].destMsNodeId);
               fflush(stdout);
            }
        }
        printf("input is trasnId %d, src Id %d\n",transactionId, srcNodeId);
        fflush(stdout);
    }

    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_AGGREGATEDNODE; i++)
    {
        if (nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].inUse == TRUE &&
            nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].msNodeId == srcNodeId&&
            nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].transactionId == transactionId)
        {
            found = TRUE;
            if (DEBUG_RR)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d: RR found msNode %d transactionid %d"
                    "type %d with bandwdith %f\n",
                    node->getNodeTime(),
                    node->nodeId,
                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].msNodeId,
                    transactionId,

                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].applicationType,

                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].bandwidthRequired);
                fflush(stdout);
            }
            break;
        }
    }
    *itemIndex=i;
    return found;
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeLookForAppItemByAppId
// LAYER      :: Layer3
// PURPOSE    :: Look for a application information record
// PARAMETERS ::
// + node             : Node*         : Pointer to node.
// + appId            : int           : Application Id
// + appSrcNodeId     : NodeAddress   : Application's src node id
// + appDestNodeId    : NodeAddress   : Application's Dest node id
// + itemIndex        : int*        : Point to the index of the application
// + transactionId    : int*          : Point to the Transaction id
// RETURN     :: BOOL : NULL
// **/
//*************************************************************************
static
BOOL CellularAbstractAggregatedNodeLookForAppItemByAppId(
        Node *node,
        int appId,
        NodeAddress srcNodeId,
        NodeAddress destNodeId,
        int *itemIndex,
        int *transactionId)
{

    int i;
    BOOL found;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    //look for the first unused item
    found = FALSE;

    if (DEBUG_GENERAL)
    {
        for (i = 0;
            i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_AGGREGATEDNODE; i++)
        {
            if (nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].inUse == TRUE)
            {
                printf(
                    "i %d, msnode %d tranId %d appId %d src %d dest %d\n",
                    i,
                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].msNodeId,

                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].transactionId,

                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].appId,

                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].srcMsNodeId,

                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].destMsNodeId);
                fflush(stdout);
            }
            printf(
                "input is appId %d src Id %d dest %d \n",appId,
                srcNodeId,destNodeId);
            fflush(stdout);
        }
    }
    for (i = 0;  i< CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_AGGREGATEDNODE; i++)
    {
        if (nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].inUse == TRUE &&
            nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].appId == appId&&
            nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].srcMsNodeId == srcNodeId&&
            nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].destMsNodeId == destNodeId)
        {
            found = TRUE;
            if (DEBUG_RR)
            {
                printf(
                    "at %015" TYPES_64BITFMT "d node %d MT: RR found msnode %d"
                    "type %d with bandwdith %f\n",
                    node->getNodeTime(),
                    node->nodeId,
                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].msNodeId,
                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].applicationType,
                    nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].bandwidthRequired);
                fflush(stdout);
            }
            break;
        }
    }

    *itemIndex=i;

    *transactionId = nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[i].transactionId;
    if (DEBUG_RR)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d: RR found msnode %d "
            "transactionId %d for AppID %d\n",
            node->getNodeTime(),
            node->nodeId,
            nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].msNodeId,
            nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].transactionId,
            nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[i].appId);
        fflush(stdout);
    }
    return found;
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeResetAppItem
// LAYER      :: Layer3
// PURPOSE    :: Reset a application information record
// PARAMETERS ::
// + node             : Node*    : Pointer to node.
// + itemIndex        : int*     : Point to the index of the application
// RETURN     :: void : NULL
// **/
//***************************************************************************
static
void CellularAbstractAggregatedNodeResetAppItem(Node *node, int itemIndex)
{
    CellularLayer3Data              *nwCellularData;
    CellularAbstractLayer3Data      *nwCellularAbstractData;
    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[itemIndex].inUse = FALSE;

    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[itemIndex].isDedicatedChannelAssigned = FALSE;
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeSendAppCallArriveMsg
// LAYER      :: Layer3
// PURPOSE    :: Send call arrive msg to app
// PARAMETERS ::
// + node             : Node*   : Pointer to node.
// + appId            : int     : Application id
// + transactionId    : int     : Point to the Transaction id
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractAggregatedNodeSendAppCallArriveMsg(Node *node,
                                                        int appId,
                                                        int transactionId)
{

    CellularAbstractCallArriveMessageInfo *callArriveInfo;
    Message *callArriveMsgToApp;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    int itemIndex;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    callArriveMsgToApp = MESSAGE_Alloc(
                            node,
                            APP_LAYER,
                            APP_CELLULAR_ABSTRACT,
                            MSG_APP_CELLULAR_FromNetworkCallArrive);

    MESSAGE_InfoAlloc(
        node,
        callArriveMsgToApp,
        sizeof(CellularAbstractCallArriveMessageInfo));

    callArriveInfo =
        (CellularAbstractCallArriveMessageInfo *)
            MESSAGE_ReturnInfo(callArriveMsgToApp);

    callArriveInfo->appId = appId;
    callArriveInfo->transactionId = transactionId;

    ERROR_Assert(
        CellularAbstractAggregatedNodeLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo need to send call arrive msg");

    callArriveInfo->appSrcNodeId =
        nwCellularAbstractAggregatedNodeInfo->
            aggregatedNodeAppInfo[itemIndex].srcMsNodeId;

    callArriveInfo->appDestNodeId =
        nwCellularAbstractAggregatedNodeInfo->
            aggregatedNodeAppInfo[itemIndex].destMsNodeId;

    callArriveInfo->appType =
        nwCellularAbstractAggregatedNodeInfo->
            aggregatedNodeAppInfo[itemIndex].applicationType;

    //TODO:instance other varibales
    MESSAGE_Send(node, callArriveMsgToApp, 0);

    if (DEBUG_NET2APP)
    {
        printf("at %015" TYPES_64BITFMT "d Aggregated node %d:notify application"
            "layer a call is arrived\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeSendAppCallAcceptMsg
// LAYER      :: Layer3
// PURPOSE    :: Send call accept msg to app
// PARAMETERS ::
// + node             : Node*   : Pointer to node.
// + appId            : int     : Application id
// + transactionId    : int     : Point to the Transaction id
// RETURN     :: void : NULL
// **/
//***************************************************************************
static
void CellularAbstractAggregatedNodeSendAppCallAcceptMsg(Node *node,
                                                        int appId,
                                                        int transactionId)
{

    CellularAbstractCallAcceptMessageInfo *callAcceptInfo;
    Message *callAcceptMsgToApp;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;

    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    int itemIndex;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    callAcceptMsgToApp = MESSAGE_Alloc(
                            node,
                            APP_LAYER,
                            APP_CELLULAR_ABSTRACT,
                            MSG_APP_CELLULAR_FromNetworkCallAccepted);

    MESSAGE_InfoAlloc(
        node,
        callAcceptMsgToApp,
        sizeof(CellularAbstractCallAcceptMessageInfo));

    callAcceptInfo =
        (CellularAbstractCallAcceptMessageInfo *)
        MESSAGE_ReturnInfo(callAcceptMsgToApp);

    callAcceptInfo->appId = appId;
    callAcceptInfo->transactionId = transactionId;

    ERROR_Assert(
        CellularAbstractAggregatedNodeLookForAppInfoItem(
            node,
            transactionId,
            node->nodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo need to send call accpet msg");

    callAcceptInfo->appSrcNodeId =
        nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[itemIndex].srcMsNodeId;

    callAcceptInfo->appDestNodeId =
        nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[itemIndex].destMsNodeId;

    callAcceptInfo->appType =
        nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[itemIndex].applicationType;

    //TODO:instance other aribales
    MESSAGE_Send(node, callAcceptMsgToApp, 0);

    if (DEBUG_NET2APP)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d:notify "
            "application layer a call is accept\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeSendAppCallEndByRemote
// LAYER      :: Layer3
// PURPOSE    :: Send App Call End By Remote msg
// PARAMETERS ::
// + node             : Node*   : Pointer to node.
// + appId            : int     : Application id
// + appSrcNodeId     : NodeAddress : App's src Node Id
// + appDestNodeId    : NodeAddress : App's dest Node Id
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractAggregatedNodeSendAppCallEndByRemote(
        Node *node,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId)
{
    CellularAbstractCallEndByRemoteMessageInfo *callEndByRemoteInfo;
    Message *callEndByRemoteMsgToApp;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;

    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    callEndByRemoteMsgToApp =
        MESSAGE_Alloc(
            node,
            APP_LAYER,
            APP_CELLULAR_ABSTRACT,
            MSG_APP_CELLULAR_FromNetworkCallEndByRemote);

    MESSAGE_InfoAlloc(
        node,
        callEndByRemoteMsgToApp,
        sizeof(CellularAbstractCallEndByRemoteMessageInfo));

    callEndByRemoteInfo =
        (CellularAbstractCallEndByRemoteMessageInfo *)
        MESSAGE_ReturnInfo(callEndByRemoteMsgToApp);

    callEndByRemoteInfo->appId = appId;
    callEndByRemoteInfo->appSrcNodeId = appSrcNodeId;
    callEndByRemoteInfo->appDestNodeId = appDestNodeId;

    //TODO:instance other aribales
    MESSAGE_Send(node, callEndByRemoteMsgToApp, 0);

    //update stat
    if (DEBUG_NET2APP)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d:notify application layer"
            "a call is ended by remote\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

}

//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeSendCallAlertingMsg
// LAYER      :: Layer3
// PURPOSE    :: Send App Call End By Remote msg
// PARAMETERS ::
// + node             : Node*        : Pointer to node.
// + appId            : int          : Application id
// + appSrcNodeId     : NodeAddress  : Application's src node id
// + appDestNodeId    : NodeAddress  : Application's Dest node id
// + callSrcDestType  : CellularAbstractCallSrcDestType
//                                   : Type of Call src dest
// + nextHopId        : NodeAddress  : Node id of next hop
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractAggregatedNodeSendCallAlertingMsg(
        Node *node,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        NodeAddress nextHopId)
{
    CellularAbstractCallAlertingPkt *callAlertingPkt;
    Message *callAlertingMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data  *nwCellularAbstractData;

    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;


    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    callAlertingMsg
        = MESSAGE_Alloc(node,
                        MAC_LAYER,
                        MAC_PROTOCOL_CELLULAR,
                        MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        callAlertingMsg,
        sizeof(CellularAbstractCallAlertingPkt),
        TRACE_CELLULAR);

    callAlertingPkt =
        (CellularAbstractCallAlertingPkt *)
        MESSAGE_ReturnPacket(callAlertingMsg);

    callAlertingPkt->appId = appId;
    callAlertingPkt->appSrcNodeId = appSrcNodeId;
    callAlertingPkt->appDestNodeId = appDestNodeId;
    callAlertingPkt->callSrcDestType = callSrcDestType;

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callAlertingMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callAlertingMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_ALERTING);

    //update stats
    nwCellularAbstractAggregatedNodeInfo->
                    stats.numFTCallAlertingSent ++;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d CC: send FT call alerting msg "
            "to gateway for appsrc %d and appdest %d \n",
            node->getNodeTime(), node->nodeId,
            appSrcNodeId,
            appDestNodeId);
        fflush(stdout);
    }
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeSendCallConnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Send Call Connect Msg
// PARAMETERS ::
// + node             : Node*        : Pointer to node.
// + appId            : int          : Application id
// + appSrcNodeId     : NodeAddress  : Application's src node id
// + appDestNodeId    : NodeAddress  : Application's Dest node id
// + callSrcDestType  : CellularAbstractCallSrcDestType
//                                   : Type of Call src dest
// + nextHopId        : NodeAddress  : Node id of next hop
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractAggregatedNodeSendCallConnectMsg(
        Node *node,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        NodeAddress nextHopId)
{
    CellularAbstractCallConnectPkt *callConnectPkt;
    Message *callConnectMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;

    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;
    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    callConnectMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc (
        node,
        callConnectMsg,
        sizeof(CellularAbstractCallConnectPkt),
        TRACE_CELLULAR);

    callConnectPkt =
        (CellularAbstractCallConnectPkt *)
        MESSAGE_ReturnPacket(callConnectMsg);

    callConnectPkt->appId = appId;
    callConnectPkt->appSrcNodeId = appSrcNodeId;
    callConnectPkt->appDestNodeId = appDestNodeId;
    callConnectPkt->callSrcDestType = callSrcDestType;

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callConnectMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callConnectMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT);

    //update stats
    nwCellularAbstractAggregatedNodeInfo->
        stats.numFTCallConnectSent ++;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d CC: send FT call connect msg"
            "to gateway for appSrc %d to appdest %d\n",
            node->getNodeTime(), node->nodeId,appSrcNodeId,appDestNodeId);
        fflush(stdout);
    }
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeSendSetupMsg
// LAYER      :: Layer3
// PURPOSE    :: Send Call setup Msg
// PARAMETERS ::
// + node             : Node*       : Pointer to node.
// + transactionId    : int         : Transaction Id
// + appId            : int         : Application id
// + appType          : CellularAbstractApplicationType : application type
// + appSrcNodeId     : NodeAddress : Application's src node id
// + appDestNodeId    : NodeAddress : Application's Dest node id
// + callSrcDestType  : CellularAbstractCallSrcDestType
//                                  : Type of Call src dest
// + numChannelReuired: int         : Number of channel required
// + bandwidthRequired: double      : Bandwidth required
// + nextHopId        : NodeAddress : Node id of next hop
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractAggregatedNodeSendSetupMsg(
        Node *node,
        int transactionId,
        int appId,
        CellularAbstractApplicationType appType,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId,
        CellularAbstractCallSrcDestType callSrcDestType,
        int numChannelRequired,
        double bandwidthRequired,
        NodeAddress nextHopId)
{
    int itemIndex;
    CellularAbstractCallSetupPkt *callSetupPkt;
    Message *callSetupMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;

    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    ERROR_Assert(
        CellularAbstractAggregatedNodeLookForAppInfoItem(
            node,
            transactionId,
            appSrcNodeId,
            &itemIndex) == TRUE,
        "cannot find the appInfo need to send cal lsetup msg");

    if (DEBUG_CC)
    {
            printf(
                "at %015" TYPES_64BITFMT "d node %d NW CC: build a CAll SETUP message\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
    }
    callSetupMsg =
        MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        callSetupMsg,
        sizeof(CellularAbstractCallSetupPkt),
        TRACE_CELLULAR);

    callSetupPkt =
        (CellularAbstractCallSetupPkt *)MESSAGE_ReturnPacket(callSetupMsg);

    callSetupPkt->appId = appId;
    callSetupPkt->transactionId = transactionId;
    callSetupPkt->appType = appType;
    callSetupPkt->appSrcNodeId = appSrcNodeId;

    callSetupPkt->appDestNodeId = appDestNodeId;
    callSetupPkt->callSrcDestType = callSrcDestType;
    callSetupPkt->numChannelRequired = numChannelRequired;
    callSetupPkt->bandwidthRequired = bandwidthRequired;

    //update stats
    nwCellularAbstractAggregatedNodeInfo->stats.numFOCallSetupSent ++;

    //send the setup msg to mac
    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callSetupMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callSetupMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_SETUP);

    //update status
    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[itemIndex].msCcState =
            CELLULAR_ABSTRACT_MS_CC_STATE_CALL_INITIATED;

    if (DEBUG_CC)
    {

        printf(
            "at %0115" TYPES_64BITFMT "d node %d NW CC: sending a CAll SETUP message\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeSendCallDisconnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Send Call disconnect Msg
// PARAMETERS ::
// + node             : Node*         : Pointer to node.
// + appId            : int           : Application id
// + appSrcNodeId     : NodeAddress   : Application's src node id
// + appDestNodeId    : NodeAddress   : Application's Dest node id
// RETURN     :: void : NULL
// **/
//***************************************************************************
static
void CellularAbstractAggregatedNodeSendCallDisconnectMsg(
        Node *node,
        int appId,
        NodeAddress appSrcNodeId,
        NodeAddress appDestNodeId)
{
    int itemIndex;
    int transactionId;
    NodeAddress nextHopId;
    CellularAbstractCallDisconnectPkt *callDisconnectPkt;
    CellularAbstractCallSrcDestType callSrcDestType;
    Message *callDisconnectMsg;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;

    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    ERROR_Assert(
        CellularAbstractAggregatedNodeLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            &itemIndex,
            &transactionId) == TRUE,
        "cannot find the appInfo needs to send the call disconnect msg");

    callSrcDestType =
        nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[itemIndex].callSrcDestType;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW CC: "
            "build a CAll DisConnect message for appId %d"
            "transactionId %d between src %d and %d call type %d\n",
            node->getNodeTime(),
            node->nodeId,
            appId,
            transactionId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType);
        fflush(stdout);
    }
    callDisconnectMsg
        = MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        callDisconnectMsg,
        sizeof(CellularAbstractCallDisconnectPkt),
        TRACE_CELLULAR);

    callDisconnectPkt =
        (CellularAbstractCallDisconnectPkt *)
        MESSAGE_ReturnPacket(callDisconnectMsg);

    callDisconnectPkt->appId = appId;
    callDisconnectPkt->transactionId = transactionId;
    callDisconnectPkt->appSrcNodeId = appSrcNodeId;
    callDisconnectPkt->appDestNodeId = appDestNodeId;
    callDisconnectPkt->callSrcDestType = callSrcDestType;

    // assume aggregated node always disconnect normally
    callDisconnectPkt->callDiscCause =
        CELLULAR_ABSTRACT_CALL_DISCONNECT_NORMAL;

    callDisconnectPkt->callDisconnectType =
        CELLULAR_ABSTRACT_CALL_DISCONNECT_BY_MS;

        //send the setup msg to mac
    nextHopId = nwCellularAbstractAggregatedNodeInfo->gatewayNodeId;

    //add wired info
    CellularAbstractAddNetworkToMacMsgInfo(
        node,
        &callDisconnectMsg,
        CELLULAR_ABSTRACT_CONTROL_PROTOCOL_PACKET,
        0,//sccp id
        CELLULAR_ABSTRACT_CONTROL_CHANNEL_WIRED,
        CELLULAR_ABSTRACT_RECEIVER_SINGLE,
        nextHopId);

    //send to mac
    CellularAbstractSendMsgOverNonCellularLink(
        node,
        callDisconnectMsg,
        CELLULAR_PD_CC,
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_DISCONNECT);

    //chnage cc state
    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_DISCONNECT_REQUEST;

    //TODO:start T305
    if (callSrcDestType == CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL)
    {
        //update stats
        nwCellularAbstractAggregatedNodeInfo->
            stats.numFOCallDisconnectByMsSent ++;
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d NW CC: sending a FO"
                "CALL DISCOnNET by ms message\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }
    if (callSrcDestType == CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL)
    {
        //update stats
        nwCellularAbstractAggregatedNodeInfo->
            stats.numFTCallDisconnectByMsSent ++;
        if (DEBUG_CC)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d NW CC: sending a "
                "FT CALL DISCOnNET by ms message\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeHandleStartCallMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle start call messages.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractAggregatedNodeHandleStartCallMsg(Node *node,
                                                      Message *msg)
{
    CellularAbstractCallStartMessageInfo *callStartMsg;

    //app related info
    CellularAbstractApplicationType appType;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    short appNumChannelReq;
    double appBandwidthReq;
    int itemIndex;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;

    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    if (DEBUG_NET2APP)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW-APP: process the call start msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    //too many active application?
    if (nwCellularAbstractAggregatedNodeInfo->numActiveApplicaions >=
        CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_AGGREGATEDNODE)
    {
        //TODO:send reject msg to App with
        //rejection cause too many applications
        return;
    }

    //update stas
    nwCellularAbstractAggregatedNodeInfo->stats.numCallStartRcvd ++;

    //update the transactionId;
    nwCellularAbstractAggregatedNodeInfo->numTransactions ++;
    nwCellularAbstractAggregatedNodeInfo->numActiveApplicaions ++;

/* not necessary
    //GUI_CELLULAR
    if (node->guiOption == TRUE)
    {
        if ((nwCellularAbstractAggregatedNodeInfo->
            numActiveApplicaions - 1) == 0)
        {
            GUI_SetNodeIcon(
                node->nodeId,
                "icons/AN-communicating.gif",
                node->getNodeTime());
        }
    }
    //GUI_CELLULAR
*/

    callStartMsg =
        (CellularAbstractCallStartMessageInfo *)MESSAGE_ReturnInfo(msg);
    appId = callStartMsg->appId;
    appType = callStartMsg->appType;
    appSrcNodeId = callStartMsg->appSrcNodeId;
    appDestNodeId = callStartMsg->appDestNodeId;
    appNumChannelReq = callStartMsg->appNumChannelReq;
    appBandwidthReq = callStartMsg->appBandwidthReq;

    if (DEBUG_NET2APP)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW-APP: process the call start msg for"
            "src%d dest %d withbandwidth %f\n",
            node->getNodeTime(), node->nodeId,
            appSrcNodeId,
            appDestNodeId,
            appBandwidthReq);
        fflush(stdout);
    }

    //create a item fo rthis transaction
    CellularAbstractAggregatedNodeCreateAppInfoItem(
        node,
        nwCellularAbstractAggregatedNodeInfo->numTransactions,
        appId,
        appType,
        appSrcNodeId,
        appDestNodeId,
        appNumChannelReq,
        appBandwidthReq,
        CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL,
        &itemIndex);

    //all the subsequent procedures will use this
    //transaction id and src to identify itself
    //inita the cc state
    if (appType == CELLULAR_ABSTRACT_VIDEO_PHONE
        || appType == CELLULAR_ABSTRACT_TEXT_MAIL
        || appType == CELLULAR_ABSTRACT_PICTURE_MAIL
        || appType == CELLULAR_ABSTRACT_ANIMATION_MAIL
        || appType == CELLULAR_ABSTRACT_WEB)
    {
        //send CellularAbstractAggregatedNodeSendPDPContextIndication
        CellularAbstractPDPContextIndicationPkt *callIndicationPkt;
        NodeAddress nextHopId;

        callIndicationPkt =
            (CellularAbstractPDPContextIndicationPkt *)
            MEM_malloc(sizeof(CellularAbstractPDPContextIndicationPkt));

        callIndicationPkt->appId = appId;
        callIndicationPkt->appType = appType;
        callIndicationPkt->appSrcNodeId = appSrcNodeId;
        callIndicationPkt->appDestNodeId = appDestNodeId;

        callIndicationPkt->callSrcDestType =
            CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL;

        callIndicationPkt->bandwidthRequired = appBandwidthReq;
        callIndicationPkt->numChannelRequired = appNumChannelReq;
        callIndicationPkt->appDuration = callStartMsg->appDuration;
        nextHopId = nwCellularAbstractAggregatedNodeInfo->gatewayNodeId;

        CellularAbstractSendCallIndication(
            node,
            (void *)callIndicationPkt,
            sizeof(CellularAbstractPDPContextIndicationPkt),
            CELLULAR_ABSTRACT_PDP_CONTEXT_INDICATION,
            nextHopId);

        MEM_free(callIndicationPkt);

        //update stats
        nwCellularAbstractAggregatedNodeInfo->
            stats.numDataCallActivationSent ++;

        CellularAbstractAggregatedNodeSendAppCallAcceptMsg(
            node,
            appId,
            nwCellularAbstractAggregatedNodeInfo->numTransactions);

        if (DEBUG_SM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d AGGNODE %d SM:send PDP_CONTEXT_INDICATION to"
                "gateway and send app a call accpet%d\n",
                node->getNodeTime(), node->nodeId, nextHopId);
            fflush(stdout);
        }
    }
    else if (appType == CELLULAR_ABSTRACT_VOICE_PHONE)
    {
        CellularAbstractAggregatedNodeSendSetupMsg(
            node,
            nwCellularAbstractAggregatedNodeInfo->numTransactions,
            appId,
            appType,
            appSrcNodeId,
            appDestNodeId,
            CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL,
            appNumChannelReq,
            appBandwidthReq,
            nwCellularAbstractAggregatedNodeInfo->gatewayNodeId);

            nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[itemIndex].msCcState
                    =CELLULAR_ABSTRACT_MS_CC_STATE_NULL;

        //update stats
        nwCellularAbstractAggregatedNodeInfo->
            stats.numVoiceCallSetupInit ++;

        if (DEBUG_RR)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d RR: prepare send setup for the app"
                "%d with transaction id %d\n",
                node->getNodeTime(),
                node->nodeId,
                appId,
                nwCellularAbstractAggregatedNodeInfo->numTransactions);
            fflush(stdout);
        }
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeHandleEndCallMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle end call messages.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractAggregatedNodeHandleEndCallMsg(Node *node,
                                                    Message *msg)
{

    CellularAbstractCallEndMessageInfo *callEndMsgInfo;
    CellularAbstractApplicationType appType;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    short appNumChannelReq;
    double appBandwidthReq;
    int itemIndex;
    int transactionId;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;

    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo
        = nwCellularAbstractData->aggregatedNodeLayer3Info;

    if (DEBUG_NET2APP)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW-APP: process the call end msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    callEndMsgInfo =
        (CellularAbstractCallEndMessageInfo *)MESSAGE_ReturnInfo(msg);
    appId = callEndMsgInfo->appId;
    appType = callEndMsgInfo->appType;
    appSrcNodeId = callEndMsgInfo->appSrcNodeId;
    appDestNodeId = callEndMsgInfo->appDestNodeId;
    appNumChannelReq = callEndMsgInfo->appNumChannelReq;
    appBandwidthReq = callEndMsgInfo->appBandwidthReq;

    //initiate the call clear process by sending disonnect msg
    if (appType == CELLULAR_ABSTRACT_VOICE_PHONE)
    {
        CellularAbstractAggregatedNodeSendCallDisconnectMsg(
            node,appId,appSrcNodeId,appDestNodeId);
    }


    //update stat
    nwCellularAbstractAggregatedNodeInfo->stats.numCallEndRcvd ++;
    //reset appinfo
    nwCellularAbstractAggregatedNodeInfo->numActiveApplicaions --;

/*  not necessary
    //GUI_CELLULAR
    if (node->guiOption == TRUE)
    {
        if (nwCellularAbstractAggregatedNodeInfo->
            numActiveApplicaions == 0)
        {
            GUI_SetNodeIcon(
                node->nodeId,
                "icons/AN-idle.gif",
                node->getNodeTime());
        }
    }
    //GUI_CELLULAR
*/

    ERROR_Assert(
        CellularAbstractAggregatedNodeLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            &itemIndex,
            &transactionId) == TRUE,
        "cannot find the appInof need for this call end msg");

    CellularAbstractAggregatedNodeResetAppItem(node, itemIndex);

    if (DEBUG_NET2APP)
    {
        printf("at %015" TYPES_64BITFMT "d node %d: Handle Call End Msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//****************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeHandleCallAnsweredMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle call answered messages.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//******************************************************************************
static
void CellularAbstractAggregatedNodeHandleCallAnsweredMsg(Node *node,
                                                         Message *msg)
{
    if (DEBUG_NET2APP)
    {
        printf("at %015" TYPES_64BITFMT "d node %d: Handle Call Answered Msg\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    CellularAbstractCallAnsweredMessageInfo *callAnswerInfo;
    CellularAbstractApplicationType appType;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    callAnswerInfo =
        (CellularAbstractCallAnsweredMessageInfo *)MESSAGE_ReturnInfo(msg);

    appType = callAnswerInfo->appType;
    if (appType == CELLULAR_ABSTRACT_VIDEO_PHONE
        || appType == CELLULAR_ABSTRACT_TEXT_MAIL
        || appType ==CELLULAR_ABSTRACT_PICTURE_MAIL
        || appType == CELLULAR_ABSTRACT_ANIMATION_MAIL
        || appType == CELLULAR_ABSTRACT_WEB)
    {
        return;
    }

    CellularAbstractAggregatedNodeSendCallConnectMsg(
        node,
        callAnswerInfo->appId,
        callAnswerInfo->appSrcNodeId,
        callAnswerInfo->appDestNodeId,
        CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL,
        nwCellularAbstractAggregatedNodeInfo->gatewayNodeId);

    if (DEBUG_NET2APP)
    {
        printf("at %015" TYPES_64BITFMT "d node %d :handle call answer mag\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeHandleCallSetupMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle call setup messages.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractAggregatedNodeHandleCallSetupMsg(Node *node,
                                                      Message *msg)
{
    int itemIndex;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;

    CellularAbstractCallSetupPkt *callSetupPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    //update stas
    nwCellularAbstractAggregatedNodeInfo->stats.numFTCallSetupRcvd ++;
    nwCellularAbstractAggregatedNodeInfo->stats.numVoiceCallSetupRcvd ++;

    callSetupPkt =
        (CellularAbstractCallSetupPkt *)MESSAGE_ReturnPacket(msg);
    appId = callSetupPkt->appId;
    appSrcNodeId = callSetupPkt->appSrcNodeId;
    appDestNodeId = callSetupPkt->appDestNodeId;
    callSrcDestType = callSetupPkt->callSrcDestType;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d AGGREGAnode:rcvd call setup from"
            "gateway for appsrc %d and dest %d \n" ,
            node->getNodeTime(), node->nodeId, appSrcNodeId, appDestNodeId);
        fflush(stdout);
    }

    //updatet he stas
    nwCellularAbstractAggregatedNodeInfo->numActiveApplicaions ++;
    nwCellularAbstractAggregatedNodeInfo->numTransactions ++;

/*  not necessary
    //GUI_CELLULAR
    if (node->guiOption == TRUE)
    {
        if ((nwCellularAbstractAggregatedNodeInfo->
            numActiveApplicaions - 1) == 0)
        {
            GUI_SetNodeIcon(
                node->nodeId,
                "icons/AN-communicating.gif",
                node->getNodeTime());
        }
    }
    //GUI_CELLULAR
*/

    //TODO:send FT call confirm to gateway;

    //create a item for this transaction
    CellularAbstractAggregatedNodeCreateAppInfoItem(
        node,
        nwCellularAbstractAggregatedNodeInfo->numTransactions,
        appId,
        callSetupPkt->appType,
        appSrcNodeId,
        appDestNodeId,
        callSetupPkt->numChannelRequired,
        callSetupPkt->bandwidthRequired,
        CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL,
        &itemIndex);

    //all the subsequent procedures will use this
    //transaction id and src to identify itself

    //inita the cc state
    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_NULL;

    CellularAbstractAggregatedNodeSendCallAlertingMsg(
        node,
        appId,
        appSrcNodeId,
        appDestNodeId,
        CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL,
        nwCellularAbstractAggregatedNodeInfo->gatewayNodeId);

    CellularAbstractAggregatedNodeSendAppCallArriveMsg(
        node,
        appId,
        nwCellularAbstractAggregatedNodeInfo->numTransactions);
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeHandlePDPContextIndication
// LAYER      :: Layer3
// PURPOSE    :: Handle PDP Context Indication.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractAggregatedNodeHandlePDPContextIndication(Node *node,
                                                              Message *msg)
{
    CellularAbstractPDPContextIndicationPkt *PDPIndicationPkt;
    int itemIndex;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractGenericTimerInfo timerInfo;


    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;


    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    //updade stats
    nwCellularAbstractAggregatedNodeInfo->stats.numDataCallActivationRcvd++;

    PDPIndicationPkt =
        (CellularAbstractPDPContextIndicationPkt *)MESSAGE_ReturnPacket(msg);

    appId = PDPIndicationPkt->appId;
    appSrcNodeId = PDPIndicationPkt->appSrcNodeId;
    appDestNodeId = PDPIndicationPkt->appDestNodeId;
    callSrcDestType = PDPIndicationPkt->callSrcDestType;

    ERROR_Assert(
        callSrcDestType ==
        CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL,
        "Only FT MS should RCVD PDPContextIndication");

    //update stat
    nwCellularAbstractAggregatedNodeInfo->numActiveApplicaions ++;
    nwCellularAbstractAggregatedNodeInfo->numTransactions ++;

/* not necessary
    //GUI_CELLULAR
    if (node->guiOption == TRUE)
    {
        if ((nwCellularAbstractAggregatedNodeInfo->
            numActiveApplicaions - 1) == 0)
        {
            GUI_SetNodeIcon(
                node->nodeId,
                "icons/AN-communicating.gif",
                node->getNodeTime());
        }
    }
    //GUI_CELLULAR
*/
    //create a item fo rthis transaction
    CellularAbstractAggregatedNodeCreateAppInfoItem(
        node,
        nwCellularAbstractAggregatedNodeInfo->numTransactions,
        appId,
        PDPIndicationPkt->appType,appSrcNodeId,
        appDestNodeId,
        PDPIndicationPkt->numChannelRequired,
        PDPIndicationPkt->bandwidthRequired,
        CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL,
        &itemIndex);

    //all the subsequent procedures will use this
    //transaction id and src to identify itself
    //inita the cc state to active
    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_ACTIVE;

    CellularAbstractAggregatedNodeSendAppCallArriveMsg(
        node,
        appId,
        nwCellularAbstractAggregatedNodeInfo->numTransactions);

    //schedule a deactivatio timer
    timerInfo.srcNodeId = appDestNodeId;

    timerInfo.transactionId =
        nwCellularAbstractAggregatedNodeInfo->numTransactions;

    timerInfo.timerType = MSG_NETWORK_CELLULAR_PDP_DEACTIVATION_Timer;

    CellularAbstractLayer3StartTimer(
        node,
        PDPIndicationPkt->appDuration,
        &timerInfo,
        sizeof(CellularAbstractGenericTimerInfo));

    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d AGGREGAnode:rcvd PDPContextIndication"
            "from gateway for appsrc %d and dest %d \n" ,
            node->getNodeTime(), node->nodeId,
            appSrcNodeId, appDestNodeId);
        fflush(stdout);
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeProcessPDPDeactivationTimer
// LAYER      :: Layer3
// PURPOSE    :: Handle PDP Deactivation Timer.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractAggregatedNodeProcessPDPDeactivationTimer(Node *node,
                                                               Message *msg)
{
    CellularAbstractGenericTimerInfo *timerInfo;
    int itemIndex;
    int transactionId;
    NodeAddress msNodeId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    timerInfo =
        (CellularAbstractGenericTimerInfo *)MESSAGE_ReturnInfo(msg);

    transactionId = timerInfo->transactionId;
    msNodeId = timerInfo->srcNodeId;

    if (CellularAbstractAggregatedNodeLookForAppInfoItem(
            node,
            transactionId,
            msNodeId,
            &itemIndex) == FALSE)
    {
        if (DEBUG_HANDOVER || DEBUG_SM)
        {
            printf(
                "at %015" TYPES_64BITFMT "d node %d cannot find the "
                "appInfo for this PDP deactiation timer"
                "The call may be droped due to src MS handover failure \n",
                node->getNodeTime(),
                node->nodeId);
            fflush(stdout);
        }
        return;
    }

    appId = nwCellularAbstractAggregatedNodeInfo->
                aggregatedNodeAppInfo[itemIndex].appId;

    appSrcNodeId = nwCellularAbstractAggregatedNodeInfo->
                    aggregatedNodeAppInfo[itemIndex].srcMsNodeId;

    appDestNodeId = nwCellularAbstractAggregatedNodeInfo->
                        aggregatedNodeAppInfo[itemIndex].destMsNodeId;

    //send application layer a message about the remote user end call
    CellularAbstractAggregatedNodeSendAppCallEndByRemote(
        node,appId,appSrcNodeId,appDestNodeId);

    //reset appinfo
    nwCellularAbstractAggregatedNodeInfo->numActiveApplicaions --;

/*  not necessary
    //GUI_CELLULAR
    if (node->guiOption == TRUE)
    {
        if (nwCellularAbstractAggregatedNodeInfo->
            numActiveApplicaions == 0)
        {
            GUI_SetNodeIcon(
                node->nodeId,
                "icons/AN-idle.gif",
                node->getNodeTime());
        }
    }
    //GUI_CELLULAR
*/

    CellularAbstractAggregatedNodeResetAppItem(node, itemIndex);
    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d AGGREGAnode:handle deactivate tiemr "
            "rset appinfo for appsrc %d and dest %d \n" ,
            node->getNodeTime(), node->nodeId, appSrcNodeId, appDestNodeId);
        fflush(stdout);
    }
}
//******************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeHandleCallAlertingMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle Call Alerting Msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractAggregatedNodeHandleCallAlertingMsg(Node *node,
                                                         Message *msg)
{
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;

    CellularAbstractCallAlertingPkt *callAlertingPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    callAlertingPkt =
        (CellularAbstractCallAlertingPkt *)MESSAGE_ReturnPacket(msg);

    appId = callAlertingPkt->appId;
    appSrcNodeId = callAlertingPkt->appSrcNodeId;
    appDestNodeId = callAlertingPkt->appDestNodeId;
    callSrcDestType = callAlertingPkt->callSrcDestType;
    ERROR_Assert(
        callSrcDestType ==
        CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL,
        "Only FO MS should RCVD call Alerting");

    //update the stats
    nwCellularAbstractAggregatedNodeInfo->stats.numFOCallAlertingRcvd ++;

    //change the ms cc state
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d AGGREGATEDA node %d CC:RCVD FO "
            "Call Alerting appID%d, src %d ,dest %d type %d \n",
            node->getNodeTime(),
            node->nodeId,
            appId,
            appSrcNodeId,
            appDestNodeId,
            callSrcDestType);
        fflush(stdout);
    }
    ERROR_Assert(
        CellularAbstractAggregatedNodeLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            &itemIndex,
            &transactionId) == TRUE,
        "cannot find the appInfo for the call alerting msg");
        //only src ms come to here

    nwCellularAbstractAggregatedNodeInfo->
        aggregatedNodeAppInfo[itemIndex].msCcState =
        CELLULAR_ABSTRACT_MS_CC_STATE_CALL_DELIVERED;

    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d AGGREGATEDA node %d CC:RCVD FO Call Alerting\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeHandleCallConnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle call connect msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractAggregatedNodeHandleCallConnectMsg(Node *node,
                                                        Message *msg)
{
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;
    CellularAbstractCallConnectPkt *callConnectPkt;
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;

    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    callConnectPkt =
        (CellularAbstractCallConnectPkt *) MESSAGE_ReturnPacket(msg);

    appId = callConnectPkt->appId;
    appSrcNodeId = callConnectPkt->appSrcNodeId;
    appDestNodeId = callConnectPkt->appDestNodeId;
    callSrcDestType = callConnectPkt->callSrcDestType;
    ERROR_Assert(
        callSrcDestType ==
        CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL,
        "Only FO MS should RCVD call coonet");

    //update the stats
    nwCellularAbstractAggregatedNodeInfo->stats.numFOCallConnectRcvd ++;

    //send connect ack and change ms cc state to active
    //CellularAbstractAggregatedNodeSendConnectAckMsg(
    //node,transactionId,appId,callSrcDestType,
    //appSrcNodeId,srcBsNodeId,appDestNodeId,0);//src ms use this

    ERROR_Assert(
        CellularAbstractAggregatedNodeLookForAppItemByAppId(
            node,appId,appSrcNodeId,
            appDestNodeId,&itemIndex,
            &transactionId) == TRUE,
        "cannot find the appInfo for this call connect msg");

    //only src ms come to here

    CellularAbstractAggregatedNodeSendAppCallAcceptMsg(
        node,
        appId,
        transactionId);

    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d AGGREGATED node %d CC:RCVD FO Call connect\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeHandleCallDisonnectMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle call disonnect msg.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractAggregatedNodeHandleCallDisonnectMsg(Node *node,
                                                          Message *msg)
{
    int itemIndex;
    int transactionId;
    int appId;
    NodeAddress appSrcNodeId;
    NodeAddress appDestNodeId;
    CellularAbstractCallSrcDestType callSrcDestType;

    CellularAbstractCallDisconnectPkt *callDisconnectPkt;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;

    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    callDisconnectPkt =
        (CellularAbstractCallDisconnectPkt *)MESSAGE_ReturnPacket(msg);

    callSrcDestType = callDisconnectPkt->callSrcDestType;

    appId = callDisconnectPkt->appId;
    appSrcNodeId = callDisconnectPkt->appSrcNodeId;
    appDestNodeId = callDisconnectPkt->appDestNodeId;
    if (DEBUG_CC)
    {
        if (callSrcDestType==CELLULAR_ABSTRACT_FIXED_ORIGINATING_CALL)
        {
            printf(
                "at %015" TYPES_64BITFMT "d AGGREGATED node %d CC:RCVD  FO Call"
                "disconnect by Network\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }
        else if (callSrcDestType==CELLULAR_ABSTRACT_FIXED_TERMINATING_CALL)
        {
            printf(
                "at %015" TYPES_64BITFMT "d AGGREGATED node %d CC:"
                "RCVD  FT Call disconnect by Network\n",
                node->getNodeTime(), node->nodeId);
            fflush(stdout);
        }

    }
    //send application layer a message about the remote user end call
    CellularAbstractAggregatedNodeSendAppCallEndByRemote(
        node,
        appId,
        appSrcNodeId,
        appDestNodeId);

    //reset appinfo
    nwCellularAbstractAggregatedNodeInfo->numActiveApplicaions --;

/* not necessary
    //GUI_CELLULAR
    if (node->guiOption == TRUE)
    {
        if (nwCellularAbstractAggregatedNodeInfo->
            numActiveApplicaions == 0)
        {
            GUI_SetNodeIcon(
                node->nodeId,
                "icons/AN-idle.gif",
                node->getNodeTime());
        }
    }
    //GUI_CELLULAR
*/

    ERROR_Assert(
        CellularAbstractAggregatedNodeLookForAppItemByAppId(
            node,
            appId,
            appSrcNodeId,
            appDestNodeId,
            &itemIndex,
            &transactionId) == TRUE,
        "cannot find the appInfo for this call disconnect msg");

    CellularAbstractAggregatedNodeResetAppItem(node, itemIndex);

}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeHandleMTCallRejectIndication
// LAYER      :: Layer3
// PURPOSE    :: Handle MT Call Reject Indication.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractAggregatedNodeHandleMTCallRejectIndication(
        Node *node,
        Message *msg)
{
    CellularAbstractMTCallRejectIndication *mtCallRejectPkt;
    Message *callRejectToAppMsg;
    CellularAbstractCallRejectMessageInfo *callRejectToAppMsgInfo;
    int itemIndex;
    int transactionId;

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;

    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;

    mtCallRejectPkt =
        (CellularAbstractMTCallRejectIndication *)MESSAGE_ReturnPacket(msg);

    //send the APP a msg about the failaure
    //notify the application layer, call failuare
    callRejectToAppMsg = MESSAGE_Alloc(
                            node,
                            APP_LAYER,
                            APP_CELLULAR_ABSTRACT,
                            MSG_APP_CELLULAR_FromNetworkCallRejected);

    MESSAGE_InfoAlloc(
        node,
        callRejectToAppMsg,
        sizeof(CellularAbstractCallRejectMessageInfo));

    callRejectToAppMsgInfo =
        (CellularAbstractCallRejectMessageInfo *)
        MESSAGE_ReturnInfo(callRejectToAppMsg);

    callRejectToAppMsgInfo->appId = mtCallRejectPkt->appId;
    callRejectToAppMsgInfo->appSrcNodeId = mtCallRejectPkt->appSrcNodeId;
    callRejectToAppMsgInfo->appDestNodeId = mtCallRejectPkt->appDestNodeId;
    callRejectToAppMsgInfo->rejectCause = mtCallRejectPkt->rejectCause;

    //TODO:instance other aribales
    MESSAGE_Send(node, callRejectToAppMsg, 0);

    //update stats
    nwCellularAbstractAggregatedNodeInfo->stats.numCallRejectSent ++;

    //reset appinfo
    nwCellularAbstractAggregatedNodeInfo->numActiveApplicaions --;

/* not necessary
    //GUI_CELLULAR
    if (node->guiOption == TRUE)
    {
        if (nwCellularAbstractAggregatedNodeInfo->
            numActiveApplicaions == 0)
        {
            GUI_SetNodeIcon(
                node->nodeId,
                "icons/AN-idle.gif",
                node->getNodeTime());
        }
    }
    //GUI_CELLULAR
*/

    ERROR_Assert(
        CellularAbstractAggregatedNodeLookForAppItemByAppId(
            node,
            mtCallRejectPkt->appId,
            mtCallRejectPkt->appSrcNodeId,
            mtCallRejectPkt->appDestNodeId,
            &itemIndex,
            &transactionId) == TRUE,
        "cannot find the appInfo for this MT call reject indication");

    CellularAbstractAggregatedNodeResetAppItem(node,itemIndex);

    if (DEBUG_CAC)
    {
        printf("node %d: CAC send APP a reject msg "
            "due to various cause\n",node->nodeId);
        fflush(stdout);
    }
}

///////////////////////////////////////////////////////////////////////
///OVERALL PROCESS FUNCIONS
//////////////////////////////////////////////////////////////////////
//MS part
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractMSHandleTrafficPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle traffic pakcet.
// PARAMETERS ::
// + node             : Node*          : Pointer to node.
// + msg              : Message*       : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**********************************************************************

static
void CellularAbstractMsHandleTrafficPacket(Node *node,Message *msg)
{
    if (DEBUG_GENERAL)
    {
        printf("node %d: Handle traffic packet\n",node->nodeId);
        fflush(stdout);
    }
    MESSAGE_Free(node, msg);
}
//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractMSHandleCCControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle CC protocl packet.
// PARAMETERS ::
// + node             : Node*        : Pointer to node.
// + msg              : Message*     : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                   : Type of message to handle
// RETURN     :: void : NULL
// **/
//***********************************************************************
static
void CellularAbstractMsHandleCCControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d: Handle CC control packet MSG TYPE %d\n",
            node->getNodeTime(), node->nodeId,messageType);
        fflush(stdout);
    }

    if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CALL_PROCEEDING)
    {
        CellularAbstractMsHandleCallProceedingMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_SETUP)
    {
        CellularAbstractMsHandleCallSetupMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_ALERTING)
    {
        CellularAbstractMsHandleCallAlertingMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT)
    {
        CellularAbstractMsHandleCallConnectMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT_ACKNOWLEDGE)
    {
        CellularAbstractMsHandleCallConnectAckMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_DISCONNECT)
    {
        CellularAbstractMsHandleCallDisconnectMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_RELEASE)
    {
        CellularAbstractMsHandleCallReleaseMsg(node,msg);
    }
    else if (messageType ==
             CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_RELEASE_COMPLETE)
    {
        CellularAbstractMsHandleCallReleaseCompleteMsg(node,msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_CALL_REJECT_INDICATION)
    {
        CellularAbstractMsHandleMTCallRejectIndication(node, msg);
    }
    MESSAGE_Free(node, msg);
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractMSHandleHandoverMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle handover msg.
// PARAMETERS ::
// + node             : Node*      : Pointer to node.
// + msg              : Message*   : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                 : Type of message to handle
// RETURN     :: void : NULL
// **/
//************************************************************************

static
void CellularAbstractMsHandleHandoverMsg(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d handle handover msg\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
    if (messageType ==
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_RI_HANDOVER_COMMAND )
    {
        CellularAbstractMsHandleRIHandoverCommandMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_HANDOVER_REQUIRED_REJECT)
    {
        CellularAbstractMsHandleHandoverRequiredRejectMsg(node, msg);
    }
}
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractMSHandleMMControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle MM protocl packet.
// PARAMETERS ::
// + node             : Node*         : Pointer to node.
// + msg              : Message*      : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                    : Type of message to handle
// RETURN     :: void : NULL
// **/
//*************************************************************************

static
void CellularAbstractMsHandleMMControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW: Handle MM control packet\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    if (messageType ==
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_LOCATION_UPDATE_ACCEPT)
    {
        CellularAbstractMsHandleLocationUpdateAcceptMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_LOCATION_UPDATE_REJECT)
    {
        CellularAbstractMsHandleLocationUpdateRejectMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_CM_SERVICE_ACCEPT)
    {
        CellularAbstractMsHandleCMServiceAccpetMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_CM_SERVICE_REJECT)
    {
        CellularAbstractMsHandleCMServiceRejectMsg(node, msg);
    }
    MESSAGE_Free(node, msg);
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractMSHandleRRControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle SM protocl packet.
// PARAMETERS ::
// + node             : Node*       : Pointer to node.
// + msg              : Message*    : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                  : Type of message to handle
// RETURN     :: void : NULL
// **/
//*************************************************************************

static
void CellularAbstractMsHandleRRControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (messageType ==
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_SYSTEM_INFORMATION_TYPE2)
    {
        CellularAbstractMsHandleSystemInformation(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_IMMEDIATE_ASSIGNMENT)
    {
        CellularAbstractMsHandleImmediateAssignmentMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_IMMEDIATE_ASSIGNMENT_REJECT)
    {
        CellularAbstractMsHandleImmediateAssignmentRejectMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_CHANNEL_RELEASE)
    {
        CellularAbstractMsHandleChannelReleaseMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_PAGING_REQUEST_TYPE1)
    {
        CellularAbstractMsHandlePageRequest(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_HANDOVER_REQUIRED_REJECT ||
        messageType ==
            CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_RI_HANDOVER_COMMAND ||
        messageType == CELLULAR_ABSTRACT_HANDOVER_REQUIRED_REJECT)
    {
        CellularAbstractMsHandleHandoverMsg(node, msg, messageType);
    }
    MESSAGE_Free(node, msg);
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractMSHandleSMControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle SM protocl packet.
// PARAMETERS ::
// + node             : Node*        : Pointer to node.
// + msg              : Message*     : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                   : Type of message to handle
// RETURN     :: void : NULL
// **/
//**************************************************************************

static
void CellularAbstractMsHandleSMControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_SM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW: Handle SM control packet\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    if (messageType == CELLULAR_ABSTRACT_SM_ACTIVATE_PDP_CONTEXT_ACCEPT)
    {
        CellularAbstractMsHandleActivatePDPContextAcceptMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_ACCEPT)
    {
        CellularAbstractMsHandleDeactivatePDPContextAcceptMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_SM_REQUEST_PDP_CONTEXT_ACTIVATION)
    {
        CellularAbstractMsHandleRequestPDPContextActivationMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_REQUEST)
    {
        CellularAbstractMsHandleDeactivatePDPContextRequestMsg(node, msg);
    }
    MESSAGE_Free(node, msg);
}
//////////////////////////////////////////////
///BS PART
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractBSHandleTrafficPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle traffic packet.
// PARAMETERS ::
// + node             : Node*      : Pointer to node.
// + msg              : Message*   : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************

static
void CellularAbstractBsHandleTrafficPacket(Node *node,Message *msg)
{
    if (DEBUG_GENERAL)
    {
        printf("node %d: Handle traffic packet\n",node->nodeId);
        fflush(stdout);
    }
    MESSAGE_Free(node, msg);
}
//*********************************************************
// /**
// FUNCTION   :: CellularAbstractBSHandleCCControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle CC protocl packet.
// PARAMETERS ::
// + node             : Node*         : Pointer to node.
// + msg              : Message*      : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                    : Type of message to handle
// RETURN     :: void : NULL
// **/
//***************************************************************

static
void CellularAbstractBsHandleCCControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d: Handle CC control packet MSG TYPE %d\n",
            node->getNodeTime(), node->nodeId, messageType);
        fflush(stdout);
    }
    if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_SETUP)
    {
        CellularAbstractBsHandleCallSetupMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CALL_PROCEEDING)
    {
        CellularAbstractBsForwardMsgToMs(node, msg, messageType);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CALL_CONFIRMED)
    {
        CellularAbstractBsHandleCallConfirmMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_ALERTING)
    {
        CellularAbstractBsHandleCallAlertingMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT)
    {
        CellularAbstractBsHandleCallConnectMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT_ACKNOWLEDGE)
    {
        CellularAbstractBsHandleCallConnectAckMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_DISCONNECT)
    {
        CellularAbstractBsHandleCallDisconnectMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_RELEASE)
    {
        CellularAbstractBsHandleCallReleaseMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_RELEASE_COMPLETE)
    {
        CellularAbstractBsHandleCallReleaseCompleteMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_CALL_REJECT_INDICATION)
    {
        CellularAbstractBsForwardMsgToMs(node, msg, messageType);
    }
    MESSAGE_Free(node, msg);
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractBSHandlehandoverMsg
// LAYER      :: Layer3
// PURPOSE    :: Handle handover packet.
// PARAMETERS ::
// + node             : Node*         : Pointer to node.
// + msg              : Message*      : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                    : Type of message to handle
// RETURN     :: void : NULL
// **/
//**********************************************************************

static
void CellularAbstractBsHandleHandoverMsg(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_HANDOVER)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW: Handle handover control packet\n",
               node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    if (messageType == CELLULAR_ABSTRACT_HANDOVER_REQUIRED)
    {
        CellularAbstractBsHandleHandoverRequiredMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_RI_HANDOVER_COMPLETE)
    {
        CellularAbstractBsHandleRIHandoverCompleteMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_HANDOVER_REQUEST)
    {
        CellularAbstractBsHandleHandoverRequestMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_HANDOVER_COMMAND)
    {
        CellularAbstractBsHandleHandoverCommandMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_HANDOVER_CLEAR_COMMAND)
    {
        CellularAbstractBsHandleHandoverClearCommandMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_HANDOVER_REQUIRED_REJECT)
    {
        CellularAbstractBsHandleHandoverRequiredRejectedMsg(node, msg);
    }
}
//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractBSHandleMMControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle MM protocl packet.
// PARAMETERS ::
// + node             : Node*      : Pointer to node.
// + msg              : Message*   : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                 : Type of message to handle
// RETURN     :: void : NULL
// **/
//***********************************************************************

static
void CellularAbstractBsHandleMMControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_MM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW: Handle MM control packet\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }

    if (messageType ==
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_LOCATION_UPDATE_REQUEST)
    {
        CellularAbstractBsHandleLocationUpdateRequestMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_LOCATION_UPDATE_ACCEPT
        || messageType ==
            CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_LOCATION_UPDATE_REJECT
        || messageType ==
            CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_CM_SERVICE_ACCEPT)
    {
        CellularAbstractBsForwardMsgToMs(node, msg, messageType);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_CM_SERVICE_REQUEST)
    {
        CellularAbstractBsHandleCMServiceRequestMsg(node, msg);
    }
    MESSAGE_Free(node, msg);
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractBSHandleRRControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle RR protocl packet.
// PARAMETERS ::
// + node             : Node*      : Pointer to node.
// + msg              : Message*   : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                 : Type of message to handle
// RETURN     :: void : NULL
// **/
//*************************************************************************

static
void CellularAbstractBsHandleRRControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    //if (DEBUG_RR)
    //{
    //    printf("node %d NW: Handle RR control packet\n",node->nodeId);
    //    fflush(stdout);
    //}
    if (messageType ==
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_CHANNEL_REQUEST)
    {
        CellularAbstractBsHandleChannelRequestMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CLEAR_COMMAND)
    {
        CellularAbstractBsHandleClearCommandMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_PAGING)
    {
        CellularAbstractBsHandlePagingMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_PAGING_RESPONSE)
    {
        CellularAbstractBsHandlePageResponseMsg(node,msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_HANDOVER_REQUIRED
        || messageType == CELLULAR_ABSTRACT_HANDOVER_COMMAND
        || messageType == CELLULAR_ABSTRACT_HANDOVER_REQUEST
        || messageType == CELLULAR_ABSTRACT_HANDOVER_CLEAR_COMMAND
        || messageType ==
            CELLULAR_ABSTRACT_RR_MESSAGE_TYPE_RI_HANDOVER_COMPLETE
        || messageType == CELLULAR_ABSTRACT_HANDOVER_REQUIRED_REJECT)
    {
        CellularAbstractBsHandleHandoverMsg(node, msg, messageType);
    }
    MESSAGE_Free(node, msg);
}
//********************************************************************
// /**
// FUNCTION   :: CellularAbstractBSHandleSMControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle SM protocl packet.
// PARAMETERS ::
// + node             : Node*     : Pointer to node.
// + msg              : Message*  : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                : Type of message to handle
// RETURN     :: void : NULL
// **/
//*******************************************************************

static
void CellularAbstractBsHandleSMControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_SM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW: Handle SM control packet\n",
            node->getNodeTime(),  node->nodeId);
        fflush(stdout);
    }
    if (messageType == CELLULAR_ABSTRACT_SM_ACTIVATE_PDP_CONTEXT_REQUEST)
    {
        CellularAbstractBsHandleActivatePDPContextRequestMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_SM_ACTIVATE_PDP_CONTEXT_ACCEPT)
    {
        CellularAbstractBsForwardMsgToMs(node, msg, messageType);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_REQUEST)
    {
        CellularAbstractBsHandleDeactivatePDPContextRequestMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_ACCEPT)
    {
        CellularAbstractBsHandleDeactivatePDPContextAcceptMsg(node, msg);
    }
    else if (messageType ==
            CELLULAR_ABSTRACT_SM_REQUEST_PDP_CONTEXT_ACTIVATION)
    {
        CellularAbstractBsForwardMsgToMs(node, msg, messageType);
    }
    MESSAGE_Free(node, msg);
}
////////////////////////////////////////////////////////////////////////
//SC paprt
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleTrafficPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle Traffic packet.
// PARAMETERS ::
// + node             : Node*        : Pointer to node.
// + msg              : Message*     : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//************************************************************************

static
void CellularAbstractScHandleTrafficPacket(Node *node, Message *msg)
{
    if (DEBUG_GENERAL)
    {
        printf(
            "node %d: Handle traffic packet\n",
            node->nodeId);
        fflush(stdout);
    }
    MESSAGE_Free(node, msg);
}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleCCControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle Cc protocl packet.
// PARAMETERS ::
// + node             : Node*       : Pointer to node.
// + msg              : Message*    : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                  : Type of message to handle
// RETURN     :: void : NULL
// **/
//**************************************************************************

static
void CellularAbstractScHandleCCControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d: Handle CC control packet MSG TYPE %d\n",
            node->getNodeTime(), node->nodeId, messageType);
        fflush(stdout);
    }
    if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_SETUP)
    {
        CellularAbstractScHandleCallSetupMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CALL_CONFIRMED)
    {
        CellularAbstractScHandleCallConfirmMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_ALERTING)
    {
        CellularAbstractScHandleCallAlertingMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT)
    {
        CellularAbstractScHandleCallConnectMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT_ACKNOWLEDGE)
    {
        CellularAbstractScHandleCallConnectAckMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_DISCONNECT)
    {
        CellularAbstractScHandleCallDisconnectMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_CALL_DISCONNECT_INDICATION)
    {
        CellularAbstractScHandleCallDisconnectIndication(node,msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_RELEASE_COMPLETE)
    {
        CellularAbstractScHandleCallReleaseCompleteMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_RELEASE)
    {
        CellularAbstractScHandleCallReleaseMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_CALL_REJECT_INDICATION)
    {
        CellularAbstractScHandleMTCallRejectIndication(node, msg);
    }
    MESSAGE_Free(node, msg);
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleHandoverPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle handover packet.
// PARAMETERS ::
// + node             : Node*      : Pointer to node.
// + msg              : Message*   : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                 : Type of message to handle
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractScHandleHandoverMsg(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_HANDOVER)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d handle handover msg\n",
            node->getNodeTime(),
            node->nodeId);
        fflush(stdout);
    }
    if (messageType == CELLULAR_ABSTRACT_HANDOVER_REQUIRED)
    {
        CellularAbstractScHandleHandoverRequiredMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_HANDOVER_REQUEST_ACK)
    {
        CellularAbstractScHandleHandoverRequestAckMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_HANDOVER_COMPLETE)
    {
        CellularAbstractScHandleHandoverCompleteMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_HANDOVER_FAILURE)
    {
        CellularAbstractScHandleHandoverFailureMsg(node, msg);
    }
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleMMControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle MM protocl packet.
// PARAMETERS ::
// + node             : Node*       : Pointer to node.
// + msg              : Message*    : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                  : Type of message to handle
// RETURN     :: void : NULL
// **/
//*************************************************************************

static
void CellularAbstractScHandleMMControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW: Handle MM control packet\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    if (messageType ==
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_LOCATION_UPDATE_REQUEST)
    {
        CellularAbstractScHandleLocationUpdateRequestMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_CM_SERVICE_REQUEST)
    {
        CellularAbstractScHandleCMServiceRequestMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_PAGING_RESPONSE)
    {
        CellularAbstractScHandlePageResponseMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_MAPD_CANCEL_LOCATION)
    {
        CellularAbstractScHandleMapdCancelLocationMsg(node, msg);
    }
    MESSAGE_Free(node, msg);
}
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleRRControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle RR protocl packet.
// PARAMETERS ::
// + node             : Node*                : Pointer to node.
// + msg              : Message*             : Message
// messageType        : CellularAbstractMessageType
//                                           : Type of message to handle
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractScHandleRRControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    //if (DEBUG_RR)
    //{
    //    printf(
    //        "node %d NW: Handle RR control packet\n",
    //        node->nodeId);
    //    fflush(stdout);
    //}
    if (messageType == CELLULAR_ABSTRACT_HANDOVER_REQUIRED
        || messageType == CELLULAR_ABSTRACT_HANDOVER_REQUEST_ACK
        || messageType == CELLULAR_ABSTRACT_HANDOVER_DETECT
        || messageType == CELLULAR_ABSTRACT_HANDOVER_COMPLETE
        || messageType == CELLULAR_ABSTRACT_HANDOVER_FAILURE)
    {
        CellularAbstractScHandleHandoverMsg(node, msg, messageType);
    }
    MESSAGE_Free(node, msg);
}
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractScHandleSMControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle SM protocl packet.
// PARAMETERS ::
// + node             : Node*    : Pointer to node.
// + msg              : Message* : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                               : Type of message to handle
// RETURN     :: void : NULL
// **/
//**********************************************************************
static
void CellularAbstractScHandleSMControlPacket(
         Node *node,
         Message *msg,
         CellularAbstractMessageType messageType)
{
    if (DEBUG_SM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW: Handle SM control packet\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    if (messageType == CELLULAR_ABSTRACT_SM_ACTIVATE_PDP_CONTEXT_REQUEST)
    {
        CellularAbstractScHandleActivatePDPContextRequestMsg(node, msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_REQUEST)
    {
        CellularAbstractScHandleDeactivatePDPContextRequestMsg(node,msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_SM_DEACTIVATE_PDP_CONTEXT_ACCEPT)
    {
        CellularAbstractScHandleDeactivatePDPContextAcceptMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_SM_PDP_CONTEXT_INDICATION)
    {
        CellularAbstractScHandlePDPContextIndication(node, msg);
    }
    MESSAGE_Free(node, msg);
}
/////////////////////////////////////////////////////////////////////
//Gateway
//*******************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleTrafficControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle Traffic packet.
// PARAMETERS ::
// + node             : Node*      : Pointer to node.
// + msg              : Message*   : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//********************************************************************
static
void CellularAbstractGatewayHandleTrafficPacket(Node *node,
                                                Message *msg)
{
    if (DEBUG_GENERAL)
    {
        printf(
            "node %d: Handle traffic packet\n",
            node->nodeId);
        fflush(stdout);
    }
    MESSAGE_Free(node, msg);
}
//********************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleCCControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle CC protocl packet.
// PARAMETERS ::
// + node             : Node*      : Pointer to node.
// + msg              : Message*   : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                 : Type of message to handle
// RETURN     :: void : NULL
// **/
//********************************************************************

static
void CellularAbstractGatewayHandleCCControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_CC)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d: Handle CC control packet MSG TYPE %d\n",
            node->getNodeTime(), node->nodeId,messageType);
        fflush(stdout);
    }

    if (messageType == CELLULAR_ABSTRACT_CC_CALL_SETUP_INDICATION)
    {
        CellularAbstractGatewayHandleCallSetupIndication(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_CALL_CONNECT_INDICATION)
    {
        CellularAbstractGatewayHandleCallConnectIndication(node,msg);
    }
    else if (messageType ==
        CELLULAR_ABSTRACT_CC_CALL_DISCONNECT_INDICATION)
    {
        CellularAbstractGatewayHandleCallDisconnectIndication(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_CALL_ALERTING_INDICATION)
    {
        CellularAbstractGatewayHandleCallAlertingIndication(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_ALERTING)
    {
        CellularAbstractGatewayHandleCallAlertingMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT)
    {
        CellularAbstractGatewayHandleCallConnectMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_SETUP)
    {
        CellularAbstractGatewayHandleCallSetupMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_DISCONNECT)
    {
        CellularAbstractGatewayHandleCallDisconnectMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_CALL_REJECT_INDICATION)
    {
        CellularAbstractGatewayHandleMTCallRejectIndication(node, msg);
    }
    MESSAGE_Free(node, msg);
}
//*******************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleMMControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle MM protocl packet.
// PARAMETERS ::
// + node             : Node*      : Pointer to node.
// + msg              : Message*   : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                 : Type of message to handle
// RETURN     :: void : NULL
// **/
//********************************************************************

static
void CellularAbstractGatewayHandleMMControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_MM)
    {
        printf(
            "at %015" TYPES_64BITFMT "d node %d NW: Handle MM control packet\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    if (messageType ==
        CELLULAR_ABSTRACT_MM_MESSAGE_TYPE_MAPD_UPDATE_LOCATION)
    {
        CellularAbstractGatewayHandleMapdUpdateLocationMsg(node, msg);
    }
    MESSAGE_Free(node, msg);
}
//********************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleRRControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle RR protocl packet.
// PARAMETERS ::
// + node             : Node*     : Pointer to node.
// + msg              : Message*  : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                : Type of message to handle
// RETURN     :: void : NULL
// **/
//********************************************************************
static
void CellularAbstractGatewayHandleRRControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    MESSAGE_Free(node, msg);
}
//********************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayHandleSMControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle SM protocl packet.
// PARAMETERS ::
// + node             : Node*      : Pointer to node.
// + msg              : Message*   : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                 : Type of message to handle
// RETURN     :: void : NULL
// **/
//********************************************************************
static
void CellularAbstractGatewayHandleSMControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_SM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW: Handle SM control packet\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    if (CELLULAR_ABSTRACT_SM_PDP_CONTEXT_INDICATION)
    {
        CellularAbstractGatewayHandlePDPContextIndication(node, msg);
    }
    MESSAGE_Free(node, msg);
}
//*********************************************************************

///////////////////////////////////////////////////////////////////////
//AGGREGATED NODE
///////////////////////////////////////////////////////////////////////
//*********************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeHandleTrafficPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle traffic  packet.
// PARAMETERS ::
// + node             : Node*    : Pointer to node.
// + msg              : Message* : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//*********************************************************************

static
void CellularAbstractAggregatedNodeHandleTrafficPacket(Node *node,
                                                       Message *msg)
{
    if (DEBUG_GENERAL)
    {
        printf("node %d: Handle traffic packet\n",node->nodeId);
        fflush(stdout);
    }
    MESSAGE_Free(node, msg);
}
//********************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeHandleCCControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle CC protocl packet.
// PARAMETERS ::
// + node             : Node*      : Pointer to node.
// + msg              : Message*   : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                 : Type of message to handle
// RETURN     :: void : NULL
// **/
//*********************************************************************
static
void CellularAbstractAggregatedNodeHandleCCControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_CC)
    {
        printf("at %015" TYPES_64BITFMT "d node %d: Handle CC control packet MSG TYPE %d\n",
            node->getNodeTime(), node->nodeId, messageType);
        fflush(stdout);
    }
    if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_SETUP)
    {
        CellularAbstractAggregatedNodeHandleCallSetupMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_ALERTING)
    {
        CellularAbstractAggregatedNodeHandleCallAlertingMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_CONNECT)
    {
        CellularAbstractAggregatedNodeHandleCallConnectMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_MESSAGE_TYPE_DISCONNECT)
    {
        CellularAbstractAggregatedNodeHandleCallDisonnectMsg(node, msg);
    }
    else if (messageType == CELLULAR_ABSTRACT_CC_CALL_REJECT_INDICATION)
    {
        CellularAbstractAggregatedNodeHandleMTCallRejectIndication(
            node, msg);
    }
    MESSAGE_Free(node, msg);
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeHandleMMControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle MM protocl packet.
// PARAMETERS ::
// + node             : Node*       : Pointer to node.
// + msg              : Message*    : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                  : Type of message to handle
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractAggregatedNodeHandleMMControlPacket(
        Node *node,
        Message *msg,
        CellularAbstractMessageType messageType)
{
    if (DEBUG_MM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW: Handle MM control packet\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    MESSAGE_Free(node, msg);
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeHandleRRControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle RR protocl packet.
// PARAMETERS ::
// + node             : Node*        : Pointer to node.
// + msg              : Message*     : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                   : Type of message to handle
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractAggregatedNodeHandleRRControlPacket(
         Node *node,
         Message *msg,
         CellularAbstractMessageType messageType)
{
    MESSAGE_Free(node, msg);
}
//************************************************************************
// /**
// FUNCTION   :: CellularAbstractAggregatedNodeHandleSMControlPacket
// LAYER      :: Layer3
// PURPOSE    :: Handle SM protocl packet.
// PARAMETERS ::
// + node             : Node*       : Pointer to node.
// + msg              : Message*    : Message for node to interpret.
// messageType        : CellularAbstractMessageType
//                                  : Type of message to handle
// RETURN     :: void : NULL
// **/
//**************************************************************************
static
void CellularAbstractAggregatedNodeHandleSMControlPacket(
         Node *node,
         Message *msg,
         CellularAbstractMessageType messageType)
{
    if (DEBUG_SM)
    {
        printf("at %015" TYPES_64BITFMT "d node %d NW: Handle SM control packet\n",
            node->getNodeTime(), node->nodeId);
        fflush(stdout);
    }
    if (messageType == CELLULAR_ABSTRACT_SM_PDP_CONTEXT_INDICATION)
    {
        CellularAbstractAggregatedNodeHandlePDPContextIndication(node, msg);
    }
    MESSAGE_Free(node, msg);
}

///**********************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3ListBs
// LAYER      :: Layer3
// PURPOSE    :: Populate List of BS for optimization
//               Added for optimization
// PARAMETERS ::
// + buf         : char*  : Pointer to buffer containing BS ids from config
// + bsList        : NodeId*  : Pointer to List of BS Node IDs
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractLayer3ListBs(
    char* buf,
    NodeId** bsList)
{
    char *currentLine = buf;
    char *next;
    char *getTokenVal;

    int thruPos;
    int i=0;

    // Search for "thru" keyword.

    thruPos = IO_FindStringPos(currentLine, " thru ");
    if (thruPos == -1 || thruPos >= (signed)strlen(buf))
    {
        // Node qualifier does not have "thru" keyword.

        char token[MAX_STRING_LENGTH];
        int numSubnetBits;
        BOOL isNodeId;

        getTokenVal = IO_GetToken(token, currentLine, &next);
        i = 0;
        while (getTokenVal)
        {
            i++;
            getTokenVal = IO_GetToken(token, next, &next);
        }//while//

        *bsList = (NodeId *) MEM_malloc((i+1) * sizeof(NodeId));

        getTokenVal = IO_GetToken(token, currentLine, &next);
        i = 0;
        while (getTokenVal)
        {
            IO_ParseNodeIdHostOrNetworkAddress(
                getTokenVal,
                &(*bsList)[i],
                &numSubnetBits,
                &isNodeId);

            getTokenVal = IO_GetToken(token, next, &next);
            i++;
        }//while//
    }
    else
    {
        // Node qualifier has "thru" keyword.

        NodeAddress startRange;
        NodeAddress endRange;
        int startNumSubnetBits;
        int endNumSubnetBits;
        char startRangeString[MAX_STRING_LENGTH];
        char endRangeString[MAX_STRING_LENGTH];
        BOOL isNodeId;

        // Parse starting value.

        getTokenVal = IO_GetToken(startRangeString, currentLine, &next);

        //printf("first token is %s\n", getTokenVal);

        // Skip over "thru" keyword.

        getTokenVal = IO_GetToken(NULL, next, &next);
        //printf("thru token is %s\n", getTokenVal);


        getTokenVal = IO_GetToken(endRangeString, next, NULL);
        //printf("end token is %s\n", getTokenVal);

        // Parse starting/ending values.
        // They can be either nodeIds or IP addresses.

        IO_ParseNodeIdHostOrNetworkAddress(
            startRangeString,
            &startRange,
            &startNumSubnetBits,
            &isNodeId);
        IO_ParseNodeIdHostOrNetworkAddress(
            endRangeString,
            &endRange,
            &endNumSubnetBits,
            &isNodeId);

        *bsList = (NodeId *) MEM_malloc((endRange - startRange + 2)
                            * sizeof(NodeId));

        for (i =0; i + startRange <= endRange; i++)
        {
            (*bsList)[i] = (NodeId) (startRange + i);
        }
    }
    (*bsList)[i] = 0;  //end of List
} //CellularAbstractLayer3ListBs

////////////////////////////////////////////////////////////////////////
////INITIAL/LAYER/FINALIZE
////////////////////////////////////////////////////////////////////////
///**********************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3PreInit
// LAYER      :: Layer3
// PURPOSE    :: Preinitialize Cellular Layer protocol
//               create a data variable to hold the
//               CellularAbstractLayer3Data information
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + nodeInput        : const NodeInput*  : Pointer to node input.
// RETURN     :: void : NULL
// **/
//*************************************************************************
void CellularAbstractLayer3PreInit(Node *node, const NodeInput *nodeInput)
{
    CellularLayer3Data *nwCellularData;
    BOOL retVal;
    char buf[MAX_STRING_LENGTH];
    char errorString[MAX_STRING_LENGTH];

    //create the structure for the data of abstract implementation;
    CellularAbstractLayer3Data *nwCellularAbstractData;

    if (DEBUG_GENERAL)
    {
        printf("node %d: Cellular Abstract Layer3 PreInit\n",node->nodeId);
        fflush(stdout);
    }

    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        MEM_malloc(sizeof(CellularAbstractLayer3Data));

    memset(nwCellularAbstractData,
           0,
          sizeof(CellularAbstractLayer3Data));

    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    nwCellularData->cellularAbstractLayer3Data =
        (CellularAbstractLayer3Data *) nwCellularAbstractData;

    //continue for second hierachy
    IO_ReadString(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-NODE-TYPE",
        &retVal,
        buf);
    if (retVal == FALSE)
    {
        sprintf(errorString,
            "Node [%u] Could not find CELLULAR-NODE-TYPE,"
            "Default type CELLULAR-MS is used\n",
            node->nodeId);
        ERROR_ReportWarning(errorString);
        nwCellularData->nodeType = CELLULAR_MS;
    }
    if (strcmp(buf, "CELLULAR-MS") == 0)
    {
        if (DEBUG_GENERAL)
        {
            printf("node %u: MS Init\n",node->nodeId);
            fflush(stdout);
        }
        nwCellularData->nodeType = CELLULAR_MS;
    }
    else if (strcmp(buf, "CELLULAR-BS") == 0)
    {
        if (DEBUG_GENERAL)
        {
            printf("node %u: BS Init\n",node->nodeId);
            fflush(stdout);
        }
        nwCellularData->nodeType = CELLULAR_BS;
    }
    else if (strcmp(buf, "CELLULAR-SC") == 0)
    {
        if (DEBUG_GENERAL)
        {
            printf("node %u: SC Init\n",node->nodeId);
            fflush(stdout);
        }
        nwCellularData->nodeType = CELLULAR_SC;
    }
    else if (strcmp(buf, "CELLULAR-GATEWAY") == 0)
    {
        if (DEBUG_GENERAL)
        {
            printf("node %u: GATEWAY Init\n",node->nodeId);
            fflush(stdout);
        }
        nwCellularData->nodeType = CELLULAR_GATEWAY;
    }
    else if (strcmp(buf, "CELLULAR-AGGREGATED-NODE") == 0)
    {
        if (DEBUG_GENERAL)
        {
            printf("node %u: AGGREGATED-NODE Init\n",node->nodeId);
            fflush(stdout);
        }
        nwCellularData->nodeType=CELLULAR_AGGREGATED_NODE;
    }
    else
    {
        ERROR_ReportError(
            "CELLULAR-NODE-TYPE parameter must be CELLULAR-MS, CELLULAR-BS,"
            "CELLULAR-SC, CELLULAR-GATEWAY or  CELLULAR-AGGREGATED-NODE");
    }
}//CellularAbstractLayer3PreInit
///************************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3Init
// LAYER      :: Layer3
// PURPOSE    :: Initialize Cellular Layer protocol
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + nodeInput        : const NodeInput*  : Pointer to node input.
// RETURN     :: void : NULL
// **/
//*************************************************************************
void CellularAbstractLayer3Init(Node *node, const NodeInput *nodeInput)
{
    //read the parameters
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    BOOL retVal;
    char buf[MAX_STRING_LENGTH];
    char errorString[MAX_STRING_LENGTH];
    int interfaceCount;
    double movThreshold;

    if (DEBUG_GENERAL)
    {
        printf(
            "node %d: Cellular Abstract Layer3 Init\n",
            node->nodeId);
        fflush(stdout);
    }

    //first hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    RANDOM_SetSeed(nwCellularData->randSeed,
                   node->globalSeed,
                   node->nodeId,
                   NETWORK_PROTOCOL_CELLULAR);

    if (nwCellularData->nodeType == CELLULAR_MS ||
        nwCellularData->nodeType == CELLULAR_BS)
    {
        for (interfaceCount = 0;
             interfaceCount < node->numberInterfaces;
             interfaceCount ++)
        {
            if (node->macData[interfaceCount]->macProtocol ==
                MAC_PROTOCOL_CELLULAR)
            {
                nwCellularData->interfaceIndex =
                    node->macData[interfaceCount]->interfaceIndex;

                if (DEBUG_NET2MAC)
                {
                    printf("node %u: Abstract MS Init find "
                        "ABSTRACT MAC interface %d\n",
                        node->nodeId,
                        nwCellularData->interfaceIndex);
                    fflush(stdout);
                }
                break;
            }
        }
        if (interfaceCount == node->numberInterfaces)
        {
            sprintf(errorString,
                "CELLULAR_MS[%u] Layer3: ABSTRACT MAC interface not found\n",
                 node->nodeId);
            ERROR_ReportError(errorString);
        }
    }

    //optimization
    IO_ReadString(
                ANY_NODEID,
                ANY_DEST,
                nodeInput,
                "CELLULAR-ABSTRACT-OPTIMIZATION-LEVEL",
                &retVal,
                buf);

    if (retVal == TRUE && strcmp(buf, "MEDIUM") == 0)
    {
        nwCellularAbstractData->optLevel =
            CELLULAR_ABSTRACT_OPTIMIZATION_MEDIUM;

        IO_ReadDouble(
            ANY_NODEID,
            ANY_ADDRESS,
            nodeInput,
            "CELLULAR-ABSTRACT-MOVEMENT-THRESHOLD",
            &retVal,
            &movThreshold);

        if (retVal == FALSE || nwCellularData->nodeType != CELLULAR_MS)
        {
            nwCellularAbstractData->movThreshold = 0.0;

        }
        else
        {
            nwCellularAbstractData->movThreshold = movThreshold;
        }
    }
    else
    {
        nwCellularAbstractData->optLevel =
            CELLULAR_ABSTRACT_OPTIMIZATION_LOW;
    }


    //Identify the Abstract interface of this node
    if (nwCellularData->nodeType == CELLULAR_MS)
    {
        CellularAbstractLayer3MsInit(node, nodeInput);
    }
    else if (nwCellularData->nodeType == CELLULAR_BS)
    {
        CellularAbstractLayer3BsInit(node, nodeInput);
    }
    else if (nwCellularData->nodeType == CELLULAR_SC)
    {
        CellularAbstractLayer3ScInit(node, nodeInput);
    }
    else if (nwCellularData->nodeType == CELLULAR_GATEWAY)
    {
        CellularAbstractLayer3GatewayInit(node, nodeInput);
    }
    else if (nwCellularData->nodeType == CELLULAR_AGGREGATED_NODE)
    {
        CellularAbstractLayer3AggregatedNodeInit(node, nodeInput);
    }

}//CellularAbstractLayer3Init
///*********************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3InitStats
// LAYER      :: Layer3
// PURPOSE    :: Initialize statistics of Cellular Layer 3
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + nodeInput        : const NodeInput*  : Pointer to node input.
// RETURN     :: void : NULL
// **/
//*************************************************************************
static
void CellularAbstractLayer3InitStats(Node *node, const NodeInput *nodeInput)
{
    BOOL               retVal;
    char               buf[MAX_STRING_LENGTH];
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;


    if (DEBUG_GENERAL)
    {
        printf("node %d: stat Init\n",node->nodeId);
        fflush(stdout);
    }

    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;
    IO_ReadString(
                node->nodeId,
                ANY_DEST,
                nodeInput,
                "CELLULAR-STATISTICS",
                &retVal,
                buf);

    if ((retVal == FALSE) || (strcmp(buf, "YES") == 0))
    {
        nwCellularData->collectStatistics = TRUE;
    }
    else if (retVal && strcmp(buf, "NO") == 0)
    {
        nwCellularData->collectStatistics = FALSE;
    }
    else
    {
        ERROR_ReportWarning(
            "Value of CELLULAR-STATISTICS should be YES or NO! Default value"
            "YES is used.");
        nwCellularData->collectStatistics = TRUE;
    }
}//CellularAbstractLayer3InitStats

//***************************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3MinBsInit
// LAYER      :: Layer3
// PURPOSE    :: Initialize BS data at MS level, for optimization
// PARAMETERS ::
// + bsId               : NodeId : BS Id
// + node             : Node*             : Pointer to node.
// + nodeInput        : const NodeInput*  : Pointer to node input.
// RETURN     :: void : NULL
// **/
//***************************************************************************
void CellularAbstractLayer3MinBsInit(
        NodeId bsId,
        Node *node,
        const NodeInput *nodeInput)
{
    CellularLayer3Data* nwCellularData;
    CellularAbstractLayer3Data* nwCellularAbstractData;
    CellularAbstractLayer3MsInfo* nwCellularAbstractMsInfo;
    char buf[MAX_STRING_LENGTH];
    int  readVal;
    BOOL retVal;
    clocktype readTime;
    double readDouble;
    Node* bsNode;
    char string[MAX_STRING_LENGTH];

    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    CellularAbstractLayer3BsMinInfo* bsMinInfo =
        (CellularAbstractLayer3BsMinInfo *)
        MEM_malloc(sizeof(CellularAbstractLayer3BsMinInfo));
    memset(bsMinInfo, 0, sizeof(CellularAbstractLayer3BsMinInfo));

    //system information
    //need further instance the message
    bsMinInfo->systemInfoType2 = NULL;
    CellularAbstractBsSystemInfo *sysInfoMsg;

    //build the system info braodcast pakcet wihch is
    //embed in a msg MSG_MAC_CELLULAR_FromNetwork).
    bsMinInfo->systemInfoType2
        = MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        bsMinInfo->systemInfoType2,
        sizeof(CellularAbstractBsSystemInfo),
        TRACE_CELLULAR);

    sysInfoMsg = (CellularAbstractBsSystemInfo*)
                    MESSAGE_ReturnPacket(
                        bsMinInfo->systemInfoType2);

    memset(sysInfoMsg, 0, sizeof(CellularAbstractBsSystemInfo));

    PARTITION_ReturnNodePointer(node->partitionData,
                                    &bsNode,
                                    bsId,
                                    FALSE);
    //sector info
    IO_ReadInt(
        bsId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-ABSTRACT-BS-NUMBER-SECTOR",
        &retVal,
        &readVal);

    if (retVal == FALSE)
    {
        sysInfoMsg->numSector =
            CELLULAR_ABSTRACT_MAX_SECTOR_PER_BS;
    }
    else if (readVal > 0 &&
             readVal <= CELLULAR_ABSTRACT_MAX_SECTOR_PER_BS)
    {
        sysInfoMsg->numSector = (short)readVal;
    }
    else
    {
        sysInfoMsg->numSector =
            CELLULAR_ABSTRACT_MAX_SECTOR_PER_BS;
    }

    sysInfoMsg->bsNodeId = bsId;

    sysInfoMsg->bsNodeAddress =
        MAPPING_GetDefaultInterfaceAddressFromNodeId(bsNode, bsId);

    //cellId
    IO_ReadInt(
        bsId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-BS-CELL-ID",
        &retVal,
        &readVal);

    if (retVal == FALSE)
    {
        // set as default value, node Id
        sysInfoMsg->cellId = node->nodeId;
    }
    else
    {
        sysInfoMsg->cellId = readVal;
    }
    //sysInfoMsg->lac = nwCellularAbstractBsInfo->lac;
    //sysInfoMsg->cellId = nwCellularAbstractBsInfo->cellId;

    //get LAC
    IO_ReadInt(
        bsId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-BS-LAC",
        &retVal,
        &readVal);

    if (retVal == FALSE)
    {
        // set default value
        sysInfoMsg->lac = node->nodeId;
    }
    else
    {
        sysInfoMsg->lac = readVal;
    }

    //control channel
    //uplink control channel
    IO_ReadString(bsId,
                  ANY_ADDRESS,
                  nodeInput,
                  "CELLULAR-ABSTRACT-BS-CONTROL-CHANNEL-UPLINK",
                  &retVal,
                  string);

    Int32 channelIndex = -1;
    if (retVal)
    {
        if (IO_IsStringNonNegativeInteger(string))
        {
            channelIndex = (Int32)strtoul(string, NULL, 10);
            if (channelIndex < node->numberChannels)
            {
                sysInfoMsg->controlULChannelIndex = channelIndex;
            }
            else
            {
                ERROR_ReportWarningArgs(
                    "CELLULAR-ABSTRACT-BS-CONTROL-CHANNEL-UPLINK"
                    "parameter should be an integer between "
                    "0 and %d or a valid channel name."
                    "Set default uplink channel index 0",
                    node->numberChannels - 1);

                sysInfoMsg->controlULChannelIndex = 0;
            }
        }
        else if (isalpha(*string) && PHY_ChannelNameExists(node, string))
        {
            sysInfoMsg->controlULChannelIndex = 
                            PHY_GetChannelIndexForChannelName(node,
                                                              string);
        }
        else
        {
            ERROR_ReportWarningArgs(
                    "CELLULAR-ABSTRACT-BS-CONTROL-CHANNEL-UPLINK"
                    "parameter should be an integer between "
                    "0 and %d or a valid channel name."
                    "Set default uplink channel index 0",
                    node->numberChannels - 1);

            sysInfoMsg->controlULChannelIndex = 0;
        }
    }
    else
    {
        sysInfoMsg->controlULChannelIndex = 0;
    }

    //downlink control channel
    IO_ReadString(bsId,
                  ANY_ADDRESS,
                  nodeInput,
                  "CELLULAR-ABSTRACT-BS-CONTROL-CHANNEL-DOWNLINK",
                  &retVal,
                  string);

    if (retVal)
    {
        if (IO_IsStringNonNegativeInteger(string))
        {
            channelIndex = (Int32)strtoul(string, NULL, 10);
            if (channelIndex < node->numberChannels)
            {
                sysInfoMsg->controlDLChannelIndex = channelIndex;
            }
            else
            {
                ERROR_ReportWarningArgs(
                    "CELLULAR-ABSTRACT-BS-CONTROL-CHANNEL-DOWNLINK "
                    "parameter should be an integer between "
                    "0 and %d or a valid channel name."
                    "Set default downlink channel index 1",
                    node->numberChannels - 1);

                sysInfoMsg->controlDLChannelIndex = 1;
            }
        }
        else if (isalpha(*string) && PHY_ChannelNameExists(node, string))
        {
            sysInfoMsg->controlDLChannelIndex = 
                            PHY_GetChannelIndexForChannelName(node,
                                                              string);
        }
        else
        {
            ERROR_ReportWarningArgs(
                    "CELLULAR-ABSTRACT-BS-CONTROL-CHANNEL-DOWNLINK "
                    "parameter should be an integer between "
                    "0 and %d or a valid channel name."
                    "Set default downlink channel index 1",
                    node->numberChannels - 1);

            sysInfoMsg->controlDLChannelIndex = 1;
        }
    }
    else
    {
        sysInfoMsg->controlDLChannelIndex = 1;
    }

    //CELLULAR-ABSTRACT-BS-CONGESTION-CONTROL-POLICY
    IO_ReadString(
        bsId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-ABSTRACT-BS-CONGESTION-CONTROL-POLICY",
        &retVal,
        buf);

    if (retVal == FALSE)
    {
        sysInfoMsg->congestionControlPolicy =
            CELLULAR_ABSTRACT_CONGESTION_CONTROL_NONE;
    }
    else if (strcmp(buf, "NONE") == 0)
    {
        sysInfoMsg->congestionControlPolicy =
            CELLULAR_ABSTRACT_CONGESTION_CONTROL_NONE;
    }
    else if (strcmp(buf, "ROUND-ROBIN") == 0)
    {
        sysInfoMsg->congestionControlPolicy =
            CELLULAR_ABSTRACT_CONGESTION_CONTROL_ROUND_ROBIN;

        //control duration
        IO_ReadTime(
            bsId,
            ANY_ADDRESS,
            nodeInput,
            "ROUND-ROBIN-CONGESTION-CONTROL-DURATION",
            &retVal,
            &readTime);

        if (retVal == FALSE)
        {
            sysInfoMsg->oneControlDuration =
                CELLULAR_ABSTRACT_DEFAULT_ROUND_ROBIN_CONGESTION_CONTROL_DURATION;
        }
        else
        {
            sysInfoMsg->oneControlDuration = readTime;
        }

        //number of access class
        IO_ReadInt(
            bsId,
            ANY_ADDRESS,
            nodeInput,
            "ROUND-ROBIN-CONGESTION-CONTROL-ACCESS-CLASS",
            &retVal,
            &readVal);

        if (retVal == FALSE)
        {
            sysInfoMsg->numAccessClass =
                CELLULAR_ABSTRACT_DEFAULT_ROUND_ROBIN_CONGESTION_CONTROL_ACCESS_CLASS;
        }
        else
        {
            sysInfoMsg->numAccessClass = (short)readVal;
        }

        //refrain probability
        IO_ReadDouble(
            bsId,
            ANY_ADDRESS,
            nodeInput,
            "ROUND-ROBIN-CONGESTION-CONTROL-REFRAIN-PROBABILITY",
            &retVal,
            &readDouble);

        if (retVal == FALSE)
        {
            sysInfoMsg->refrainProb =
                CELLULAR_ABSTRACT_DEFAULT_ROUND_ROBIN_CONGESTION_CONTROL_REFRAIN_PROBABILITY;
        }
        else
        {
            if (readDouble == 0.5 ||
                readDouble == 0.75 ||
                readDouble == 0.25)
            {
                sysInfoMsg->refrainProb = readDouble;
            }
            else
            {
                sysInfoMsg->refrainProb = 0.25;
            }
        }
    }
    else
    {
        // for others not implemented yet
        sysInfoMsg->congestionControlPolicy =
            CELLULAR_ABSTRACT_CONGESTION_CONTROL_NONE;
    }

    sysInfoMsg->txInteger = CELLULAR_TX_INTEGER;
    sysInfoMsg->maxReTrans = CELLULAR_MAX_RETRANS;

    bsMinInfo->bsNodeId = bsId;
    bsMinInfo->numSectors = (short)sysInfoMsg->numSector;
    MOBILITY_ReturnCoordinates(
        bsNode,
        &(bsMinInfo->bsPosition));

    sysInfoMsg->bsLocationC1 = bsMinInfo->bsPosition.common.c1;
    sysInfoMsg->bsLocationC2 = bsMinInfo->bsPosition.common.c2;
    sysInfoMsg->bsLocationC3 = bsMinInfo->bsPosition.common.c3;

    bsMinInfo->next = nwCellularAbstractMsInfo->bsMinInfo;
    nwCellularAbstractMsInfo->bsMinInfo = bsMinInfo;

    CellularAbstractMsHandleSystemInformation(node,
            bsMinInfo->systemInfoType2);

}//CellularAbstractLayer3MinBsInit

///***********************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3MsInit
// LAYER      :: Layer3
// PURPOSE    :: Initialize MS's Cellular Layer protocol
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + nodeInput        : const NodeInput*  : Pointer to node input.
// RETURN     :: void : NULL
// **/
//**************************************************************************
void CellularAbstractLayer3MsInit(Node *node, const NodeInput *nodeInput)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;
    char buf[MAX_STRING_LENGTH];
    int i;

    if (DEBUG_GENERAL)
    {
        printf("node %d: in MS inti process\n",node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    nwCellularAbstractData->msLayer3Info =
        (CellularAbstractLayer3MsInfo *)
        MEM_malloc(sizeof(CellularAbstractLayer3MsInfo));

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    memset(nwCellularAbstractMsInfo,
           0,
          sizeof(CellularAbstractLayer3MsInfo));

    nwCellularAbstractMsInfo->msNodeId = node->nodeId;

    nwCellularAbstractMsInfo->msNodeAddress =
        MAPPING_GetDefaultInterfaceAddressFromNodeId(node, node->nodeId);

    nwCellularAbstractMsInfo->userAge = CELLULAR_ABSTRACT_USER_DEFAULT_AGE;
    nwCellularAbstractMsInfo->userGender = CELLULAR_ABSTRACT_USER_MALE;
    nwCellularAbstractMsInfo->isPowerOn = FALSE;
    nwCellularAbstractMsInfo->isBsSelected = FALSE;
    nwCellularAbstractMsInfo->isLocationUpdateInProgress = FALSE;
    nwCellularAbstractMsInfo->numLocationUpdateAttempt = 0;
    nwCellularAbstractMsInfo->timerT3212Msg = NULL;
    nwCellularAbstractMsInfo->t3212TimeoutValue =
        DefaultCellularAbstractPeriodicLocationUpdateTimer_T3212Time;

    nwCellularAbstractMsInfo->channelReqForLocationUpdate =
        (CellularAbstractChannelRequestInfo *)
        MEM_malloc(sizeof(CellularAbstractChannelRequestInfo));

    memset(
        nwCellularAbstractMsInfo->channelReqForLocationUpdate,
        0,
        sizeof(CellularAbstractChannelRequestInfo));

    nwCellularAbstractMsInfo->
        channelReqForLocationUpdate->numChannelRequestAttempts = 0;

    nwCellularAbstractMsInfo->associatedBsSectorInfo =
        (CellularAbstractAssociatedBsSectorInfo *)
        MEM_malloc(sizeof(CellularAbstractAssociatedBsSectorInfo));

    memset(
        nwCellularAbstractMsInfo->associatedBsSectorInfo,
        0,
        sizeof(CellularAbstractAssociatedBsSectorInfo));

    nwCellularAbstractMsInfo->reportInfo =
        (CellularAbstractMeasurementReportMsgInfo *)
        MEM_malloc(CELLULAR_ABSTRACT_MAX_BS_SECTOR_CANDIDATE
        * sizeof(CellularAbstractMeasurementReportMsgInfo));

    nwCellularAbstractMsInfo->isTransactionInProcess = FALSE;
    nwCellularAbstractMsInfo->numTransactions = 0;
    nwCellularAbstractMsInfo->numActiveApplicaions = 0;
    nwCellularAbstractMsInfo->userCommState =
        CELLULAR_ABSTRACT_MS_COMM_STATE_IDLE;
    nwCellularAbstractMsInfo->isHandoverInProgress = FALSE;
    nwCellularAbstractMsInfo->handoverState =
        CELLULAR_ABSTRACT_HANDOVER_STATE_IDLE;

    nwCellularAbstractMsInfo->handoverInfo =
        (CellularAbstractHandoverInfo *)
        MEM_malloc(sizeof(CellularAbstractHandoverInfo));

    memset(
        nwCellularAbstractMsInfo->handoverInfo,
        0,
        sizeof(nwCellularAbstractMsInfo->handoverInfo));

    //bs sector candidate
    nwCellularAbstractMsInfo->bsSectorCandidate = NULL;

    //appInfoatMS
    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_MS+1; i++)
    {
        nwCellularAbstractMsInfo->msAppInfo[i].inUse = FALSE;
    }

    //handover margin

    //optimization
    if (nwCellularAbstractData->optLevel !=
            CELLULAR_ABSTRACT_OPTIMIZATION_LOW)
    {
        int i;

        memset(buf, 0, MAX_STRING_LENGTH);
        for (i=0; i < nodeInput->numLines; i++)
        {
            if (strcmp(nodeInput->values[i], "CELLULAR-BS") == 0)
            {
                strcpy(buf, nodeInput->qualifiers[i]);


                if (buf)
                {
                    NodeId* bsList=NULL;
                    int j;

                    //get a list of BS
                    CellularAbstractLayer3ListBs(buf, &bsList);

                    j = 0;
                    while (bsList[j] != 0)
                    {
                        //populate data at MS
                        CellularAbstractLayer3MinBsInit(bsList[j],
                                                        node,
                                                        nodeInput);
                        j++;
                    }
                    MEM_free(bsList);
                }
            }
        }
    }

    // init the first position
    nwCellularAbstractMsInfo->lastUpdatePosition =
        node->mobilityData->current->position;

    //statistics
    CellularAbstractLayer3InitStats(node, nodeInput);
}//CellularAbstractLayer3MsInit

//***********************************************************************
//BS
//***********************************************************************
//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractParseChannelRange
// LAYER      :: Layer3
// PURPOSE    :: parse the channel range allocated to the BS
// PARAMETERS ::
// + channelRangeString : char * : Pointer to the channel range string.
// + channelRangeStart : short*  : Pointer to the first channel.
// + channelRangeEnd : short * : Pointer to the last channel.
// RETURN     :: void : NULL
// **/
//***********************************************************************
#if 0
static
void CellularAbstractParseChannelRange(
        char    *channelRangeString,
        short   *channelRangeStart,
        short   *channelRangeEnd)
{
    char    *firstPart;
    char    errorString[MAX_STRING_LENGTH];


    firstPart = channelRangeString;

    while (firstPart++ != NULL)
    {
        if (*firstPart == '-')
        {
            char    *secondPart;

            secondPart = firstPart + 1;
            *firstPart = 0;

            *channelRangeStart = (short)
                strtoul(channelRangeString+1, NULL, 10);
            *channelRangeEnd = (short)
                strtoul(secondPart, NULL, 10);

           return;
        }
    }

    *channelRangeStart = 0;
    *channelRangeEnd = 0;

    sprintf(
        errorString,
        "Incorrect format for channel range: %s",
        channelRangeString);
    ERROR_ReportError(errorString);

} // End of CellularAbstractParseChannelRange //
#endif
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3BsInit
// LAYER      :: Layer3
// PURPOSE    :: Initialize BS's Cellular Layer protocol
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + nodeInput        : const NodeInput*  : Pointer to node input.
// RETURN     :: void : NULL
// **/
//**************************************************************************
void CellularAbstractLayer3BsInit(Node *node, const NodeInput *nodeInput)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;
    char buf[MAX_STRING_LENGTH];
    int  readVal;
    char errorString[MAX_STRING_LENGTH];
    BOOL retVal;
    int sectorIndex;
    clocktype readTime;
    double readDouble;
    char string[MAX_STRING_LENGTH];
    Int32 channelIndex = -1;

    if (DEBUG_GENERAL)
    {
        printf("node %d: in BS inti process\n",node->nodeId);
        fflush(stdout);
    }
    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    nwCellularAbstractData->bsLayer3Info =
        (CellularAbstractLayer3BsInfo *)
        MEM_malloc(sizeof(CellularAbstractLayer3BsInfo));

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;
    memset(nwCellularAbstractBsInfo,
           0,
          sizeof(CellularAbstractLayer3BsInfo));

    nwCellularAbstractBsInfo->bsNodeId = node->nodeId;

    nwCellularAbstractBsInfo->bsNodeAddress =
        MAPPING_GetDefaultInterfaceAddressFromNodeId(node, node->nodeId);

    //cellId
    IO_ReadInt(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-BS-CELL-ID",
        &retVal,
        &readVal);

    if (retVal == FALSE)
    {
        sprintf(errorString,
            "Node [%d] Could not find CELLULAR-BS-CELL-ID,"
            "Set to default as node Id\n",
            node->nodeId);
        ERROR_ReportWarning(errorString);
        // set as default value, node Id
        nwCellularAbstractBsInfo->cellId = node->nodeId;
    }
    else
    {
        nwCellularAbstractBsInfo->cellId = readVal;
        if (DEBUG_GENERAL)
        {
            printf(
                "node %d: Cell Id is %d\n",
                node->nodeId,nwCellularAbstractBsInfo->cellId);
            fflush(stdout);
        }
    }

    //get LAC
    IO_ReadInt(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-BS-LAC",
        &retVal,
        &readVal);

    if (retVal == FALSE)
    {
        sprintf(errorString,
            "Node [%d] Could not find its CELLULAR-BS-LAC,"
            " set node Id as defalut\n",
            node->nodeId);
        ERROR_ReportWarning(errorString);

        // set default value
        nwCellularAbstractBsInfo->lac = node->nodeId;
    }
    else
    {
        nwCellularAbstractBsInfo->lac = readVal;
    }

    if (DEBUG_GENERAL)
    {
        printf(
            "node %d: associate SC nodeId is %d, "
            "address is %d lac is %d \n",
            node->nodeId,
            nwCellularAbstractBsInfo->associatedScNodeId,
            nwCellularAbstractBsInfo->associatedScNodeAddress,
            nwCellularAbstractBsInfo->lac);
        fflush(stdout);
    }
    // associated sc
    IO_ReadInt(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-BS-ASSOCIATE-SC",
        &retVal,
        &readVal);

    if (retVal == FALSE)
    {
        sprintf(errorString,
            "Node [%d] Could not find its CELLULAR-BS-ASSOCIATE-SC\n",
            node->nodeId);
        ERROR_ReportError(errorString);
    }
    else
    {
        NodeAddress scNodeId;
        BOOL retValSc;
        char bufSc[MAX_STRING_LENGTH];

        scNodeId = readVal;
        IO_ReadString(
            scNodeId,
            ANY_ADDRESS,
            nodeInput,
            "CELLULAR-NODE-TYPE",
            &retValSc,
            bufSc);
        if (retValSc == FALSE || strcmp(bufSc, "CELLULAR-SC") != 0)
        {
            sprintf(errorString,
                "Node [%d]: the claimed SC node %d type is not a SC\n",
                node->nodeId, scNodeId);
            ERROR_ReportError(errorString);
        }

        nwCellularAbstractBsInfo->associatedScNodeId = readVal;
        nwCellularAbstractBsInfo->associatedScNodeAddress =
            MAPPING_GetDefaultInterfaceAddressFromNodeId(node, scNodeId);
    }

    //location informaiton
    MOBILITY_ReturnCoordinates(
        node,
        &(nwCellularAbstractBsInfo->bsLocation));

    if (DEBUG_GENERAL)
    {
        printf("node %d: position is %f %f %f \n",
            node->nodeId,
            nwCellularAbstractBsInfo->bsLocation.cartesian.x,
            nwCellularAbstractBsInfo->bsLocation.cartesian.y,
            nwCellularAbstractBsInfo->bsLocation.cartesian.z);
        fflush(stdout);
    }

    #ifdef CHANNEL_ALLOCATION
    //channel range for the BS
    IO_ReadString(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-BS-CHANNEL-RANGE",
        &retVal,
        buf);

    if (retVal == FALSE)
    {
        sprintf(
            errorString,
            "Node [%d] Could not find its CELLULAR-BS-CHANNEL-RANGE\n",
            node->nodeId);
        ERROR_ReportError(errorString);
    }
    else
    {
        int channelIndexStart;
        int channelIndexEnd;
        int i;
        int j;

        if (DEBUG_GENERAL)
        {
            printf("node %d the channel range string is %s\n",
                node->nodeId,buf);
            fflush(stdout);
        }

        CellularAbstractParseChannelRange(
            buf,&channelIndexStart,&channelIndexEnd);

        if (DEBUG_GENERAL)
        {
            printf(
                "node %d the channel range string is %d to %d %s \n",
                node->nodeId,channelIndexStart,channelIndexEnd,buf);
            fflush(stdout);
        }

        nwCellularAbstractBsInfo->numChannelAssigned =
            channelIndexEnd-channelIndexStart + 1;
        nwCellularAbstractBsInfo->numChannelInUse = 0;
        if (nwCellularAbstractBsInfo->numChannelAssigned <= 1)
        {
            sprintf(
                errorString,
                "Node [%d] The CHANNELs ASSIGNED"
                "TO THIS BS is not valid\n",
                node->nodeId);
            ERROR_ReportError(errorString);
        }

        for (i = 0; i < CELLULAR_ABSTRACT_MAX_CHANNEL_PER_BS;i ++)
        {
            nwCellularAbstractBsInfo->bsChannelBank[i].channelIndex =
                CELLULAR_ABSTRACT_INVALID_CHANNEL_ID;
        }//initialize all the channel

        j = channelIndexStart;
        for (i = 0; i < nwCellularAbstractBsInfo->numChannelAssigned; i ++)
        {
            nwCellularAbstractBsInfo->bsChannelBank[i].channelIndex = j;
            j ++;
            nwCellularAbstractBsInfo->bsChannelBank[i].channelBandwidth =
                CELLULAR_ABSTRACT_DEFAULT_CHANNEL_BANDWIDTH;

            nwCellularAbstractBsInfo->bsChannelBank[i].channelFreq =
                CELLULAR_ABSTRACT_DEFAULT_CHANNEL_FREQUENCY;

            nwCellularAbstractBsInfo->bsChannelBank[i].channelBasicDateRate =
                CELLULAR_ABSTRACT_DEFAULT_CHANNEL_DATE_RATE;

            nwCellularAbstractBsInfo->bsChannelBank[i].channelBusyTime = 0;
            nwCellularAbstractBsInfo->bsChannelBank[i].channelIdelTime = 0;

            nwCellularAbstractBsInfo->
                bsChannelBank[i].isControlChannel = FALSE;

            nwCellularAbstractBsInfo->bsChannelBank[i].channelStatus =
                CELLULAR_ABSTRACT_CHANNEL_STATUS_IDLE;
            if (DEBUG_GENERAL)
            {
                printf(
                    "node %d: BS is assined with channel %d\n",
                    node->nodeId,
                    nwCellularAbstractBsInfo->bsChannelBank[i].channelIndex);
                fflush(stdout);
            }
        }
    }
    #endif /* CHANNEL_ALLOCATION*/

    // control channel
    // uplink control channel
    IO_ReadString(node->nodeId,
                  ANY_ADDRESS,
                  nodeInput,
                  "CELLULAR-ABSTRACT-BS-CONTROL-CHANNEL-UPLINK",
                  &retVal,
                  string);
    if (retVal == FALSE)
    {
        sprintf(
            errorString,
            "Node [%d] Could not find its"
            "ABSTRACT-CELLULAR-BS-CONTROL-CHANNEL-UPLINK,"
            "Set default 0\n",
            node->nodeId);
        ERROR_ReportWarning(errorString);
        nwCellularAbstractBsInfo->controlULChannelIndex = 0;
    }
    else
    {
        if (IO_IsStringNonNegativeInteger(string))
        {
            channelIndex = (Int32)strtoul(string, NULL, 10);
            if (channelIndex < node->numberChannels)
            {
                nwCellularAbstractBsInfo->controlULChannelIndex =
                                                            channelIndex;
            }
            else
            {
                ERROR_ReportWarningArgs(
                    "CELLULAR-ABSTRACT-BS-CONTROL-CHANNEL-UPLINK"
                    "parameter should be an integer between "
                    "0 and %d or a valid channel name."
                    "Set default uplink channel index 0",
                    node->numberChannels - 1);

                nwCellularAbstractBsInfo->controlULChannelIndex = 0;
            }
        }
        else if (isalpha(*string) && PHY_ChannelNameExists(node, string))
        {
                nwCellularAbstractBsInfo->controlULChannelIndex = 
                                    PHY_GetChannelIndexForChannelName(node,
                                                                      string);
        }
        else
        {
            ERROR_ReportWarningArgs(
                "CELLULAR-ABSTRACT-BS-CONTROL-CHANNEL-UPLINK"
                "parameter should be an integer between "
                "0 and %d or a valid channel name."
                "Set default uplink channel index 0",
                node->numberChannels - 1);

            nwCellularAbstractBsInfo->controlULChannelIndex = 0;
        }

    #ifdef CHANNEL_ALLOCATION
        int i;
        for (i = 0; i < nwCellularAbstractBsInfo->numChannelAssigned; i++)
        {
            if (nwCellularAbstractBsInfo->bsChannelBank[i].channelIndex ==
                    nwCellularAbstractBsInfo->controlULChannelIndex)
            {
                nwCellularAbstractBsInfo->
                    bsChannelBank[i].isChannelInUse = TRUE;

                nwCellularAbstractBsInfo->
                    bsChannelBank[i].isControlChannel = TRUE;

                nwCellularAbstractBsInfo->bsChannelBank[i].channelStatus =
                    CELLULAR_ABSTRACT_CHANNEL_STATUS_INUSE_CONTROL;

                nwCellularAbstractBsInfo->numChannelInUse ++;
                if (DEBUG_GENERAL)
                {
                    printf(
                        "node %d: the uplink control channel index"
                        "is %d in array %d\n",
                        node->nodeId,

                        nwCellularAbstractBsInfo->
                            bsChannelBank[i].channelIndex,

                        i);
                    fflush(stdout);
                }
                break;
            }
        }
    #endif /* CHANNEL_ALLOCATION */
    }

    //downlink control channel
    IO_ReadString(node->nodeId,
                  ANY_ADDRESS,
                  nodeInput,
                  "CELLULAR-ABSTRACT-BS-CONTROL-CHANNEL-DOWNLINK",
                  &retVal,
                  string);

    if (retVal == FALSE)
    {
        sprintf(errorString,
            "Node [%d] Could not find its "
            "ABSTRACT-CELLULAR-BS-CONTROL-CHANNEL-DOWNLINK,"
            "set default 1\n",
            node->nodeId);
        ERROR_ReportWarning(errorString);
        nwCellularAbstractBsInfo->controlDLChannelIndex = 1;
    }
    else
    {
        if (IO_IsStringNonNegativeInteger(string))
        {
            channelIndex = (Int32)strtoul(string, NULL, 10);
            if (channelIndex < node->numberChannels)
            {
                nwCellularAbstractBsInfo->controlDLChannelIndex = channelIndex;
            }
            else
            {
                ERROR_ReportWarningArgs(
                    "CELLULAR-ABSTRACT-BS-CONTROL-CHANNEL-DOWNLINK"
                    "parameter should be an integer between "
                    "0 and %d or a valid channel name."
                    "Set default downlink channel index 1",
                    node->numberChannels - 1);

                nwCellularAbstractBsInfo->controlDLChannelIndex = 1;
            }
        }
        else if (isalpha(*string) && PHY_ChannelNameExists(node, string))
        {
            nwCellularAbstractBsInfo->controlDLChannelIndex = 
                                PHY_GetChannelIndexForChannelName(node,
                                                                  string);
        }
        else
        {
            ERROR_ReportWarningArgs(
                "CELLULAR-ABSTRACT-BS-CONTROL-CHANNEL-DOWNLINK"
                "parameter should be an integer between "
                "0 and %d or a valid channel name."
                "Set default downlink channel index 1",
                node->numberChannels - 1);

            nwCellularAbstractBsInfo->controlDLChannelIndex = 1;
        }

    #ifdef CHANNEL_ALLOCATION
        int i;
        for (i = 0; i < nwCellularAbstractBsInfo->numChannelAssigned;i ++)
        {
            if (nwCellularAbstractBsInfo->bsChannelBank[i].channelIndex ==
                    nwCellularAbstractBsInfo->controlDLChannelIndex)
            {
                nwCellularAbstractBsInfo->
                    bsChannelBank[i].isChannelInUse = TRUE;

                nwCellularAbstractBsInfo->
                    bsChannelBank[i].isControlChannel = TRUE;

                nwCellularAbstractBsInfo->bsChannelBank[i].channelStatus =
                    CELLULAR_ABSTRACT_CHANNEL_STATUS_INUSE_CONTROL;

                nwCellularAbstractBsInfo->numChannelInUse ++;
                if (DEBUG_GENERAL)
                {
                    printf(
                        "node %d: the downlink control channel index"
                        "is %d in array %d\n",
                        node->nodeId,
                        nwCellularAbstractBsInfo->
                            bsChannelBank[i].channelIndex,
                        i);
                    fflush(stdout);
                }
                break;
            }
        }
    #endif /* CHANNEL_ALLOCATION */
    }

    //sector info
    IO_ReadInt(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-ABSTRACT-BS-NUMBER-SECTOR",
        &retVal,
        &readVal);

    if (retVal == FALSE)
    {
        sprintf(errorString,
            "Node [%d] Could not find its"
            "CELLULAR-ABSTRACT-BS-NUMBER-SECTOR,"
            "Set default value 6\n",
            node->nodeId);
        ERROR_ReportWarning(errorString);
        nwCellularAbstractBsInfo->numSectorInCell =
            CELLULAR_ABSTRACT_MAX_SECTOR_PER_BS;
    }
    else if (readVal > 0 &&
             readVal <= CELLULAR_ABSTRACT_MAX_SECTOR_PER_BS)
    {
        nwCellularAbstractBsInfo->numSectorInCell = (short)readVal;
        if (DEBUG_GENERAL)
        {
            printf(
                "node %d: the number of cell in the BS is %d\n",
                node->nodeId,nwCellularAbstractBsInfo->numSectorInCell);
            fflush(stdout);
        }
    }
    else
    {
        sprintf(errorString,
                    "Node [%d] its"
                    "CELLULAR-ABSTRACT-BS-NUMBER-SECTOR "
                    "should >0 and < 6, Set default value 6\n",
                    node->nodeId);
        ERROR_ReportWarning(errorString);
        nwCellularAbstractBsInfo->numSectorInCell =
            CELLULAR_ABSTRACT_MAX_SECTOR_PER_BS;

    }


    //sector channel allocation info
    for (sectorIndex = 1;
            sectorIndex <= nwCellularAbstractBsInfo->numSectorInCell;
            sectorIndex ++)
    {
        nwCellularAbstractBsInfo->bsSectorInfo[sectorIndex-1].sectorId =
            sectorIndex;

    #ifdef CHANNEL_ALLOCATION
        IO_ReadStringInstance(
            node->nodeId,
            ANY_ADDRESS,
            nodeInput,
            "ABSTRACT-CELLULAR-BS-SECTOR",
            sectorIndex,
            FALSE,
            &retVal,
            buf);

        if (retVal == FALSE)
        {
            sprintf(errorString,
                "WARNING: Node [%d] sector %d Could not"
                " find its ABSTRACT-CELLULAR-BS-SECTOR\n",
                node->nodeId,sectorIndex);
            ERROR_ReportError(errorString);
        }
        else
        {
            int channelIndexStart;
            int channelIndexEnd;
            int i;
            int j;

            if (DEBUG_GENERAL)
            {
                printf("node %d the channel range string is %s\n",
                    node->nodeId,buf);
                fflush(stdout);
            }

            CellularAbstractParseChannelRange(
                buf,
                &channelIndexStart,
                &channelIndexEnd);

            if (DEBUG_GENERAL)
            {
                printf(
                    "node %d sector %d the channel"
                    "range string is %d to %d\n",
                    node->nodeId,
                    sectorIndex,
                    channelIndexStart,
                    channelIndexEnd);
                fflush(stdout);
            }

            nwCellularAbstractBsInfo->
                bsSectorInfo[sectorIndex-1].numChannelAssigned =
                channelIndexEnd-channelIndexStart + 1;

            if (nwCellularAbstractBsInfo->numChannelAssigned <= 0)
            {
                sprintf(errorString,
                    "WARNING: Node [%d] sector %d INVALID channel range\n",
                    node->nodeId,sectorIndex);
                ERROR_ReportError(errorString);
            }

            for (i = 0; i < CELLULAR_ABSTRACT_MAX_CHANNEL_PER_SECTOR;i ++)
            {
                nwCellularAbstractBsInfo->
                    bsSectorInfo[sectorIndex-1].channelIndex[i] =
                        CELLULAR_ABSTRACT_INVALID_CHANNEL_ID;
            }//initialize all the channel in this sector

            j = channelIndexStart;
            for (i = 0;
                i < nwCellularAbstractBsInfo->
                    bsSectorInfo[sectorIndex-1].numChannelAssigned;
                i ++)
            {
                nwCellularAbstractBsInfo->
                    bsSectorInfo[sectorIndex-1].channelIndex[i] = j;

                nwCellularAbstractBsInfo->
                    bsSectorInfo[sectorIndex-1].numChannelInUse = 0;
                j ++;
                if (DEBUG_GENERAL)
                {
                    printf(
                        "node %d: BS sector %d is assined with channel %d\n",
                        node->nodeId,sectorIndex,
                        nwCellularAbstractBsInfo->
                            bsSectorInfo[sectorIndex-1].channelIndex[i]);
                    fflush(stdout);
                }
            }
        }
    #endif /*CHANNEL_ALLOCATION*/
    }

    //in case of bandwidth
    double bandwidthAllocatedToCell;
    bandwidthAllocatedToCell = 0;
    for (sectorIndex = 0;
        sectorIndex < nwCellularAbstractBsInfo->numSectorInCell;
        sectorIndex++)
    {
        double bandwidthAllocated;
        IO_ReadDoubleInstance(
            node->nodeId,
            ANY_ADDRESS,
            nodeInput,
            "ABSTRACT-CELLULAR-BS-SECTOR-BANDWIDTH",
            sectorIndex,
            TRUE,
            &retVal,
            &bandwidthAllocated);

        if (retVal == FALSE)
        {
            sprintf(errorString,
                "WARNING: Node [%d] sector %d Could not find its "
                "ABSTRACT-CELLULAR-BS-SECTOR-BANDWIDTH."
                " Set default 2048Kbps\n",
                node->nodeId,sectorIndex);
            ERROR_ReportWarning(errorString);
            // set default value
            nwCellularAbstractBsInfo->
                bsSectorInfo[sectorIndex].sectorBandwidthAllocated =
                    CELLULAR_ABSTRACT_DEFAULT_CHANNEL_BANDWIDTH;

            nwCellularAbstractBsInfo->
                bsSectorInfo[sectorIndex].bandwidthInUse = 0;

            bandwidthAllocatedToCell =
                bandwidthAllocatedToCell +
                CELLULAR_ABSTRACT_DEFAULT_CHANNEL_BANDWIDTH;
        }
        else
        {
            nwCellularAbstractBsInfo->
                bsSectorInfo[sectorIndex].sectorBandwidthAllocated =
                    bandwidthAllocated;

            nwCellularAbstractBsInfo->
                bsSectorInfo[sectorIndex].bandwidthInUse = 0;

            bandwidthAllocatedToCell =
                bandwidthAllocatedToCell + bandwidthAllocated;

            if (DEBUG_GENERAL)
            {
                printf(
                    "node %d:Allocate bandwidth %f\n",
                    node->nodeId,
                    nwCellularAbstractBsInfo->
                    bsSectorInfo[sectorIndex].sectorBandwidthAllocated);
                fflush(stdout);
            }
        }
    }

    nwCellularAbstractBsInfo->bandwidthAllocated =
        bandwidthAllocatedToCell;

    nwCellularAbstractBsInfo->bandwidthInUse = 0;
    nwCellularAbstractBsInfo->numAdmissionRequest = 0;

    //service supported
    IO_ReadString(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-ABSTRACT-BS-SERVICE",
        &retVal,
        buf);

    if (retVal == FALSE)
    {
        sprintf(errorString,
                "Node [%d] Could not find its"
                "CELLULAR-ABSTRACT-BS-SERVICE "
                "Set to default DATA and VOICE\n",
                node->nodeId);
        ERROR_ReportWarning(errorString);
        // set default
        nwCellularAbstractBsInfo->
                    bsServiceSupport[CELLULAR_ABSTRACT_VOICE] =
                        TRUE;
        nwCellularAbstractBsInfo->
                    bsServiceSupport[CELLULAR_ABSTRACT_DATA] =
                        TRUE;
    }
    else
    {
        int i;
        for (i = 0; i < CELLULAR_ABSTRACT_MAX_SERVICE_TYPE_PER_BS; i ++)
        {
            nwCellularAbstractBsInfo->bsServiceSupport[i] = FALSE;
        }
        // For IO_GetDelimitedToken
        char* next;
        char* token;
        char* p;
        char serviceString[MAX_STRING_LENGTH];
        const char* delims = "{,} \n";
        char iotoken[MAX_STRING_LENGTH];

        strcpy(serviceString, buf);
        p = serviceString;
        p = strchr(p, '{');

        if (p == NULL)
        {
            char errorBuf[MAX_STRING_LENGTH];
            sprintf(errorBuf, "Could not find '{' character:\n in %s\n",
                               serviceString);
            ERROR_ReportWarning(errorBuf);
            // set default
            nwCellularAbstractBsInfo->
                        bsServiceSupport[CELLULAR_ABSTRACT_VOICE] =
                            TRUE;
            nwCellularAbstractBsInfo->
                        bsServiceSupport[CELLULAR_ABSTRACT_DATA] =
                            TRUE;
        }
        else
        {
            token = IO_GetDelimitedToken(iotoken, p, delims, &next);

            if (!token)
            {
                char errorBuf[MAX_STRING_LENGTH];
                sprintf(errorBuf, "Can't find service list, e.g. "
                    "{ DATA, VOICE }:in \n  %s\n",serviceString);
                ERROR_ReportWarning(errorBuf);
                // set default
                nwCellularAbstractBsInfo->
                            bsServiceSupport[CELLULAR_ABSTRACT_VOICE] =
                                TRUE;
                nwCellularAbstractBsInfo->
                            bsServiceSupport[CELLULAR_ABSTRACT_DATA] =
                                TRUE;

            }
            else
            {
                while (token)
                {
                    if (strcmp(token,"VOICE") == 0)
                    {
                        nwCellularAbstractBsInfo->
                            bsServiceSupport[CELLULAR_ABSTRACT_VOICE] =
                                TRUE;

                        if (DEBUG_GENERAL)
                        {
                            printf("node %d: BS support %s\n",
                                node->nodeId, token);
                            fflush(stdout);
                        }
                    }
                    else if (strcmp(token,"DATA") == 0)
                    {
                        nwCellularAbstractBsInfo->
                            bsServiceSupport[CELLULAR_ABSTRACT_DATA] =
                                TRUE;
                        if (DEBUG_GENERAL)
                        {
                            printf("node %d: BS support %s\n",
                                node->nodeId, token);
                            fflush(stdout);
                        }
                    }
                    else
                    {
                        char errorBuf[MAX_STRING_LENGTH];
                        sprintf(errorBuf, "Can't support %s, "
                            "only support service list, e.g. "
                            "{ VOICE, VIDEO-PHONE, ... }\n",token);
                        ERROR_Assert(FALSE, errorBuf);
                    }
                    token = IO_GetDelimitedToken(
                                iotoken, next,delims, &next);
                }
            }
        }
    }
    //CELLULAR-ABSTRACT-BS-ADMISSON-CONTROL-POLICY
    IO_ReadString(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-ABSTRACT-BS-ADMISSION-CONTROL-POLICY",
        &retVal,
        buf);

    if (retVal == FALSE)
    {
        nwCellularAbstractBsInfo->callAdmissionPolicy =
            CELLULAR_ABSTRACT_CALL_ADMISSION_CONTROL_NONE;

        if (DEBUG_GENERAL)
        {
            printf(
                "node %d: BS call admission control policy"
                "is NONE by default \n",
                node->nodeId);
            fflush(stdout);
        }
    }
    else if (strcmp(buf, "NONE") == 0)
    {
        nwCellularAbstractBsInfo->callAdmissionPolicy =
            CELLULAR_ABSTRACT_CALL_ADMISSION_CONTROL_NONE;
        if (DEBUG_GENERAL)
        {
            printf(
                "node %d: BS call admission control policy"
                "is NONE\n",
                node->nodeId);
            fflush(stdout);
        }
    }
    else if (strcmp(buf, "THRESHOLD-BASED") == 0)
    {
        nwCellularAbstractBsInfo->callAdmissionPolicy =
            CELLULAR_ABSTRACT_CALL_ADMISSION_CONTROL_THRESHOLD_BASED;

        IO_ReadInt(
            node->nodeId,
            ANY_ADDRESS,
            nodeInput,
            "THRESHOLD-BASED-CAC-PARAM-N",
            &retVal,
            &readVal);

        if (retVal == FALSE)
        {
            sprintf(errorString,
                "Node [%d] Could not find its"
                "THRESHOLD-BASED-CAC-PARAM-N "
                "set default value \n",
                node->nodeId);
            ERROR_ReportWarning(errorString);
            nwCellularAbstractBsInfo->cacThresholdParamN =
                CELLULAR_ABSTRACT_DEFAULT_THRESHOLD_BASED_CAC_PARAM_N;
        }
        else
        {
            nwCellularAbstractBsInfo->cacThresholdParamN = readVal;
        }

        IO_ReadInt(
            node->nodeId,
            ANY_ADDRESS,
            nodeInput,
            "THRESHOLD-BASED-CAC-PARAM-M",
            &retVal,
            &readVal);

        if (retVal == FALSE)
        {
            sprintf(errorString,
                "Node [%d] Could not find its"
                "THRESHOLD-BASED-CAC-PARAM-M\n",
                node->nodeId);
            ERROR_ReportWarning(errorString);
            nwCellularAbstractBsInfo->cacThresholdParamM =
                CELLULAR_ABSTRACT_DEFAULT_THRESHOLD_BASED_CAC_PARAM_M;
        }
        else
        {
            nwCellularAbstractBsInfo->cacThresholdParamM = readVal;
        }

        ERROR_Assert( nwCellularAbstractBsInfo->cacThresholdParamN >
            nwCellularAbstractBsInfo->cacThresholdParamM,
            "Param N should be great than M");


        if (DEBUG_GENERAL)
        {
            printf(
                "node %d: BS call admission control policy"
                "is THRESHOLD-BASED\n",
                node->nodeId);
            fflush(stdout);
        }
    }
    else
    {
        sprintf(errorString,
                "Node [%d] CELLULAR-ABSTRACT-BS-ADMISSON-CONTROL-POLICY"
                "only support NONE or THREHSOLD-BASED\n",
                node->nodeId);
        ERROR_ReportError(errorString);
    }

    //CELLULAR-ABSTRACT-BS-CONGESTION-CONTROL-POLICY
    IO_ReadString(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-ABSTRACT-BS-CONGESTION-CONTROL-POLICY",
        &retVal,
        buf);

    if (retVal == FALSE)
    {
        nwCellularAbstractBsInfo->congestionControlPolicy =
            CELLULAR_ABSTRACT_CONGESTION_CONTROL_NONE;
        if (DEBUG_GENERAL)
        {

            printf(
                "node %d: BS congestion control policy"
                "is NONE by default\n",node->nodeId);
            fflush(stdout);
        }
    }
    else if (strcmp(buf, "NONE") == 0)
    {
        nwCellularAbstractBsInfo->congestionControlPolicy =
            CELLULAR_ABSTRACT_CONGESTION_CONTROL_NONE;
        if (DEBUG_GENERAL)
        {

            printf(
                "node %d: BS congestion control policy"
                "is NONE\n",node->nodeId);
            fflush(stdout);
        }
    }
    else if (strcmp(buf, "ROUND-ROBIN") == 0)
    {
        nwCellularAbstractBsInfo->congestionControlPolicy =
            CELLULAR_ABSTRACT_CONGESTION_CONTROL_ROUND_ROBIN;

        //control duration
        IO_ReadTime(
            node->nodeId,
            ANY_ADDRESS,
            nodeInput,
            "ROUND-ROBIN-CONGESTION-CONTROL-DURATION",
            &retVal,
            &readTime);

        if (retVal == FALSE)
        {
            sprintf(errorString,
                "Node [%d] Could not find its "
                "ROUND-ROBIN-CONGESTION-CONTROL-DURATION\n",
                node->nodeId);
            ERROR_ReportWarning(errorString);
            nwCellularAbstractBsInfo->oneControlDuration =
                CELLULAR_ABSTRACT_DEFAULT_ROUND_ROBIN_CONGESTION_CONTROL_DURATION;
        }
        else
        {
            nwCellularAbstractBsInfo->oneControlDuration = readTime;
        }

        //number of access class
        IO_ReadInt(
            node->nodeId,
            ANY_ADDRESS,
            nodeInput,
            "ROUND-ROBIN-CONGESTION-CONTROL-ACCESS-CLASS",
            &retVal,
            &readVal);

        if (retVal == FALSE)
        {
            sprintf(errorString,
                "Node [%d] Could not find its"
                "ROUND-ROBIN-CONGESTION-CONTROL-ACCESS-CLASS\n",
                node->nodeId);
            ERROR_ReportWarning(errorString);
            nwCellularAbstractBsInfo->numAccessClass =
                CELLULAR_ABSTRACT_DEFAULT_ROUND_ROBIN_CONGESTION_CONTROL_ACCESS_CLASS;
        }
        else
        {
            nwCellularAbstractBsInfo->numAccessClass = (short)readVal;
        }

        //refrain probability
        IO_ReadDouble(
            node->nodeId,
            ANY_ADDRESS,
            nodeInput,
            "ROUND-ROBIN-CONGESTION-CONTROL-REFRAIN-PROBABILITY",
            &retVal,
            &readDouble);

        if (retVal == FALSE)
        {
            sprintf(errorString,
                "Node [%d] Could not find its "
                "ROUND-ROBIN-CONGESTION-CONTROL-REFRAIN-PROBABILITY\n",
                node->nodeId);
            ERROR_ReportWarning(errorString);
            nwCellularAbstractBsInfo->refrainProb =
                CELLULAR_ABSTRACT_DEFAULT_ROUND_ROBIN_CONGESTION_CONTROL_REFRAIN_PROBABILITY;
        }
        else
        {
            if (readDouble == 0.5 ||
                readDouble == 0.75 ||
                readDouble == 0.25)
            {
                nwCellularAbstractBsInfo->refrainProb = readDouble;
            }
            else
            {

                sprintf(errorString,
                    "Node [%d]:"
                    "ROUND-ROBIN-CONGESTION-CONTROL-REFRAIN-PROBABILITY"
                    "should be 0.25,  0.5 or 0.75\n",
                    node->nodeId);
                ERROR_ReportError(errorString);
            }
        }

        if (DEBUG_GENERAL)
        {

            printf(
                "node %d: BS congestion control policy"
                "is ROUND-ROBIN\n",
                node->nodeId);
            fflush(stdout);
        }
    }
    else if (strcmp(buf, "PROBABILISTIC") == 0)
    {
        nwCellularAbstractBsInfo->congestionControlPolicy =
            CELLULAR_ABSTRACT_CONGESTION_CONTROL_PROBABILISTIC_POLICY;

        //refrain probability
        IO_ReadDouble(
            node->nodeId,
            ANY_ADDRESS,
            nodeInput,
            "PROBABILISTIC-CONGESTION-CONTROL-REFRAIN-PROBABILITY",
            &retVal,
            &readDouble);

        if (retVal == FALSE)
        {
            sprintf(errorString,
                "Node [%d] Could not find its "
                "PROBABILISTIC-CONGESTION-CONTROL-REFRAIN-PROBABILITY\n",
                node->nodeId);
            ERROR_ReportError(errorString);
        }
        else
        {
            //TODO
        }
        if (DEBUG_GENERAL)
        {

            printf(
                "node %d: BS congestion control policy"
                "is PROBABILISTIC-BASED\n",node->nodeId);
            fflush(stdout);
        }
    }
    else
    {
        sprintf(errorString,
                "Node [%d] CELLULAR-ABSTRACT-BS-CONGESTION-CONTROL-POLICY"
                "only support NONE, ROUND-ROBIN or PROBABILISTIC-BASED\n",
                node->nodeId);
        ERROR_ReportError(errorString);
    }

    //control information interval
    IO_ReadTime(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-ABSTRACT-BS-CONTROL-INFORMATION-INTERVAL",
        &retVal,
        &readTime);
    if (retVal == FALSE)
    {
        sprintf(errorString,
            "Node [%d] Could not find its "
            "CELLULAR-ABSTRACT-BS-CONTROL-INFORMATION-INTERVAL"
            "set default value \n",
            node->nodeId);
        ERROR_ReportWarning(errorString);
        // set default
        nwCellularAbstractBsInfo->systemInfoBroadcastInterval =
            CELLULAR_ABSTRACT_DEFAULT_BS_CONTROL_INFORMATION_INTERVAL;
    }
    else
    {
        nwCellularAbstractBsInfo->systemInfoBroadcastInterval = readTime;
        if (DEBUG_GENERAL)
        {
            char clkStr[MAX_STRING_LENGTH];
            ctoa(nwCellularAbstractBsInfo->systemInfoBroadcastInterval,
                 clkStr);
            printf(
                "node %d: control inteval is BS is %s NS\n",
                node->nodeId,
                clkStr);
            fflush(stdout);
        }
    }

    //tx power
    IO_ReadDouble(
        node,
        node->nodeId,
        MAPPING_GetInterfaceIndexFromInterfaceAddress(
            node,
            MAPPING_GetDefaultInterfaceAddressFromNodeId(
                node,
                node->nodeId)),
        nodeInput,
        "PHY-ABSTRACT-TX-POWER",
        &retVal,
        &readDouble);

    if (retVal == FALSE)
    {
        sprintf(errorString,
            "Node [%d] Could not find its "
            "PHY-ABSTRACT-TX-POWER"
            " set default value 30db\n",
            node->nodeId);
        ERROR_ReportWarning(errorString);
        nwCellularAbstractBsInfo->bsTxPower =
            CELLULAR_ABSTRACT_DEFAULT_BS_CONTROL_TX_POWER;
    }
    else
    {
        nwCellularAbstractBsInfo->bsTxPower = readDouble;
        if (DEBUG_GENERAL)
            printf("node %d: BS tx power is is %f dBm \n", node->nodeId,
                nwCellularAbstractBsInfo->bsTxPower);
        fflush(stdout);
    }

    //channel requests transmission retry
    //TODO: read cofigure file to see user supply some values
    nwCellularAbstractBsInfo->txInteger = CELLULAR_TX_INTEGER;
    nwCellularAbstractBsInfo->maxReTrans = CELLULAR_MAX_RETRANS;

    //appInfo structure
    int i;
    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS; i++)
    {
        nwCellularAbstractBsInfo->bsAppInfo[i].inUse = FALSE;
    }

    //page request Info
    nwCellularAbstractBsInfo->pageRequestId = 0;
    for (i = 0;i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS; i ++)
    {
        nwCellularAbstractBsInfo->bsPageRequestInfo[i].inUse = FALSE;
    }

    //channel assignment Info
    nwCellularAbstractBsInfo->assignmentId = 0;
    for (i = 0;i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_BS; i ++)
    {
        nwCellularAbstractBsInfo->bsChannelAssignmentInfo[i].inUse = FALSE;
    }

    //handover margin
    if (DEBUG_SAMPLE)
    {
        CellularAbstractGenericTimerInfo timerInfoSmapler;
        timerInfoSmapler.timerType = MSG_NETWORK_CELLULAR_BW_SAMPLE_Timer;
        CellularAbstractLayer3StartTimer(
            node,
            CELLULAR_RESOURCE_USAGE_SAMPLE_INTERVAL,
            &timerInfoSmapler,
            sizeof(CellularAbstractGenericTimerInfo));
    }

    //statistics
    CellularAbstractLayer3InitStats(node, nodeInput);

    //system information

    if (nwCellularAbstractData->optLevel !=
            CELLULAR_ABSTRACT_OPTIMIZATION_LOW)
    {
        return;
    }
    //need further instance the message
    nwCellularAbstractBsInfo->systemInfoType2 = NULL;
    CellularAbstractBsSystemInfo *sysInfoMsg;
    Message *sysInfoTimer;
    CellularAbstractBsSystemTimerInfo *timerInfo;

    //build the system info braodcast pakcet wihch is
    //embed in a msg MSG_MAC_CELLULAR_FromNetwork).
    nwCellularAbstractBsInfo->systemInfoType2
        = MESSAGE_Alloc(
            node,
            MAC_LAYER,
            MAC_PROTOCOL_CELLULAR,
            MSG_MAC_CELLULAR_FromNetwork);

    MESSAGE_PacketAlloc(
        node,
        nwCellularAbstractBsInfo->systemInfoType2,
        sizeof(CellularAbstractBsSystemInfo),
        TRACE_CELLULAR);

    sysInfoMsg = (CellularAbstractBsSystemInfo*)
                    MESSAGE_ReturnPacket(
                        nwCellularAbstractBsInfo->systemInfoType2);

    memset(sysInfoMsg, 0, sizeof(CellularAbstractBsSystemInfo));

    sysInfoMsg->bsNodeId = nwCellularAbstractBsInfo->bsNodeId;

    sysInfoMsg->bsNodeAddress =
        nwCellularAbstractBsInfo->associatedScNodeAddress;

    sysInfoMsg->lac = nwCellularAbstractBsInfo->lac;
    sysInfoMsg->cellId = nwCellularAbstractBsInfo->cellId;
    sysInfoMsg->txInteger = nwCellularAbstractBsInfo->txInteger;
    sysInfoMsg->maxReTrans = nwCellularAbstractBsInfo->maxReTrans;

    sysInfoMsg->controlDLChannelIndex =
        nwCellularAbstractBsInfo->controlDLChannelIndex;
    sysInfoMsg->controlULChannelIndex =
        nwCellularAbstractBsInfo->controlULChannelIndex;

    sysInfoMsg->numSector = nwCellularAbstractBsInfo->numSectorInCell;

    sysInfoMsg->bsLocationC1 =
        nwCellularAbstractBsInfo->bsLocation.common.c1;
    sysInfoMsg->bsLocationC2 =
        nwCellularAbstractBsInfo->bsLocation.common.c2;
    sysInfoMsg->bsLocationC3 =
        nwCellularAbstractBsInfo->bsLocation.common.c3;


    sysInfoMsg->congestionControlPolicy =
        nwCellularAbstractBsInfo->congestionControlPolicy;
    sysInfoMsg->oneControlDuration =
        nwCellularAbstractBsInfo->oneControlDuration;
    sysInfoMsg->numAccessClass = nwCellularAbstractBsInfo->numAccessClass;
    sysInfoMsg->refrainProb = nwCellularAbstractBsInfo->refrainProb;

    if (DEBUG_GENERAL)
    {
        printf(
            "node%d, the sys info BSid %d, num sector %d\n",
            node->nodeId,
            sysInfoMsg->bsNodeId,
            sysInfoMsg->numSector);
        fflush(stdout);
    }

    //schedule a system info timer to send the packet;
    sysInfoTimer = MESSAGE_Alloc(node,
                        NETWORK_LAYER,
                        NETWORK_PROTOCOL_CELLULAR,
                        MSG_NETWORK_CELLULAR_TimerExpired);

    MESSAGE_InfoAlloc(
        node,
        sysInfoTimer,
        sizeof(CellularAbstractBsSystemTimerInfo));

    timerInfo =
        (CellularAbstractBsSystemTimerInfo *)
        MESSAGE_ReturnInfo(sysInfoTimer);

    timerInfo->timerType = MSG_NETWORK_CELLULAR_SystemInfoTimer;
    timerInfo->transactionId = 0;

    //the first system info broadcast is made immediately
    //with a random delay from 0 to 10NS
    MESSAGE_Send(
        node,
        sysInfoTimer,
        (clocktype)(RANDOM_erand(nwCellularData->randSeed) *
         CELLULAR_ABSTRACT_DEFAULT_BS_SYSTEM_INFORMATION_DELAY));


    if (DEBUG_GENERAL)
    {
        printf("node %d:schedule a system info timer\n",node->nodeId);
        fflush(stdout);
    }

}//CellularAbstractLayer3BsInit
//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3ScInit
// LAYER      :: Layer3
// PURPOSE    :: Initialize SC's Cellular Layer protocol
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + nodeInput        : const NodeInput*  : Pointer to node input.
// RETURN     :: void : NULL
// **/
//*************************************************************************
void CellularAbstractLayer3ScInit(Node *node, const NodeInput *nodeInput)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;
    char buf[MAX_STRING_LENGTH];
    char errorString[MAX_STRING_LENGTH];
    BOOL retVal;
    int readVal;
    int bsIndex;
    int vlrIndex;
    int i;

    if (DEBUG_GENERAL)
    {
        printf("node %d: in SC inti process\n",node->nodeId);
        fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    nwCellularAbstractData->scLayer3Info =
        (CellularAbstractLayer3ScInfo *)
        MEM_malloc(sizeof(CellularAbstractLayer3ScInfo));

    //thrid hierarchy
    nwCellularAbstractScInfo = nwCellularAbstractData->scLayer3Info;

    memset(nwCellularAbstractScInfo,
           0,
          sizeof(CellularAbstractLayer3ScInfo));

    nwCellularAbstractScInfo->scNodeId = node->nodeId;
    nwCellularAbstractScInfo->scNodeAddress =
        MAPPING_GetDefaultInterfaceAddressFromNodeId(node, node->nodeId);

    //sc controled bs
    nwCellularAbstractScInfo->numScControlBs =  0;
    for (bsIndex = 0; bsIndex < CELLULAR_ABSTRACT_MAX_BS_PER_SC; bsIndex ++)
    {
        nwCellularAbstractScInfo->scControlBsInfo[bsIndex].bsCellId =
            CELLULAR_ABSTRACT_INVALID_BS_ID;
    }

    //read the file and update the structure scControlBsInfo
    IO_ReadString(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-SC-CONTROL-BS",
        &retVal,
        buf);

    if (retVal == FALSE)
    {
        sprintf(errorString,
                "Node [%d] Could not find its CELLULAR-SC-CONTROL-BS\n",
                node->nodeId);
        ERROR_ReportError(errorString);
    }
    else
    {
        // For IO_GetDelimitedToken
        char* next;
        char* token;
        char* p;
        char csControlBsString[MAX_STRING_LENGTH];
        const char* delims = "{,} \n";
        char iotoken[MAX_STRING_LENGTH];


        strcpy(csControlBsString, buf);
        p = csControlBsString;
        p = strchr(p, '{');

        if (p == NULL)
        {
            char errorBuf[MAX_STRING_LENGTH];
            sprintf(
                errorBuf, "Could not find '{' character:\n in %s\n",
                csControlBsString);
            ERROR_Assert(FALSE, errorBuf);
        }
        else
        {
            token = IO_GetDelimitedToken(iotoken, p, delims, &next);

            if (!token)
            {
                char errorBuf[MAX_STRING_LENGTH];
                sprintf(errorBuf, "Can't find bs list, e.g. "
                    "{ 1, 2, ... }:in \n  %s\n",csControlBsString);
                ERROR_Assert(FALSE, errorBuf);
            }
            else
            {
                while (token)
                {
                    NodeAddress bsNodeId;
                    bsNodeId = (NodeAddress)atoi(token);

                    // judge if the bsBodeId's node type
                    BOOL retValBs;
                    char bufBs[MAX_STRING_LENGTH];

                    IO_ReadString(
                        bsNodeId,
                        ANY_ADDRESS,
                        nodeInput,
                        "CELLULAR-NODE-TYPE",
                        &retValBs,
                        bufBs);
                    if (retValBs == FALSE ||
                        strcmp(bufBs, "CELLULAR-BS") != 0)
                    {
                        sprintf(errorString,
                            "Node [%d]: the claimed controled "
                            "BS %d type is not a BS\n",
                            node->nodeId, bsNodeId);
                        ERROR_ReportError(errorString);
                    }

                    //update the info structure
                    nwCellularAbstractScInfo->
                        scControlBsInfo[nwCellularAbstractScInfo->
                        numScControlBs].bsNodeId = bsNodeId;

                    nwCellularAbstractScInfo->
                        scControlBsInfo[nwCellularAbstractScInfo->
                        numScControlBs].bsNodeAddress =
                            MAPPING_GetDefaultInterfaceAddressFromNodeId(
                                node,
                                bsNodeId);

                    //get the cellid of the bs
                    IO_ReadInt(
                        bsNodeId,
                        ANY_ADDRESS,
                        nodeInput,
                        "CELLULAR-BS-CELL-ID",
                        &retVal,
                        &readVal);
                    if (retVal == FALSE)
                    {
                        char errorBuf[MAX_STRING_LENGTH];
                        sprintf(
                            errorBuf,
                            "Node [%d] Could not find controled BS's %d"
                            "CELLULAR-BS-CELL-ID, set as bs node Id\n",
                            node->nodeId, bsNodeId);
                        ERROR_ReportWarning(errorBuf);
                        nwCellularAbstractScInfo->
                            scControlBsInfo[nwCellularAbstractScInfo->
                            numScControlBs].bsCellId = bsNodeId;
                    }
                    else
                    {
                        nwCellularAbstractScInfo->
                            scControlBsInfo[nwCellularAbstractScInfo->
                            numScControlBs].bsCellId = readVal;

                        if (DEBUG_GENERAL)
                        {
                            printf(
                                "node %d: the #%d controled BS is"
                                "%d's with Cell Id is %d\n",
                                node->nodeId,
                                nwCellularAbstractScInfo->numScControlBs,

                                nwCellularAbstractScInfo->
                                scControlBsInfo[nwCellularAbstractScInfo->
                                                    numScControlBs].bsNodeId,
                                nwCellularAbstractScInfo->
                                scControlBsInfo[nwCellularAbstractScInfo->
                                                numScControlBs].bsCellId);
                            fflush(stdout);
                        }
                    }
                    //get the lac of the BS
                    IO_ReadInt(
                        bsNodeId,
                        ANY_ADDRESS,
                        nodeInput,
                        "CELLULAR-BS-LAC",
                        &retVal,
                        &readVal);
                    if (retVal == FALSE)
                    {
                        char errorBuf[MAX_STRING_LENGTH];
                        sprintf(errorBuf,
                        "Node [%d] Could not find controled BS's %d"
                        "CELLULAR-BS-LAC, set as default Bs node Id\n",
                        node->nodeId, bsNodeId);
                        ERROR_ReportWarning(errorBuf);
                        nwCellularAbstractScInfo->
                            scControlBsInfo[nwCellularAbstractScInfo->
                            numScControlBs].lac = bsNodeId;
                    }
                    else
                    {
                        nwCellularAbstractScInfo->
                            scControlBsInfo[nwCellularAbstractScInfo->
                            numScControlBs].lac = readVal;

                        if (DEBUG_GENERAL)
                        {
                            printf(
                                "node %d: the #%d controled BS"
                                "is %d's with LAC is %d\n",
                                node->nodeId,
                                nwCellularAbstractScInfo->numScControlBs,
                                nwCellularAbstractScInfo->
                                    scControlBsInfo[nwCellularAbstractScInfo->
                                                    numScControlBs].bsNodeId,
                                nwCellularAbstractScInfo->
                                scControlBsInfo[nwCellularAbstractScInfo->
                                                        numScControlBs].lac);
                            fflush(stdout);
                        }
                    }
                    nwCellularAbstractScInfo->numScControlBs ++;
                    token = IO_GetDelimitedToken(
                        iotoken, next,delims, &next);
                }

                // determine if any BS has the same Cell Id and LAC conbination
                int bsIndex1, bsIndex2;
                BOOL  ideticalLacCellId = FALSE;
                for (bsIndex1 = 0;
                     bsIndex1 < nwCellularAbstractScInfo->numScControlBs &&
                     !ideticalLacCellId;
                     bsIndex1 ++)
                 {
                    for (bsIndex2 = bsIndex1 + 1;
                         bsIndex2 < nwCellularAbstractScInfo->numScControlBs &&
                         !ideticalLacCellId;
                         bsIndex2 ++)
                     {
                         if ((nwCellularAbstractScInfo->
                                    scControlBsInfo[bsIndex1].bsCellId ==
                             nwCellularAbstractScInfo->
                                    scControlBsInfo[bsIndex2].bsCellId) &&
                             (nwCellularAbstractScInfo->
                                    scControlBsInfo[bsIndex1].lac ==
                             nwCellularAbstractScInfo->
                                    scControlBsInfo[bsIndex2].lac) )
                        {
                            ideticalLacCellId = TRUE;
                        }
                     }
                 }

                if (ideticalLacCellId)
                {
                    sprintf(errorString,
                            "Node [%d]: 2 controled BSs have the same"
                            " CellId&LAC combination\n",
                            node->nodeId);
                    ERROR_ReportError(errorString);
                }
            }
        }
    }

    //VLR
    for (vlrIndex = 0;
        vlrIndex < CELLULAR_ABSTRACT_MAX_MS_PER_SC; vlrIndex ++);
    {
        nwCellularAbstractScInfo->scVlr[vlrIndex].inUse = FALSE;
    }
    //Auc
    //gateway
    IO_ReadInt(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-SC-CONNECT-GATEWAY",
        &retVal,
        &readVal);
    if (retVal == FALSE)
    {
        sprintf(errorString,
            "Node [%d] Could not find its CELLULAR-SC-CONNECT-GATEWAY\n",
            node->nodeId);
        ERROR_ReportError(errorString);
    }
    else
    {
        // judge if the readVal's node type
        BOOL retValGateway;
        char bufGateway[MAX_STRING_LENGTH];

        IO_ReadString(
            readVal,
            ANY_ADDRESS,
            nodeInput,
            "CELLULAR-NODE-TYPE",
            &retValGateway,
            bufGateway);
        if (retValGateway == FALSE ||
            strcmp(bufGateway, "CELLULAR-GATEWAY") != 0)
        {
            sprintf(errorString,
                "Node [%d]: the claimed connected "
                "Gateway %d type is not a Gateway\n",
                node->nodeId, readVal);
            ERROR_ReportError(errorString);
        }

        nwCellularAbstractScInfo->gatewayNodeId = readVal;

        nwCellularAbstractScInfo->gatewayNodeAddress =
            MAPPING_GetDefaultInterfaceAddressFromNodeId(
                node, nwCellularAbstractScInfo->gatewayNodeId);

        if (DEBUG_GENERAL)
        {
            printf("node %d: SC connect to gateway is %d\n",
                node->nodeId,nwCellularAbstractScInfo->gatewayNodeId);
            fflush(stdout);
        }
    }
    //HLR
    //the hlr node could be a different node
    nwCellularAbstractScInfo->associatedHLRNodeId =
        nwCellularAbstractScInfo->gatewayNodeId;

    //appInfoatSc
    //appInfo structure
    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_SC; i ++)
    {
        nwCellularAbstractScInfo->scAppInfo[i].inUse = FALSE;
    }
    for (i = 0; i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_SC; i ++)
    {
        nwCellularAbstractScInfo->scpagingInfo[i].inUse = FALSE;
    }

    //statistics
    CellularAbstractLayer3InitStats(node, nodeInput);

}//CellularAbstractLayer3ScInit
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractGatewayGetLacList
// LAYER      :: Layer3
// PURPOSE    :: Gateway get the lac of the linked SC.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + nodeInput        : const NodeInput * : Point to the input
// + scIndex          : int               : SC's index
// + scNodeId         : NodeAddress       : SC's address
// RETURN     :: void : NULL
// **/
//************************************************************************
static
void CellularAbstractGatewayGetLacList(Node *node,
                                       const NodeInput *nodeInput,
                                       int scIndex,
                                       NodeAddress scNodeId)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;
    char buf[MAX_STRING_LENGTH];
    char errorString[MAX_STRING_LENGTH];
    BOOL retVal;

    int numLac;

    if (DEBUG_GENERAL)
    {
            printf(
                "node %d: in GATEWAY inti process get LAC list\n",
                node->nodeId);
            fflush(stdout);
    }

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo =
        nwCellularAbstractData->gatewayLayer3Info;

    //read the SC list
    IO_ReadString(
        scNodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-SC-LAC-LIST",
        &retVal,
        buf);

    if (retVal == FALSE)
    {
        sprintf(errorString,
                "Node [%d] Could not find SC %d CELLULAR-SC-LAC-LIST\n",
                node->nodeId,scNodeId);
        ERROR_ReportError(errorString);
    }
    else
    {
        numLac=0;
        // For IO_GetDelimitedToken
        char* next;
        char* token;
        char* p;
        char scLacString[MAX_STRING_LENGTH];
        const char* delims = "{,} \n";
        char iotoken[MAX_STRING_LENGTH];
        int num;

        strcpy(scLacString, buf);
        p = scLacString;
        p = strchr(p, '{');

        if (p == NULL)
        {
            char errorBuf[MAX_STRING_LENGTH];
            sprintf(
                errorBuf,
                "Could not find '{' character:\n"
                "in the lac list %s\n",
                scLacString);
            ERROR_Assert(FALSE, errorBuf);
        }
        else
        {
            token = IO_GetDelimitedToken(iotoken, p, delims, &next);

            if (!token)
            {
                char errorBuf[MAX_STRING_LENGTH];
                sprintf(errorBuf, "Can't find sc lac list, e.g. "
                    "{ 1, 2, ... }:in \n  %s\n",scLacString);
                ERROR_Assert(FALSE, errorBuf);
            }
            else
            {
                while (token)
                {
                    num = atoi(token);

                    //read the LAC into to the sc lac varibale.
                    if (numLac >= CELLULAR_ABSTRACT_MAX_LAC_PER_SC)
                    {
                        char errorBuf[MAX_STRING_LENGTH];
                        sprintf(
                            errorBuf, "the SC only support %d LAC\n",
                            CELLULAR_ABSTRACT_MAX_LAC_PER_SC);
                        ERROR_Assert(FALSE, errorBuf);
                    }

                    nwCellularAbstractGatewayInfo->
                        gatewayConnectSc[scIndex].lac[numLac] = num;
                    numLac ++;
                    token = IO_GetDelimitedToken(iotoken, next,delims, &next);
                }
            }
        }
    }
}
//***********************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3GatewayInit
// LAYER      :: Layer3
// PURPOSE    :: Initialize Gateway's Cellular Layer protocol
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + nodeInput        : const NodeInput*  : Pointer to node input.
// RETURN     :: void : NULL
// **/
//***********************************************************************
void CellularAbstractLayer3GatewayInit(Node *node,
                                       const NodeInput *nodeInput)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;
    char buf[MAX_STRING_LENGTH];
    char errorString[MAX_STRING_LENGTH];
    BOOL retVal;
    int readVal;
    int hlrIndex;

    if (DEBUG_GENERAL)
    {
            printf("node %d: in GATEWAY inti process\n",node->nodeId);
            fflush(stdout);
    }
    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)node->
            networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    nwCellularAbstractData->gatewayLayer3Info =
        (CellularAbstractLayer3GatewayInfo *)
            MEM_malloc(sizeof(CellularAbstractLayer3GatewayInfo));

    //thrid hierarchy
    nwCellularAbstractGatewayInfo =
        nwCellularAbstractData->gatewayLayer3Info;

    memset(nwCellularAbstractGatewayInfo,
           0,
          sizeof(CellularAbstractLayer3GatewayInfo));

    nwCellularAbstractGatewayInfo->gatewayNodeId = node->nodeId;

    nwCellularAbstractGatewayInfo->gatewayNodeAddress=
        MAPPING_GetDefaultInterfaceAddressFromNodeId(node, node->nodeId);

    //conected gateway
    IO_ReadInt(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-GATEWAY-CONNECT-AGGREGATED-NODE",
        &retVal,
        &readVal);
    if (retVal == FALSE)
    {
        sprintf(errorString,
            "Node [%d] Could not find its "
            "CELLULAR-GATEWAY-CONNECT-AGGREGATED-NODE\n",
            node->nodeId);
        ERROR_ReportWarning(errorString);
    }
    else
    {
        // judge if the readVal's node type
        BOOL retValAN;
        char bufAN[MAX_STRING_LENGTH];

        IO_ReadString(
            readVal,
            ANY_ADDRESS,
            nodeInput,
            "CELLULAR-NODE-TYPE",
            &retValAN,
            bufAN);
        if (retValAN == FALSE ||
            strcmp(bufAN, "CELLULAR-AGGREGATED-NODE") != 0)
        {
            sprintf(errorString,
                "Node [%d]: the claimed connected "
                "Aggregated Node %d type is not a AN\n",
                node->nodeId, readVal);
            ERROR_ReportWarning(errorString);
        }

        nwCellularAbstractGatewayInfo->aggregatedNodeId = readVal;
        nwCellularAbstractGatewayInfo->aggregatedNodeAddress =
            MAPPING_GetDefaultInterfaceAddressFromNodeId(
                node,
                nwCellularAbstractGatewayInfo->aggregatedNodeId);

        if (DEBUG_GENERAL)
        {
            printf("node %d: aggregated node connect to gateway is %d\n",
                node->nodeId,nwCellularAbstractGatewayInfo->aggregatedNodeId);
            fflush(stdout);
        }
    }

    //SC connect to this gateway
    nwCellularAbstractGatewayInfo->numSc = 0;

    //read the SC list
    IO_ReadString(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-GATEWAY-CONNECT-SC",
        &retVal,
        buf);

    if (retVal == FALSE)
    {
        sprintf(
            errorString,
            "Node [%d] Could not find its CELLULAR-GATEWAY-CONNECT-SC\n",
            node->nodeId);
        ERROR_ReportError(errorString);
    }
    else
    {
        // For IO_GetDelimitedToken
        char* next;
        char* token;
        char* p;
        char gatewayConnectScString[MAX_STRING_LENGTH];
        const char* delims = "{,} \n";
        char iotoken[MAX_STRING_LENGTH];

        strcpy(gatewayConnectScString, buf);
        p = gatewayConnectScString;
        p = strchr(p, '{');

        if (p == NULL)
        {
            char errorBuf[MAX_STRING_LENGTH];
            sprintf(
                errorBuf, "Could not find '{' character:\n in %s\n",
                gatewayConnectScString);
            ERROR_Assert(FALSE, errorBuf);
        }
        else
        {
            token = IO_GetDelimitedToken(iotoken, p, delims, &next);

            if (!token)
            {
                char errorBuf[MAX_STRING_LENGTH];
                sprintf(errorBuf, "Can't find sc list, e.g. "
                    "{ 1, 2, ... }:in \n  %s\n",gatewayConnectScString);
                ERROR_Assert(FALSE, errorBuf);
            }
            else
            {
                while (token)
                {
                    NodeAddress scNodeId;
                    int i;
                    scNodeId =(NodeAddress)atoi(token);

                    // judge if the ScNodeId's node type
                    BOOL retValSc;
                    char bufSc[MAX_STRING_LENGTH];

                    IO_ReadString(
                        scNodeId,
                        ANY_ADDRESS,
                        nodeInput,
                        "CELLULAR-NODE-TYPE",
                        &retValSc,
                        bufSc);
                    if (retValSc == FALSE ||
                        strcmp(bufSc,
                               "CELLULAR-SC") != 0)
                    {
                        sprintf(errorString,
                            "Node [%d]: the claimed connected "
                            "SC %d type is not a SC\n",
                            node->nodeId, scNodeId);
                        ERROR_ReportError(errorString);
                    }

                    //update the info structure
                    nwCellularAbstractGatewayInfo->
                        gatewayConnectSc[nwCellularAbstractGatewayInfo->
                        numSc].scNodeId = scNodeId;

                    nwCellularAbstractGatewayInfo->
                        gatewayConnectSc[nwCellularAbstractGatewayInfo->
                            numSc].scNodeAddress =
                                MAPPING_GetDefaultInterfaceAddressFromNodeId(
                                    node,
                                    scNodeId);

                    for (i = 0; i < CELLULAR_ABSTRACT_MAX_LAC_PER_SC; i ++)
                        nwCellularAbstractGatewayInfo->
                            gatewayConnectSc[nwCellularAbstractGatewayInfo->
                                numSc].lac[i] =
                                    CELLULAR_ABSTRACT_INVALID_LAC_ID;

                    CellularAbstractGatewayGetLacList(
                        node,
                        nodeInput,
                        nwCellularAbstractGatewayInfo->numSc,
                        scNodeId);

                    nwCellularAbstractGatewayInfo->numSc ++;

                    //TODO: read the LAC lsit to the sc lac varibale.

                    token =
                        IO_GetDelimitedToken(iotoken,
                                             next, delims, &next);
                }
            }
        }
    }

    //HLR
    for (hlrIndex = 0;
            hlrIndex < CELLULAR_ABSTRACT_MAX_MS_PER_HLR; hlrIndex ++)
    {
        nwCellularAbstractGatewayInfo->hlr[hlrIndex].inUse = FALSE;
    }

    //statistics
    CellularAbstractLayer3InitStats(node, nodeInput);
}//CellularAbstractLayer3GatewayInit
//**********************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3AggregatedNodeInit
// LAYER      :: Layer3
// PURPOSE    :: Initialize AggregatedNode's Cellular Layer protocol
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + nodeInput        : const NodeInput*  : Pointer to node input.
// RETURN     :: void : NULL
// **/
//***********************************************************************
void CellularAbstractLayer3AggregatedNodeInit(Node *node,
                                              const NodeInput *nodeInput)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;

    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    char errorString[MAX_STRING_LENGTH];
    BOOL retVal;
    int readVal;
    int i;

    if (DEBUG_GENERAL)
    {
        printf("node %d: in GATEWAY inti process\n",node->nodeId);
        fflush(stdout);
    }
    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)node->
            networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    nwCellularAbstractData->aggregatedNodeLayer3Info =
        (CellularAbstractLayer3AggregatedNodeInfo *)
            MEM_malloc(sizeof(CellularAbstractLayer3AggregatedNodeInfo));

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;
    memset(nwCellularAbstractAggregatedNodeInfo,
           0,
           sizeof(CellularAbstractLayer3AggregatedNodeInfo));

    nwCellularAbstractAggregatedNodeInfo->aggregatedNodeId = node->nodeId;
    nwCellularAbstractAggregatedNodeInfo->aggregatedNodeAddress =
        MAPPING_GetDefaultInterfaceAddressFromNodeId(node, node->nodeId);

    //gateway
    IO_ReadInt(
        node->nodeId,
        ANY_ADDRESS,
        nodeInput,
        "CELLULAR-AGGREGATED-NODE-CONNECT-GATEWAY",
        &retVal,
        &readVal);
    if (retVal == FALSE)
    {
        sprintf(
            errorString,
            "Node [%d] Could not find its"
            "CELLULAR-AGGREGATED-NODE-CONNECT-GATEWAY\n",
            node->nodeId);
        ERROR_ReportError(errorString);
    }
    else
    {
        // judge if the readVal's node type
        BOOL retValGateway;
        char bufGateway[MAX_STRING_LENGTH];

        IO_ReadString(
            readVal,
            ANY_ADDRESS,
            nodeInput,
            "CELLULAR-NODE-TYPE",
            &retValGateway,
            bufGateway);
        if (retValGateway == FALSE ||
            strcmp(bufGateway,
                   "CELLULAR-GATEWAY") != 0)
        {
            sprintf(errorString,
                "Node [%d]: the claimed connected "
                "GATEWAY %d type is not a Gateway\n",
                node->nodeId, readVal);
            ERROR_ReportError(errorString);
        }

        nwCellularAbstractAggregatedNodeInfo->gatewayNodeId = readVal;
        nwCellularAbstractAggregatedNodeInfo->gatewayNodeAddress =
            MAPPING_GetDefaultInterfaceAddressFromNodeId(node,
                nwCellularAbstractAggregatedNodeInfo->gatewayNodeId);
        if (DEBUG_GENERAL)
        {
            printf(
                "node %d: gateway connect to this aggregated node is %d\n",
                node->nodeId,
                nwCellularAbstractAggregatedNodeInfo->gatewayNodeId);
            fflush(stdout);
        }
    }
    //appInfo
    for (i = 0;i < CELLULAR_ABSTRACT_MAX_ACTIVE_APP_PER_AGGREGATEDNODE; i ++)
    {
        nwCellularAbstractAggregatedNodeInfo->
            aggregatedNodeAppInfo[i].inUse = FALSE;
    }

    nwCellularAbstractAggregatedNodeInfo->isTransactionInProcess = FALSE;
    nwCellularAbstractAggregatedNodeInfo->numActiveApplicaions = 0;
    nwCellularAbstractAggregatedNodeInfo->numTransactions = 0;

    //statistics
    CellularAbstractLayer3InitStats(node, nodeInput);
}//CellularAbstractLayer3AggregatedNodeInit

//*****************************************************************
// /**
// FUNCTION   :: CellularAbstractBsHandleResourceSampleTimer
// LAYER      :: Layer3
// PURPOSE    :: Handle Resource smaple timers.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// RETURN     :: void : NULL
// **/
//*******************************************************************
static
void CellularAbstractBsHandleResourceSampleTimer(Node *node)
{
    CellularAbstractGenericTimerInfo timerInfo;
    char time[MAX_STRING_LENGTH] = {0};

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;
    CellularAbstractSectorInfo *sectorInfo;
    int numSectorInCell;
    int sectorIndex;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData = (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    sectorInfo = nwCellularAbstractBsInfo->bsSectorInfo;

    numSectorInCell = nwCellularAbstractBsInfo->numSectorInCell;

    TIME_PrintClockInSecond(node->getNodeTime(), time);

    if (SAMPLE_STDOUT)
    {
        for (sectorIndex = 0; sectorIndex < numSectorInCell; sectorIndex ++)
        {
            printf(
                "NODE %d TIME %s SECTOR %d USED %f\n",
                node->nodeId, time, sectorInfo[sectorIndex].sectorId,
                sectorInfo[sectorIndex].bandwidthInUse);
            fflush(stdout);
        }
    }
    if (SAMPLE_STDOUT)
    {
        printf(
            "NODE %d TIME %s SECTOR %d USED %f\n",
            node->nodeId, time, 0,
            nwCellularAbstractBsInfo->bandwidthInUse);
        fflush(stdout);
    }

    //change the icon

    //GUI_CELLULAR
    if (node->guiOption == TRUE)
    {
        if (nwCellularAbstractBsInfo->bandwidthInUse == 0)
        {
            GUI_SetNodeIcon( node->nodeId,
                             "icons/BS100.png",
                             node->getNodeTime());
        }
        else if (nwCellularAbstractBsInfo->bandwidthInUse /
            nwCellularAbstractBsInfo->bandwidthAllocated < 0.2)
        {
            GUI_SetNodeIcon( node->nodeId,
                             "icons/BS80-100.png",
                             node->getNodeTime());
        }
        else if (nwCellularAbstractBsInfo->bandwidthInUse /
            nwCellularAbstractBsInfo->bandwidthAllocated < 0.4)
        {
            GUI_SetNodeIcon( node->nodeId,
                             "icons/BS60-80.png",
                             node->getNodeTime());
        }
        else if (nwCellularAbstractBsInfo->bandwidthInUse /
            nwCellularAbstractBsInfo->bandwidthAllocated < 0.6)
        {
            GUI_SetNodeIcon( node->nodeId,
                             "icons/BS40-60.png",
                             node->getNodeTime());
        }
        else if (nwCellularAbstractBsInfo->bandwidthInUse /
            nwCellularAbstractBsInfo->bandwidthAllocated < 0.8)
        {
            GUI_SetNodeIcon( node->nodeId,
                             "icons/BS20-40.png",
                             node->getNodeTime());
        }
        else if (nwCellularAbstractBsInfo->bandwidthInUse /
            nwCellularAbstractBsInfo->bandwidthAllocated < 0.9999)
        {
            GUI_SetNodeIcon( node->nodeId,
                             "icons/BS0-20.png",
                             node->getNodeTime());
        }
        else if (nwCellularAbstractBsInfo->bandwidthInUse /
            nwCellularAbstractBsInfo->bandwidthAllocated >= 0.9999)
        {
            GUI_SetNodeIcon( node->nodeId,
                             "icons/BS0.png",
                             node->getNodeTime());
        }
    }
    //GUI_CELLULAR
    timerInfo.timerType = MSG_NETWORK_CELLULAR_BW_SAMPLE_Timer;
    CellularAbstractLayer3StartTimer(
        node,
        CELLULAR_RESOURCE_USAGE_SAMPLE_INTERVAL,
        &timerInfo,
        sizeof(CellularAbstractGenericTimerInfo));
}

//*******************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3Finalize
// LAYER      :: Layer3
// PURPOSE    :: Print stats and clear protocol variables
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// RETURN     :: void : NULL
// **/
//*********************************************************************
void CellularAbstractLayer3Finalize(Node *node)
{
    if (DEBUG_GENERAL)
    {
        printf("node %d: Cellular Abstract Layer3 Finalize\n",node->nodeId);
        fflush(stdout);
    }
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;

    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    if (nwCellularData->collectStatistics == FALSE &&
       node->networkData.networkStats == FALSE)
    {
        return;
    }
    else
    {
        if (nwCellularData->nodeType == CELLULAR_MS)
        {

            CellularAbstractLayer3MsFinalize(node);
        }
        else if (nwCellularData->nodeType == CELLULAR_BS)
        {
            CellularAbstractLayer3BsFinalize(node);
        }
        else if (nwCellularData->nodeType == CELLULAR_SC)
        {
            CellularAbstractLayer3ScFinalize(node);
        }
        else if (nwCellularData->nodeType == CELLULAR_GATEWAY)
        {
            CellularAbstractLayer3GatewayFinalize(node);
        }
        else if (nwCellularData->nodeType == CELLULAR_AGGREGATED_NODE)
        {
            CellularAbstractLayer3AggregatedNodeFinalize(node);
        }
    }

}//CellularAbstractLayer3Finalize

// /**
// FUNCTION   :: CellularAbstractLayer3MsFinalize
// LAYER      :: Layer3
// PURPOSE    :: Print stats and clear protocol variables
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// RETURN     :: void : NULL
// **/
void CellularAbstractLayer3MsFinalize(Node *node)
{
    char buf[MAX_STRING_LENGTH];

    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;

    sprintf(
        buf,
        "Number of system information received from BSs = %d",
        nwCellularAbstractMsInfo->stats.numSystemInfoRecvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of measurement report received from MAC = %d",
        nwCellularAbstractMsInfo->stats.numMeasurementReportRecvdFromMac);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of cell selection (attach) performed = %d",
        nwCellularAbstractMsInfo->stats.numCellSelectionPerformed);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of cell reselection performed = %d",
        nwCellularAbstractMsInfo->stats.numCellReSelectionPerformed);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of location update attempts made = %d",
        nwCellularAbstractMsInfo->stats.numLocationUpdateAttempt);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of location update request sent to SC = %d",
        nwCellularAbstractMsInfo->stats.numLocationUpdateSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    if (nwCellularAbstractMsInfo->stats.numLocationUpdateAttempt != 0)
    {
        sprintf(
            buf,
            "Average Number of location update request sent per attempt = %f",
            (double)nwCellularAbstractMsInfo->stats.numLocationUpdateSent /
            (double)nwCellularAbstractMsInfo->stats.numLocationUpdateAttempt);
    }
    else
    {
        sprintf(
            buf,
            "Average Number of location update request sent per attempt = 0.0");
    }
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of location update succeeded = %d",
        nwCellularAbstractMsInfo->stats.numLocationUpdateSuccess);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of location update request rejected = %d",
        nwCellularAbstractMsInfo->stats.numLocationUpdateRejected);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of location update failed = %d",
        nwCellularAbstractMsInfo->stats.numLocationUpdateFailaure);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of channel request attempt made = %d",
        nwCellularAbstractMsInfo->stats.numChannelRequestAttempt);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of channel requests sent = %d",
        nwCellularAbstractMsInfo->stats.numChannelRequestSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of immediate assignments received = %d",
        nwCellularAbstractMsInfo->stats.numImmediateAssignmentRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of immediate assignment rejection received = %d",
        nwCellularAbstractMsInfo->stats.numImmediateAssignmentRejectRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of channel requests succeeded = %d",
        nwCellularAbstractMsInfo->stats.numChannelRequestSuccess);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of channel requests failed = %d",
        nwCellularAbstractMsInfo->stats.numChannelRequestFailure);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    if (nwCellularAbstractMsInfo->stats.numChannelRequestAttempt != 0)
    {
        sprintf(
            buf,
            "Average number of channel requests sent per attempt = %f",
            (double)nwCellularAbstractMsInfo->stats.numChannelRequestSent /
            (double)nwCellularAbstractMsInfo->stats.numChannelRequestAttempt);
    }
    else
    {
        sprintf(
            buf,
            "Average number of channel requests sent per attempt = 0.0");
    }
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    if (nwCellularAbstractMsInfo->
                stats.numChannelRequestSent != 0)
    {
        sprintf(
            buf,
            "Average channel access delay(ms) = %f",
            (nwCellularAbstractMsInfo->stats.totalAccessDelay /
             nwCellularAbstractMsInfo->stats.numChannelRequestSent) / 1.0e6);
    }
    else
    {
       sprintf(
            buf,
            "Average channel access delay(ms) = 0.0");
    }
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of CM service requests sent = %d",
        nwCellularAbstractMsInfo->stats.numCmServiceRequestSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of CM service requests accepted = %d",
        nwCellularAbstractMsInfo->stats.numcmServiceAcceptRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of CM service requests rejected = %d",
        nwCellularAbstractMsInfo->stats.numCmServiceRejectRdvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of page requests received = %d",
        nwCellularAbstractMsInfo->stats.numPageRequestRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of page response sent = %d",
        nwCellularAbstractMsInfo->stats.numPageResponseSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of handover required sent to BS = %d",
        nwCellularAbstractMsInfo->stats.numHandoverRequiredSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of radio interface handover received from BS = %d",
        nwCellularAbstractMsInfo->stats.numRIHandoverCommandRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of radio interface handover completed sent to BS = %d",
        nwCellularAbstractMsInfo->stats.numRIHandoverCompleteSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of handover required rejects received from BS = %d",
        nwCellularAbstractMsInfo->stats.numHandoverRequiredRejectRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of voice call originated at MS = %d",
        nwCellularAbstractMsInfo->stats.numVoiceCallSetupInit);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of voice call terminated at MS = %d",
        nwCellularAbstractMsInfo->stats.numVoiceCallSetupRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of data call originated at MS = %d",
        nwCellularAbstractMsInfo->stats.numDataCallActivationSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of data call terminated at MS = %d",
        nwCellularAbstractMsInfo->stats.numDataCallActivationRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of start call request received from application = %d",
        nwCellularAbstractMsInfo->stats.numCallStartRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of end call request received from application = %d",
        nwCellularAbstractMsInfo->stats.numCallEndRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of call reject messages sent to application = %d",
        nwCellularAbstractMsInfo->stats.numCallRejectSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of call dropped messages sent to application = %d",
        nwCellularAbstractMsInfo->stats.numCallDroppedSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);
}

// /**
// FUNCTION   :: CellularAbstractLayer3BsFinalize
// LAYER      :: Layer3
// PURPOSE    :: Print stats and clear protocol variables
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// RETURN     :: void : NULL
// **/
void CellularAbstractLayer3BsFinalize(Node *node)
{
    char buf[MAX_STRING_LENGTH];
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3BsInfo *nwCellularAbstractBsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractBsInfo = nwCellularAbstractData->bsLayer3Info;

    sprintf(
        buf,
        "Number of system information broadcasted = %d",
        nwCellularAbstractBsInfo->stats.numSysInfoSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of channel request received from MS = %d",
        nwCellularAbstractBsInfo->stats.numChannelRequestRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of immediate assignment sent to MS = %d",
        nwCellularAbstractBsInfo->stats.numImmediateAssignmentSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of immediate assignment reject sent to MS = %d",
        nwCellularAbstractBsInfo->stats.numImmediateAssignmentRejectSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of CM service reject by BS sent "
        "to MS (cause: unsupported service) = %d",
        nwCellularAbstractBsInfo->stats.numCmServiceRejectByBsSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of paging received from SC = %d",
        nwCellularAbstractBsInfo->stats.numPagingRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of page request sent to MS = %d",
        nwCellularAbstractBsInfo->stats.numPageRequestSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of page response received from MS = %d",
        nwCellularAbstractBsInfo->stats.numPageResponseRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);


    sprintf(
        buf,
        "Number of MS initiated handover required received from MS = %d",
        nwCellularAbstractBsInfo->stats.numMSInitHandoverRequiredRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of MS initiated handover required forward to SC = %d",
        nwCellularAbstractBsInfo->stats.numMSInitHandoverRequiredFwd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of handover request received from SC = %d",
        nwCellularAbstractBsInfo->stats.numHandoverRequestRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of handover request acknowledgement sent to SC = %d",
        nwCellularAbstractBsInfo->stats.numHandoverRequestAckSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of handover failure sent to SC = %d",
        nwCellularAbstractBsInfo->stats.numHandoverFailureSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
      "Number of MS initiated handover required reject received from SC = %d",
        nwCellularAbstractBsInfo->stats.numMSInitHandoverRequiredRejectRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of MS initiated handover required reject forward to MS = %d",
        nwCellularAbstractBsInfo->stats.numMSInitHandoverRequiredRejectFwd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of handover command received from SC = %d",
        nwCellularAbstractBsInfo->stats.numHandoverCommandRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of Radio interface handover command sent to MS = %d",
        nwCellularAbstractBsInfo->stats.numRIHandoverCommandSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of Radio interface handover complete received from MS = %d",
        nwCellularAbstractBsInfo->stats.numRIHandoverCompleteRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of handover complete received sent to SC = %d",
        nwCellularAbstractBsInfo->stats.numHandoverCompleteSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);
}

// /**
// FUNCTION   :: CellularAbstractLayer3ScFinalize
// LAYER      :: Layer3
// PURPOSE    :: Print stats and clear protocol variables
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// RETURN     :: void : NULL
// **/
void CellularAbstractLayer3ScFinalize(Node *node)
{
    char buf[MAX_STRING_LENGTH];
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3ScInfo *nwCellularAbstractScInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractScInfo= nwCellularAbstractData->scLayer3Info;

    sprintf(
        buf,
        "Number of location update requests received = %d",
        nwCellularAbstractScInfo->stats.numLocationUpdateRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of location update accept sent = %d",
        nwCellularAbstractScInfo->stats.numLocationUpdateAcceptSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of location update rejects sent = %d",
        nwCellularAbstractScInfo->stats.numLocationUpdateRejectSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of MAPD update location sent to HLR = %d",
        nwCellularAbstractScInfo->stats.numMapdUpdateLocationSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of MAPD cancel location received from HLR = %d",
        nwCellularAbstractScInfo->stats.numMapdCancelLocationRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of CM  service requests received = %d",
        nwCellularAbstractScInfo->stats.numCMServiceRequestRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of CM  service accept sent = %d",
        nwCellularAbstractScInfo->stats.numCMServiceAcceptSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of paging sent to BS = %d",
        nwCellularAbstractScInfo->stats.numPagingSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of page response received = %d",
        nwCellularAbstractScInfo->stats.numPageResponseRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of handover required received = %d",
        nwCellularAbstractScInfo->stats.numHandoverRequiredRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of intraCell (InterSector) handover required received = %d",
        nwCellularAbstractScInfo->stats.numIntraCellHandoverRequiredRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of interCell-intraSC handover required received = %d",
        nwCellularAbstractScInfo->
            stats.numInterCellIntraScHandoverRequiredRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of interSC handover required received = %d",
        nwCellularAbstractScInfo->stats.numInterScHandoverRequiredRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of handover request sent to BS = %d",
        nwCellularAbstractScInfo->stats.numHandoverRequestSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of handover request acknowledgement received from BS = %d",
        nwCellularAbstractScInfo->stats.numHandoverRequestAckRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of handover request failure received from BS = %d",
        nwCellularAbstractScInfo->stats.numHandoverFailureRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of handover required reject sent to BS = %d",
        nwCellularAbstractScInfo->stats.numHandoverRequiredRejectSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of handover command sent to BS = %d",
        nwCellularAbstractScInfo->stats.numHandoverCommandSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of handover complete received from BS = %d",
        nwCellularAbstractScInfo->stats.numHandoverCompleteRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

}

// /**
// FUNCTION   :: CellularAbstractLayer3GatewayFinalize
// LAYER      :: Layer3
// PURPOSE    :: Print stats and clear protocol variables
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// RETURN     :: void : NULL
// **/
void CellularAbstractLayer3GatewayFinalize(Node *node)
{
    char buf[MAX_STRING_LENGTH];
    CellularLayer3Data  *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3GatewayInfo *nwCellularAbstractGatewayInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractGatewayInfo =
        nwCellularAbstractData->gatewayLayer3Info;

    sprintf(
        buf,
        "Number of MAPD update location received from VLR = %d",
        nwCellularAbstractGatewayInfo->stats.numMapdUpdateLocationRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of MAPD cancel location sent to VLR = %d",
        nwCellularAbstractGatewayInfo->stats.numMapdCancelLocationSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of interSc MO-MT voice call handled = %d",
        nwCellularAbstractGatewayInfo->stats.numInterScMOMTCall);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of interSc MO-MT data call handled = %d",
        nwCellularAbstractGatewayInfo->stats.numInterScMOMTDataCall);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of MS to aggregated node voice call handled = %d",
        nwCellularAbstractGatewayInfo->stats.numMOFTVoiceCall);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of MS to aggregated node data call handled = %d",
        nwCellularAbstractGatewayInfo->stats.numMOFTDataCall);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of aggregated node to MS voice call handled = %d",
        nwCellularAbstractGatewayInfo->stats.numFOMTVoiceCall);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of aggregated node to MS data call handled = %d",
        nwCellularAbstractGatewayInfo->stats.numFOMTVoiceCall);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);
}

// /**
// FUNCTION   :: CellularAbstractLayer3AggregatedNodeFinalize
// LAYER      :: Layer3
// PURPOSE    :: Print stats and clear protocol variables
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// RETURN     :: void : NULL
// **/
void CellularAbstractLayer3AggregatedNodeFinalize(Node *node)
{
    char buf[MAX_STRING_LENGTH];
    CellularLayer3Data              *nwCellularData;
    CellularAbstractLayer3Data      *nwCellularAbstractData;
    CellularAbstractLayer3AggregatedNodeInfo
        *nwCellularAbstractAggregatedNodeInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        node->networkData.cellularLayer3Var->cellularAbstractLayer3Data;

    //thrid hierarchy
    nwCellularAbstractAggregatedNodeInfo =
        nwCellularAbstractData->aggregatedNodeLayer3Info;


    sprintf(
        buf,
        "Number of aggregated node to MS voice call initiated = %d",
        nwCellularAbstractAggregatedNodeInfo->
            stats.numVoiceCallSetupInit);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of MS to aggregated node voice call received = %d",
        nwCellularAbstractAggregatedNodeInfo->
            stats.numVoiceCallSetupRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of aggregated node to MS data call initiated = %d",
        nwCellularAbstractAggregatedNodeInfo->
            stats.numDataCallActivationSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of MS to aggregated node data call received = %d",
        nwCellularAbstractAggregatedNodeInfo->
            stats.numDataCallActivationRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of start call request received from application = %d",
        nwCellularAbstractAggregatedNodeInfo->stats.numCallStartRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of end call request received from application = %d",
        nwCellularAbstractAggregatedNodeInfo->stats.numCallEndRcvd);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of call reject messages sent to application = %d",
        nwCellularAbstractAggregatedNodeInfo->stats.numCallRejectSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);

    sprintf(
        buf,
        "Number of call dropped messages sent to application = %d",
        nwCellularAbstractAggregatedNodeInfo->stats.numCallDroppedSent);
    IO_PrintStat(
                node,
                "CELLULAR LAYER3",
                "CELLULAR",
                ANY_DEST,
                node->nodeId,
                buf);
}

//**************************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3Layer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers and layer messages.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// RETURN     :: void : NULL
// **/
//**************************************************************************
void CellularAbstractLayer3Layer(Node *node, Message *msg)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
        nwCellularData->cellularAbstractLayer3Data;

    if (DEBUG_GENERAL)
    {
        printf("node %d: Cellular Abstract Layer3 Process Event\n",
                node->nodeId);
        fflush(stdout);
    }

    if (nwCellularData->nodeType == CELLULAR_MS)
    {
        //thrid hierarchy
        nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;
        if (nwCellularAbstractMsInfo->isPowerOn == FALSE)
        {
            if (msg->eventType == MSG_CELLULAR_PowerOn)
            {
                CellularAbstractMsHandlePowerOnMsg(node, msg);
                if (nwCellularAbstractData->optLevel !=
                        CELLULAR_ABSTRACT_OPTIMIZATION_LOW)
                {
                    CellularAbstractLayer3Callback(node);
                }
            }
            MESSAGE_Free(node, msg);
            return;
        }
    }

    switch((msg->eventType))
    {
        //Timer expired is called most frequently, so put ahead of other events
        //message from this node's own network layer,e.g.,timer
        //MSG_NETWORK_CELLULAR_SystemInfoTimer only valid for BS
        case MSG_NETWORK_CELLULAR_TimerExpired:
        {
            char* msgInfo;
            msgInfo =(char*)MESSAGE_ReturnInfo(msg);
            CellularAbstractNetworkTimerType timerType;
            memcpy((void*)&timerType,
                   (void*)(msgInfo),
                   sizeof(CellularAbstractNetworkTimerType));

            if (DEBUG_GENERAL)
            {
                printf(
                    "node %d,receive timerType %d\n",
                    node->nodeId,timerType);
                fflush(stdout);
            }

            switch (timerType)
            {
                case MSG_NETWORK_CELLULAR_SystemInfoTimer:
                {

                    CellularAbstractBsProcessSystemInfoTimer(node, msg);
                    MESSAGE_Free(node, msg);
                    break;
                }
                case
                    MSG_NETWORK_CELLULAR_WaitForChannelRequestResponseTimer:
                {
                    CellularAbstractMsProcessChannelRequestTimer(node, msg);
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_ImmediateAssignmentTimer_T3101:
                {
                    if (DEBUG_GENERAL)
                    {
                        printf(
                            "node %d NW: ready immediat tiemrr %d\n",
                            node->nodeId,timerType);
                        fflush(stdout);
                    }
                    CellularAbstractBsProcessImmediateAssignmentTimer(
                        node, msg);
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_T3126Timer:
                {
                    CellularAbstractMsProcessT3126Timer(node, msg);
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_T3210Timer://location update timer
                {
                    CellularAbstractMsProcessT3210Timer(node, msg);
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_T3211Timer:
                {
                    //location update failure timer
                    CellularAbstractMsProcessT3211Timer(node, msg);
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_T3212Timer:
                {
                    CellularAbstractMsProcessT3212Timer(node, msg);
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_T3230Timer:
                {
                    //CM servicce request timer
                    CellularAbstractMsProcessT3230Timer(node, msg);
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_T3110Timer://cahnnel release
                {
                    CellularAbstractMsProcessT3110Timer(node, msg);
                    MESSAGE_Free(node, msg);
                    break;
                }

                case MSG_NETWORK_CELLULAR_T3111Timer://channel release
                {
                    CellularAbstractBsProcessT3111Timer(node, msg);
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_T301Timer://waitng for connecting
                {
                    CellularAbstractScProcessT301Timer(node, msg);
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_T303Timer://call proceeding timer
                {
                    if (nwCellularData->nodeType == CELLULAR_MS)
                    {
                        CellularAbstractMsProcessT303Timer(node, msg);
                    }
                    else if (nwCellularData->nodeType == CELLULAR_SC)
                    {
                        CellularAbstractScProcessT303Timer(node, msg);
                    }
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_T305Timer:
                {
                    //MS start after call disconnect send
                    if (nwCellularData->nodeType == CELLULAR_MS)
                    {
                        CellularAbstractMsProcessT305Timer(node, msg);
                    }
                    else if (nwCellularData->nodeType == CELLULAR_SC)
                    {
                        CellularAbstractScProcessT303Timer(node, msg);
                    }
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_T308Timer:
                {
                    //MS start after call disconnect send
                    if (nwCellularData->nodeType == CELLULAR_MS)
                    {
                        CellularAbstractMsProcessT308Timer(node, msg);
                    }
                    else if (nwCellularData->nodeType==CELLULAR_SC)
                    {
                        CellularAbstractScProcessT308Timer(node,msg);
                    }
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_T310Timer://call proceeding timer
                {
                    if (nwCellularData->nodeType == CELLULAR_MS)
                    {
                        CellularAbstractMsProcessT310Timer(node, msg);
                    }
                    else if (nwCellularData->nodeType == CELLULAR_SC)
                    {
                        CellularAbstractScProcessT310Timer(node, msg);
                    }
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_T313Timer://call proceeding timer
                {
                    if (nwCellularData->nodeType == CELLULAR_MS)
                    {
                        CellularAbstractMsProcessT313Timer(node, msg);
                    }
                    else if (nwCellularData->nodeType == CELLULAR_SC)
                    {
                        CellularAbstractScProcessT313Timer(node, msg);

                    }
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_T3113Timer:
                {
                    CellularAbstractBsProcessT3113Timer(node, msg);
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_T3240Timer:
                {

                    CellularAbstractMsProcessT3240Timer(node, msg);
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_PDP_DEACTIVATION_Timer:
                {
                    if (nwCellularData->nodeType == CELLULAR_SC)
                    {
                        CellularAbstractScProcessPDPDeactivationTimer(
                            node, msg);
                    }
                    else if (nwCellularData->nodeType ==
                        CELLULAR_AGGREGATED_NODE)
                    {

                CellularAbstractAggregatedNodeProcessPDPDeactivationTimer
                        (node, msg);
                    }
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_PAGING_Timer:
                {
                    CellularAbstractScHandlePagingTimer(node, msg);
                    MESSAGE_Free(node, msg);
                    break;
                }
                case MSG_NETWORK_CELLULAR_BW_SAMPLE_Timer:
                {
                    CellularAbstractBsHandleResourceSampleTimer(node);
                    MESSAGE_Free(node, msg);
                    break;
                }
                default:
                {
                    printf(
                        "node %d NW: Unknow timer%d\n",
                        node->nodeId,timerType);
                    MESSAGE_Free(node, msg);
                    assert(FALSE);
                    abort();
                    break;
                }
            }
            break;
        }
        //message from application layer
        case MSG_CELLULAR_PowerOn:
        {
            if (nwCellularData->nodeType == CELLULAR_MS)
            {
                CellularAbstractMsHandlePowerOnMsg(node, msg);
                if (nwCellularAbstractData->optLevel !=
                        CELLULAR_ABSTRACT_OPTIMIZATION_LOW)
                {
                    CellularAbstractLayer3Callback(node);
                }
            }
            MESSAGE_Free(node, msg);
            break;
        }
        case MSG_CELLULAR_PowerOff:
        {
            if (nwCellularData->nodeType == CELLULAR_MS)
            {
                CellularAbstractMsHandlePowerOffMsg(node, msg);
            }
            MESSAGE_Free(node, msg);
            break;
        }

        case MSG_NETWORK_CELLULAR_FromAppStartCall:
        {
            //only MS or aggregated node have such message
            if (DEBUG_GENERAL)
            {
                printf(
                    "node %d: Cellular Abstract Layer3:"
                    "process FromAppStartCall\n",
                    node->nodeId);
                fflush(stdout);
            }
            if (nwCellularData->nodeType == CELLULAR_MS)
            {
                CellularAbstractMsHandleStartCallMsg(node, msg);
            }
            else if (nwCellularData->nodeType == CELLULAR_AGGREGATED_NODE)
            {
                CellularAbstractAggregatedNodeHandleStartCallMsg(node, msg);
            }

            MESSAGE_Free(node, msg);
            break;
        }

        case MSG_NETWORK_CELLULAR_FromAppEndCall:
        //only MS or aggregated node have such message
        {
            if (DEBUG_GENERAL)
            {
                printf(
                    "node %d: Cellular Abstract Layer3:"
                    "process FromAppEndCall\n",
                    node->nodeId);
                fflush(stdout);
            }
            if (nwCellularData->nodeType == CELLULAR_MS)
            {
                CellularAbstractMsHandleEndCallMsg(node, msg);
            }
            else if (nwCellularData->nodeType == CELLULAR_AGGREGATED_NODE)
            {
                CellularAbstractAggregatedNodeHandleEndCallMsg(node, msg);
            }

            MESSAGE_Free(node, msg);
            break;
        }
        case MSG_NETWORK_CELLULAR_FromAppCallAnswered:
        {
            if (DEBUG_GENERAL)
            {
                printf(
                    "node %d: Cellular Abstract Layer3:"
                    "process FromAppCallAnswered\n",
                    node->nodeId);
                fflush(stdout);
            }

            if (nwCellularData->nodeType == CELLULAR_MS)
            {
                CellularAbstractMsHandleCallAnsweredMsg(node, msg);
            }
            else if (nwCellularData->nodeType == CELLULAR_AGGREGATED_NODE)
            {
                CellularAbstractAggregatedNodeHandleCallAnsweredMsg(
                    node, msg);
            }

            MESSAGE_Free(node, msg);
            break;
        }
        case MSG_NETWORK_CELLULAR_FromMacNetworkNotFound:
        {
            if (DEBUG_CELLSELECTION)
            {
                printf(
                    "node %d: Cellular Abstract Layer3:"
                    "FromMacNetworkNotFound\n",
                    node->nodeId);
                fflush(stdout);
            }

            CellularAbstractMsHandleNoNetworkFoundMsg(node, msg);
            MESSAGE_Free(node, msg);
            break;
        }
        case MSG_NETWORK_CELLULAR_FromMacMeasurementReport:
        {
            CellularAbstractMsHandleMeasurementReportFromMac(node, msg);
            MESSAGE_Free(node, msg);
            break;
        }
        case MSG_NETWORK_CELLULAR_PollHandoverForCallManagement:
        {
            CellularProtocolDiscriminator protocolDiscriminator;
            CellularAbstractMessageType messageType;

            CellularAbstractRemoveLayer3MsgHeader(
                node,
                msg,
                &protocolDiscriminator,
                &messageType);
            if (protocolDiscriminator == CELLULAR_PD_CC)
            {
                if (nwCellularData->nodeType == CELLULAR_MS)
                {
                    CellularAbstractMsHandleCCControlPacket(
                        node, msg, messageType);
                }
                else if (nwCellularData->nodeType == CELLULAR_SC)
                {
                    CellularAbstractScHandleCCControlPacket(
                        node, msg, messageType);
                }
                else
                {
                    MESSAGE_Free(node, msg);
                }
            }
            if (protocolDiscriminator == CELLULAR_PD_SM)
            {
                if (nwCellularData->nodeType == CELLULAR_MS)
                {
                    CellularAbstractMsHandleSMControlPacket(
                        node, msg, messageType);
                }
                else if (nwCellularData->nodeType == CELLULAR_SC)
                {
                    CellularAbstractScHandleSMControlPacket(
                        node, msg, messageType);
                }
                else
                {
                    MESSAGE_Free(node, msg);
                }
            }
            break;
        }
        default:
        {
            printf(
                "node %d:CELLULAR ABSTRACT LAYER3:"
                "Protocol = %d\n", node->nodeId,
                MESSAGE_GetProtocol(msg));
            MESSAGE_Free(node, msg);
            assert(FALSE);
            abort();
            break;
        }
    }
}//CellularAbstractLayer3Layer

//************************************************************************
// /**
// FUNCTION   :: CellularAbstractReceivePacketFromMacLayer
// LAYER      :: Layer3
// PURPOSE    :: Handle timers and layer messages.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret.
// + lastHopAddress   : NodeAddress       : Address of the last hop
// + interfaceIndex   : int               : Interface
// RETURN     :: void : NULL
// **/
//************************************************************************
void CellularAbstractReceivePacketFromMacLayer(Node *node,
                                               Message *msg,
                                               NodeAddress lastHopAddress,
                                               int interfaceIndex)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    CellularProtocolDiscriminator protocolDiscriminator;
    CellularAbstractMessageType messageType;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;

    if (nwCellularData->nodeType == CELLULAR_MS)
    {
        //thrid hierarchy
        nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;
        if (nwCellularAbstractMsInfo->isPowerOn == FALSE)
        {
            MESSAGE_Free(node, msg);
            return;
        }
    }

    CellularAbstractRemoveLayer3MsgHeader(
        node,
        msg,
        &protocolDiscriminator,
        &messageType);

    //all the msg has been removed the header added by the sender
    if (protocolDiscriminator == CELLULAR_PD_CC)
    {
        if (nwCellularData->nodeType == CELLULAR_MS)
        {
            CellularAbstractMsHandleCCControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_BS)
        {
            CellularAbstractBsHandleCCControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_SC)
        {
            CellularAbstractScHandleCCControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_GATEWAY)
        {
            CellularAbstractGatewayHandleCCControlPacket(
                node,msg,messageType);
        }
        else if (nwCellularData->nodeType ==
            CELLULAR_AGGREGATED_NODE)
        {
            CellularAbstractAggregatedNodeHandleCCControlPacket(
                node, msg, messageType);
        }
        else
        {
            MESSAGE_Free(node, msg);
        }
    }
    else if (protocolDiscriminator == CELLULAR_PD_MM)
    {
        if (nwCellularData->nodeType == CELLULAR_MS)
        {
            CellularAbstractMsHandleMMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_BS)
        {
            CellularAbstractBsHandleMMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_SC)
        {
            CellularAbstractScHandleMMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_GATEWAY)
        {
            CellularAbstractGatewayHandleMMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_AGGREGATED_NODE)
        {
            CellularAbstractAggregatedNodeHandleMMControlPacket(
                node, msg, messageType);
        }
        else
        {
            MESSAGE_Free(node, msg);
        }
    }
    else if (protocolDiscriminator == CELLULAR_PD_RR)
    {
        if (nwCellularData->nodeType == CELLULAR_MS)
        {
            CellularAbstractMsHandleRRControlPacket
                (node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_BS)
        {
            CellularAbstractBsHandleRRControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_SC)
        {
            CellularAbstractScHandleRRControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_GATEWAY)
        {
            CellularAbstractGatewayHandleRRControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_AGGREGATED_NODE)
        {
            CellularAbstractAggregatedNodeHandleRRControlPacket(
                node, msg, messageType);
        }
        else
        {
            MESSAGE_Free(node, msg);
        }
    }
    else if (protocolDiscriminator == CELLULAR_PD_APP)
    {
        if (nwCellularData->nodeType == CELLULAR_MS)
        {
            CellularAbstractMsHandleTrafficPacket(node, msg);
        }
        else if (nwCellularData->nodeType == CELLULAR_BS)
        {
            CellularAbstractBsHandleTrafficPacket(node, msg);
        }
        else if (nwCellularData->nodeType == CELLULAR_SC)
        {
            CellularAbstractScHandleTrafficPacket(node, msg);
        }
        else if (nwCellularData->nodeType == CELLULAR_GATEWAY)
        {
            CellularAbstractGatewayHandleTrafficPacket(node, msg);
        }
        else if (nwCellularData->nodeType == CELLULAR_AGGREGATED_NODE)
        {
            CellularAbstractAggregatedNodeHandleTrafficPacket(node, msg);
        }
        else
        {
            MESSAGE_Free(node, msg);
        }
    }
    else if (protocolDiscriminator == CELLULAR_PD_SM)
    {
        if (nwCellularData->nodeType == CELLULAR_MS)
        {
            CellularAbstractMsHandleSMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_BS)
        {
            CellularAbstractBsHandleSMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_SC)
        {
            CellularAbstractScHandleSMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_GATEWAY)
        {
            CellularAbstractGatewayHandleSMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_AGGREGATED_NODE)
        {
            CellularAbstractAggregatedNodeHandleSMControlPacket(
                node, msg, messageType);
        }
        else
        {
            MESSAGE_Free(node, msg);
        }
    }
    else
    {
        //error happen
        printf(
            "CELLULAR ABSTRACT LAYER3: Protocol = %d,"
            "unknown protocolDiscriminator\n",
            MESSAGE_GetProtocol(msg));
        MESSAGE_Free(node, msg);
        assert(FALSE);
        abort();
    }

}
//*************************************************************************
// /**
// FUNCTION   :: CellularAbstractLayer3ReceivePacketOverIp
// LAYER      :: Layer3
// PURPOSE    :: Handle timers and layer messages.
// PARAMETERS ::
// + node             : Node*             : Pointer to node.
// + msg              : Message*          : Message for node to interpret
// + sourceAddress    : Address       : Message from node
// RETURN     :: void : NULL
// **/
//**************************************************************************
void CellularAbstractLayer3ReceivePacketOverIp(Node *node,
                                       Message *msg,
                                       Address sourceAddress)
{
    CellularLayer3Data *nwCellularData;
    CellularAbstractLayer3Data *nwCellularAbstractData;
    CellularAbstractLayer3MsInfo *nwCellularAbstractMsInfo;

    CellularProtocolDiscriminator protocolDiscriminator;
    CellularAbstractMessageType messageType;

    //First hierarchy
    nwCellularData =
        (CellularLayer3Data *)node->networkData.cellularLayer3Var;

    //second hierachy
    nwCellularAbstractData =
        (CellularAbstractLayer3Data *)
            nwCellularData->cellularAbstractLayer3Data;
    if (DEBUG_GENERAL)
     {
        printf("nodeId %d:process packet from IP\n",
            node->nodeId);
        fflush(stdout);
     }

    if (nwCellularData->nodeType == CELLULAR_MS)
    {
        //thrid hierarchy
        nwCellularAbstractMsInfo = nwCellularAbstractData->msLayer3Info;


        if (nwCellularAbstractMsInfo->isPowerOn == FALSE)
        {
            MESSAGE_Free(node, msg);
            return;
        }
    }

    CellularAbstractRemoveLayer3MsgHeader(
        node,
        msg,
        &protocolDiscriminator,&messageType);

    //all the msg has been removed the header added by the sender
    if (protocolDiscriminator == CELLULAR_PD_CC)
    {
        if (nwCellularData->nodeType == CELLULAR_MS)
        {
            CellularAbstractMsHandleCCControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_BS)
        {
            CellularAbstractBsHandleCCControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_SC)
        {
            CellularAbstractScHandleCCControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_GATEWAY)
        {
            CellularAbstractGatewayHandleCCControlPacket(
                node,msg,messageType);
        }
        else if (nwCellularData->nodeType ==
            CELLULAR_AGGREGATED_NODE)
        {
            CellularAbstractAggregatedNodeHandleCCControlPacket(
                node, msg, messageType);
        }
        else
        {
            MESSAGE_Free(node, msg);
        }
    }
    else if (protocolDiscriminator == CELLULAR_PD_MM)
    {
        if (nwCellularData->nodeType == CELLULAR_MS)
        {
            CellularAbstractMsHandleMMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_BS)
        {
            CellularAbstractBsHandleMMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_SC)
        {
            CellularAbstractScHandleMMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_GATEWAY)
        {
            CellularAbstractGatewayHandleMMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_AGGREGATED_NODE)
        {
            CellularAbstractAggregatedNodeHandleMMControlPacket(
                node, msg, messageType);
        }
        else
        {
            MESSAGE_Free(node, msg);
        }
    }
    else if (protocolDiscriminator == CELLULAR_PD_RR)
    {
        if (nwCellularData->nodeType == CELLULAR_MS)
        {
            CellularAbstractMsHandleRRControlPacket
                (node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_BS)
        {
            CellularAbstractBsHandleRRControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_SC)
        {
            CellularAbstractScHandleRRControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_GATEWAY)
        {
            CellularAbstractGatewayHandleRRControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_AGGREGATED_NODE)
        {
            CellularAbstractAggregatedNodeHandleRRControlPacket(
                node, msg, messageType);
        }
        else
        {
            MESSAGE_Free(node, msg);
        }
    }
    else if (protocolDiscriminator == CELLULAR_PD_APP)
    {
        if (nwCellularData->nodeType == CELLULAR_MS)
        {
            CellularAbstractMsHandleTrafficPacket(node, msg);
        }
        else if (nwCellularData->nodeType == CELLULAR_BS)
        {
            CellularAbstractBsHandleTrafficPacket(node, msg);
        }
        else if (nwCellularData->nodeType == CELLULAR_SC)
        {
            CellularAbstractScHandleTrafficPacket(node, msg);
        }
        else if (nwCellularData->nodeType == CELLULAR_GATEWAY)
        {
            CellularAbstractGatewayHandleTrafficPacket(node, msg);
        }
        else if (nwCellularData->nodeType == CELLULAR_AGGREGATED_NODE)
        {
            CellularAbstractAggregatedNodeHandleTrafficPacket(node, msg);
        }
        else
        {
            MESSAGE_Free(node, msg);
        }
    }
    else if (protocolDiscriminator == CELLULAR_PD_SM)
    {
        if (nwCellularData->nodeType == CELLULAR_MS)
        {
            CellularAbstractMsHandleSMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_BS)
        {
            CellularAbstractBsHandleSMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_SC)
        {
            CellularAbstractScHandleSMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_GATEWAY)
        {
            CellularAbstractGatewayHandleSMControlPacket(
                node, msg, messageType);
        }
        else if (nwCellularData->nodeType == CELLULAR_AGGREGATED_NODE)
        {
            CellularAbstractAggregatedNodeHandleSMControlPacket(
                node, msg, messageType);
        }
        else
        {
            MESSAGE_Free(node, msg);
        }
    }
    else
    {
        //error happen
        printf(
            "CELLULAR ABSTRACT LAYER3: Protocol = %d,"
            "unknown protocolDiscriminator\n",
            MESSAGE_GetProtocol(msg));
        MESSAGE_Free(node, msg);
        assert(FALSE);
        abort();
    }
}

